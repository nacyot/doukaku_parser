---
:id: '32'
:title: メソッド名一覧の表示
:comments:
- :id: '3388'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/3388
  :user_name: にしお
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/26 08:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  リフレクション系のお題の続編です。\r\n<p>\r\n「ある与えられたオブジェクト<em>target</em>のメソッドのうち、\r\n\"test_\"で始まるものをすべて呼びだす」というコードを書いてください。\r\n引数に関しては都合のいいように仮定して構いません(全部0個、など)。\r\n</p>\n<p>\r\nメソッドという概念がない言語の場合は、\r\n「複数の関数への参照を持っているようなオブジェクト(たとえばパッケージとかモジュールとか)から\"test_\"で始まる関数をすべて呼び出す」と読み替えても構いません。\r\n\t</p>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1459'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1459
  :user_name: ocean
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/07/26 09:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    import types

    class A:
        def __init__(self):
            self.bar = 0
            self.test_bar = 1
            self.baz = []
            self.test_baz = {}
        def foo(self):
            print "foo"
        def test_foo(self):
            print "test_foo"
        def boo(self):
            print "boo"
        def test_boo(self):
            print "test_boo"

    def call_tests(obj):
        for name in dir(obj):
            if name.startswith("test_"):
                attr = getattr(obj, name)
                if isinstance(attr, types.MethodType):
                    attr()

    def main():
        call_tests(A())

    if __name__ == '__main__':
        main()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1461'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1461
  :user_name: yuin
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/82/
  :language: Ruby
  :time: 2007/07/26 09:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    class Foo
      private;   def test_foo()   puts("test_foo_private") end
      public;   def test_foo2()   puts("test_foo_public") end
      protected; def test_fuga()  puts("test_fuga") end
      public;    def public_foo() puts("public_foo")   end
    end

    obj = Foo.new
    ["methods","private_methods"].collect{|m| obj.send(m).grep(/^test_/)}.flatten.each{|m| obj.instance_eval m}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1462'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1462
  :user_name: ether
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/96/
  :language: Tcl
  :time: 2007/07/26 10:15 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n\t"
  :code: |
    info commands target::test_*
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1463'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1463
  :user_name: ether
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/96/
  :language: Tcl
  :time: 2007/07/26 10:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  呼び出すって実行するところまでだと気づいたので修正。引数はなしで。\n\t"
  :code: |
    foreach cmd [info commands target::test_*] { $cmd }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1464'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1464
  :user_name: rubikitch
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/26 10:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Common Lispのメソッドはクラス内の概念ではないので「複数の関数への参照を持っているようなオブジェクト(たとえばパッケージとかモジュールとか)から\"test_\"で始まる関数をすべて呼び出す」\r\n\r\n関数名はLisp的にはtest-なんだけどね～\n\t"
  :code: |
    (require :cl-ppcre)
    (defun test_1 () 1)
    (defun test_2 () 2)
    (defun test_3 () 3)

    (loop for f in (ppcre:regex-apropos-list "^test_" *package*)
       collect (cons f (funcall f)))        ; =&gt; ((TEST_1 . 1) (TEST_3 . 3) (TEST_2 . 2))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1465'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1465
  :user_name: halt
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/309/
  :language: PHP
  :time: 2007/07/26 10:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">get_class_methods関数を使うと簡単にメソッド一覧を取得できます。</pre>\n\t"
  :code: |
    &lt;?php
    class Doukaku
    {
        function Doukaku()
        {
        }

        function test_Doukaku()
        {
        }

        function hello()
        {
            print("hello world!");
        }

        function test_hello()
        {
        }
    }

    $doukaku = new Doukaku();
    $result = array();
    foreach (get_class_methods($doukaku) as $method) {
        if (strpos($method, "test_") === 0) {
            $result[] = $method;
        }
    }

    var_dump($result);
    ?&gt;
  :tags:
  - miss
  :references:
    :url: 
    :title: 
- :id: '1466'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1466
  :user_name: halt
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/309/
  :language: PHP
  :time: 2007/07/26 10:47 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">実行するとこが抜けてたorz</pre>\n\t"
  :code: |
    &lt;?php
    class Doukaku
    {
        function php()
        {
            print("php\n");
        }

        function test_php()
        {
            print("test_php\n");
        }

        function hello()
        {
            print("hello\n");
        }

        function test_hello()
        {
            print("test_hello\n");
        }
    }

    $doukaku = new Doukaku();
    $result = array();
    foreach (get_class_methods($doukaku) as $method) {
        if (strpos($method, "test_") === 0) {
            $doukaku-&gt;$method();
        }
    }

    ?&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1467'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1467
  :user_name: yuin
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/26 10:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">setAccessibleしないといけないのがなんとも。</pre>\n\t"
  :code: |
    class Foo {
      private def test_foo = println("test_foo_private")
      def test_foo2 = println("test_foo_public")
      protected def test_fuga = println("test_fuga")
      def public_foo = println("public_foo")
    }

    val foo = new Foo
    foo.getClass.getDeclaredMethods.filter(_.getName.startsWith("test_"))
       .map(x=&gt;{x.setAccessible(true);x}).foreach(_.invoke(foo,Array()))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1468'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1468
  :user_name: odz
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/212/
  :language: Python
  :time: 2007/07/26 11:05 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  inspect モジュールの出番。\r\nclassmethod も呼んでしまうのはどうにかならんかな。\n\t"
  :code: |
    import inspect

    def call_tests(target):
        methods = [method for name, method in inspect.getmembers(target, inspect.ismethod) if name.startswith('test_')]
        for method in methods: method()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1470'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1470
  :user_name: mimizu
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/103/
  :language: Java
  :time: 2007/07/26 12:43 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n\t"
  :code: "import java.lang.reflect.Method;\n\npublic class TestMethods {\n    \n    public
    static void test(Object target) {\n        Class targetClass = target.getClass();\n
    \       Method[] methods = targetClass.getDeclaredMethods();\n        for (Method
    method : methods) {\n            if (method.getName().startsWith(\"test_\")) {\n
    \               try {\n                    method.invoke(target);\n                }\n
    \               catch (Exception e) {}\n            }\n        }\n    }\n    \n
    \   public static void main(String[] args) {\n        test(new Test());\n    }\n
    \   \n}\n\nclass Test {\n    public void test_public() {\n        System.out.println(\"public
    method\");\n    }\n    protected void test_protected() {\n        System.out.println(\"protected
    method\");\n    }\n    void test_package_private() {\n        System.out.println(\"package
    private method\");\n    }\n    private void test_private() {\n        System.out.println(\"private
    method\");\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1471'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1471
  :user_name: ocean
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/177/
  :language: JavaScript
  :time: 2007/07/26 12:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  上のコードをJavaScriptに移植。IE6とFirefox2で動作確認。\n\t"
  :code: |
    function A()
    {
        this.bar = 1;
        this.test_bar = 2;
        this.baz = [];
        this.test_baz = {};
    }

    A.prototype.foo = function()
    {
        alert("foo");
    }

    A.prototype.test_foo = function()
    {
        alert("test_foo");
    }

    A.prototype.boo = function()
    {
        alert("boo");
    }

    A.prototype.test_boo = function()
    {
        alert("test_boo");
    }

    function call_tests(obj)
    {
        for (var name in obj)
        {
            var attr = obj[name];

            if (attr instanceof Function &amp;&amp; name.indexOf("test_") == 0)
            {
                attr();
            }
        }
    }

    call_tests(new A());
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1472'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1472
  :user_name: sumim
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/26 12:49 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Squeak Smalltalk で。\n\t"
  :code: |
    target class selectors select: [:sel | sel beginsWith: #test]
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '1474'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1474
  :user_name: morchin
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/07/26 13:10 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">以下の特徴を持つ。\r\n・call_tests()の第一引数にはクラスとインスタンスのどちらでも渡せる。\r\n・ベースクラスのメソッドも呼ぶか、指定したクラスのみのメソッドしか呼ばないかを指定可能。\r\n・staticmethodを呼ぶかどうかを指定可能。\r\n</pre>\n\t"
  :code: "import types\n\nclass A:\n\ta1 = 1\n\ttest_a1 = 1\n\tdef __init__(self):\n\t\tself.a2
    = 2\n\t\tself.test_a2 = 2\n\tdef a3(self):\n\t\tprint \"a3 called!\"\n\tdef test_a3(self):\n\t\tprint
    \"test_a3 called!\"\n\nclass B(A):\n\tdef b1(self):\n\t\tprint 'b1 called!'\n\tdef
    test_b1(self):\n\t\tprint 'test_b1 called!'\n\t@staticmethod\n\tdef test_b2():\n\t\tprint
    'test_b2 called!'\n\ndef call_tests(obj, single_level=False, call_static=True):\n\tif
    isinstance(obj, types.InstanceType):\n\t\tcls = obj.__class__\n\telif isinstance(obj,
    types.ClassType):\n\t\tcls = obj\n\t\tobj = obj()  # obj is bound to instance
    object.\n\telse:\n\t\treturn\n\t# make dict of attributes\n\tnames = cls.__dict__\n\tfor
    base in cls.__bases__:\n\t\tnames.update(base.__dict__)\n\tif single_level:\n\t\tfor
    base in cls.__bases__:\n\t\t\tfor name in base.__dict__:\n\t\t\t\tif hasattr(base,
    name):\n\t\t\t\t\tdel names[name]\n\tfor name in sorted(names):\n\t\tif name[:5]
    == 'test_':\n\t\t\tif call_static:\n\t\t\t\ttry:\n\t\t\t\t\tgetattr(obj, name)()
    \ # EAFP\n\t\t\t\texcept:\n\t\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tf = names[name]\n\t\t\t\tif
    callable(f):\n\t\t\t\t\tf(obj)\n\nif __name__ == '__main__':\n\tcall_tests(B,
    0, 0)\n\tprint '==='\n\tcall_tests(B, 1, 0)\n\tprint '==='\n\tcall_tests(B, 0,
    1)\n\tprint '==='\n\tcall_tests(B, 1, 1)\n# output:\n# test_a3 called!\n# test_b1
    called!\n# ===\n# test_b1 called!\n# ===\n# test_a3 called!\n# test_b1 called!\n#
    test_b2 called!\n# ===\n# test_b1 called!\n# test_b2 called!\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1476'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1476
  :user_name: 匿名
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/07/26 14:53 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  引数つきのメソッドでも呼び出せるようにしてみました。プリミティブ型なら 0（または false）、参照型なら null を渡すようにしています。\n\t"
  :code: |
    import java.lang.reflect.Method;

    public class Sample {
        public static void callTest(Object target) throws Exception {
            Class c = target.getClass();
            Method[] ms = c.getMethods();
            for (int i = 0; i &lt; ms.length; i++) {
                if (ms[i].getName().startsWith("test_")) {
                    Class[] argTypes = ms[i].getParameterTypes();
                    Object[] args = new Object[argTypes.length];
                    for (int j = 0; j &lt; argTypes.length; j++) {
                        if (argTypes[j] == Character.TYPE) {
                            args[j] = Character.valueOf((char) 0);
                        } else if (argTypes[j] == Boolean.TYPE) {
                            args[j] = Boolean.valueOf(false);
                        } else if (argTypes[j].isPrimitive()) {
                            args[j] = Byte.valueOf((byte)0);
                        } else {
                            args[j] = null;
                        }
                    }
                    ms[i].invoke(target, args);
                }
            }
        }

        public void test_1(int i) {
            System.out.println("test_1 called");
        }

        private int test_2() {
            System.out.println("test_2 called");
            return 0;
        }

        public static void test_3(char c) {
            System.out.println("test_3 called");
        }

        public void test_4(byte by, boolean b, short s, String str, double d) {
            System.out.println("test_4 called");
        }

        public static void main(String[] args) throws Exception {
            callTest(new Sample());
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1477'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1477
  :user_name: cats
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/172/
  :language: C
  :time: 2007/07/26 14:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    using System;
    using System.Reflection;
    class Program
    {
      class Test
      {
        void test_1() { Console.WriteLine("1"); }
        static void test_2() { Console.WriteLine("2"); }
      }
      static void Main()
      {
        CallTest(new Test());
      }
      static void CallTest(object o)
      {
        foreach (MethodInfo mi in o.GetType().GetMethods(
          BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static))
          if (mi.Name.StartsWith("test_")) mi.Invoke(o, new object[0]);
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1478'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1478
  :user_name: kkobayashi
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/26 15:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  題意の解釈によって色々書き方があると思いますが、一例として。\n\t"
  :code: |
    obj &lt;- list(
            test_f1 = function(){ print("f1") }, # OK
            text_f2 = function(){ print("f2") }, # NG
            txet_f3 = function(){ print("f3") }, # NG
            tesx_f4 = function(){ print("f4") }, # NG
            test_f5 = function(){ print("f5") }, # OK
            test_f6 = "f6"                       # NG (not a function)
    )

    dummy &lt;- sapply(obj[grep("^test_", names(obj))], function(f){if(is.function(f)) f()})
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1481'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1481
  :user_name: hamano
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/25/
  :language: C
  :time: 2007/07/26 18:37 GMT
  :vote_count: '7'
  :vote_score: '7'
  :body: "\n\t  <pre class=\"compact\">C言語にメソッドはないので共有ライブラリの関数を列挙し、呼び出すようにしました。\r\n\r\n1.
    共有ライブラリをコンパイルします。\r\n% gcc --shared call_tests.c -o tests.so\r\n\r\n2. 本体をコンパイルします。\r\n%
    gcc call_tests.c -o call_tests -ldl -lbfd\r\n\r\n3. 実行します\r\n% ./call_tests ./tests.so\r\nhello2\r\nhello1\r\nhello3\r\n</pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;dlfcn.h&gt;\n#include
    &lt;bfd.h&gt;\n\nvoid test_hello1()\n{\n    printf(\"hello1\\n\");\n}\nvoid test_hello2()\n{\n
    \   printf(\"hello2\\n\");\n}\nvoid test_hello3()\n{\n    printf(\"hello3\\n\");\n}\n\nint
    main(int argc, char *argv[]){\n    void *handle;\n    void (*func)();\n    bfd
    *abfd;\n    asymbol *store;\n    int symcount;\n    void *minisyms;\n    size_t
    size;\n    int i;\n    bfd_byte *from, *fromend;\n    asymbol *sym;\n    const
    char *name;\n\n    if(argc &lt; 2) return EXIT_FAILURE;\n    handle = dlopen(argv[1],
    RTLD_LAZY);\n    if(!handle) return EXIT_FAILURE;\n    abfd = bfd_openr(argv[1],
    NULL);\n    if(!abfd) return EXIT_FAILURE;\n    bfd_check_format(abfd, bfd_object);\n
    \   store = bfd_make_empty_symbol(abfd);\n    symcount = bfd_read_minisymbols(abfd,
    0, &amp;minisyms, &amp;size);\n    from = (bfd_byte *)minisyms;\n    fromend =
    from + symcount * size;\n    for (; from &lt; fromend; from += size){\n        sym
    = bfd_minisymbol_to_symbol(abfd, 0, from, store);\n        if(sym-&gt;flags !=
    (BSF_FUNCTION | BSF_GLOBAL)) continue;\n        name = bfd_asymbol_name(sym);\n
    \       if(strncmp(name, \"test_\", 5)) continue;\n        func = dlsym(handle,
    name);\n        func();\n    }\n    \n    bfd_close(abfd);\n    dlclose(handle);\n
    \   return EXIT_SUCCESS;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1482'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1482
  :user_name: shiro
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/41/
  :language: Scheme
  :time: 2007/07/26 18:38 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">GaucheではCommonLispと同様に、メソッドはクラスでなく総称関数に所属します。\r\nここではモジュールの中から探してみることにします。\r\n\r\n使い方の例:\r\n(define-module
    foo\r\n  (define (test_1) (print 1))\r\n  (define (test_2) (print 2))\r\n  (define
    test_3 \"I'm variable!\")\r\n  (define (test_4) (print 4)))\r\n\r\n(call-tests
    (find-module 'foo))\r\n</pre>\n\t"
  :code: |
    (define (call-tests module)
      (hash-table-for-each (module-table module)
                           (lambda (k v)
                             (and-let* ([ (#/^test_/ (x-&gt;string k)) ]
                                        [val (global-variable-ref module k)]
                                        [ (procedure? val) ])
                               (val)))))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '1485'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1485
  :user_name: onjo
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/235/
  :language: Common
  :time: 2007/07/26 20:28 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  変数の定義でもシンボルはインターンされるので fboundp を。ついでに大文字小文字を区別する別回答。\r\nfuncall は関数を探しにいきますので
    symbol-function は不要ですがなんとなく。\n\t"
  :code: |
    (defun call-test (pakcage)
      (do-symbols (symbol pakcage)
        (when (and (fboundp symbol) (ppcre:scan "^test_" (symbol-name symbol)))
          (format t "~A =&gt; ~A~%" symbol (funcall (symbol-function symbol))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1486'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1486
  :user_name: rubikitch
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/26 20:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  ぎゃぁ、fboundpが抜けてたorzorzorz\n\t"
  :code: |
    (require :cl-ppcre)
    (defun test_1 () 1)
    (defun test_2 () 2)
    (defun test_3 () 3)
    (defparameter test_var 0)

    (loop for f in (ppcre:regex-apropos-list "^test_" *package*)
       when (fboundp f)
       collect (cons f (funcall f)))        ; =&gt; ((TEST_1 . 1) (TEST_3 . 3) (TEST_2 . 2))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1487'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1487
  :user_name: talo
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/237/
  :language: 
  :time: 2007/07/27 03:09 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  setAccessible(true);\r\nが抜けているので、 private メソッドを実行すると IllegalAccessException
    が発生すると思います。\r\n\r\nもっとも、Exception を握りつぶしていらっしゃるので、実行結果からは private メソッドがスルーされているように見えますが。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1488'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1488
  :user_name: morchin
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/07/27 03:12 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">以下を修正。\r\n・cls.__bases__で、1つ上の階層のベースクラスしかとれていなかったので、再帰的にベースクラスを探すようにした。
    \r\n・継承階層で同じ名称のメソッドをオーバーライドしていた場合、一番子供側のメソッドを呼び出すようにした。 \r\n・新型クラスに対して、 isinstance(obj,
    types.InstanceType) と isinstance(obj, types.ClassType) の\r\n  両方ともFalseになってしまって対応していなかったので対応した。
    \r\n</pre>\n\t"
  :code: "def call_tests(obj, single_level=False, call_static=True):\n    if hasattr(obj,
    '__bases__'):\n        # class object\n        cls = obj\n        obj = obj()
    \ # obj is bound to instance object.\n    else:\n        if not hasattr(obj, '__class__'):
    return  # non class type\n        # instance object\n        cls = obj.__class__\n
    \   \n    # make dict of attributes\n    bases = []\n    def base_classes(cls):\n
    \       if cls.__bases__:\n            bases.extend(cls.__bases__)\n            for
    base in cls.__bases__:\n                base_classes(base)\n    base_classes(cls)\n
    \   \n    names = {}\n    names.update(cls.__dict__)\n    for base in bases:\n
    \       for attr, val in base.__dict__.items():\n            if not names.has_key(attr):\n
    \               names[attr] = val\n    \n    if single_level:\n        for base
    in bases:\n            for name in base.__dict__:\n                if names.has_key(name):\n
    \                   del names[name]\n    \n    # call function of attributes\n
    \   for name in sorted(names):\n        if name[:5] == 'test_':\n            if
    call_static:\n                f = getattr(obj, name)\n                if callable(f):
    f()\n            else:\n                f = names[name]\n                if callable(f):
    f(obj)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1489'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1489
  :user_name: morchin
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/78/
  :language: 
  :time: 2007/07/27 03:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">すみません。PrologとPythonの言語の選択間違えました(;_;)。にしおさん、修正お願いします。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1490'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1490
  :user_name: sumim
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/27 03:20 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">スーパークラス定義のメソッドを考慮するのをすっかり\r\n忘れていました(^_^;)。\r\n\r\nということで改めて。</pre>\n\t"
  :code: |
    target class allSelectors select: [:sel | sel beginsWith: #test]
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '1491'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1491
  :user_name: KIYO-SHIT
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/311/
  :language: PHP
  :time: 2007/07/27 03:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  環境選びますがfnmatchとかいかがざんすか？\n\t"
  :code: |
    foreach (get_class_methods($doukaku) as $method) {
        if (fnmatch("test_*", $method)) {
            $doukaku-&gt;$method();
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1492'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1492
  :user_name: にしお
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/07/27 03:45 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">Pythonのクラスメソッドはあくまで\r\n「呼んだときに第一引数にクラスオブジェクトが渡されるメソッド」\r\nというだけなので、\r\n単純に「xのメソッド」と言った場合には\r\nclassmethodやstaticmethodでラップしてあるメソッドも含まれるわけです。\r\n\r\nなのでもしそれらを省きたければim_selfがインスタンス自身かどうかをチェックすればいいと思います。\r\n下のコードならばtest_methodだけが呼ばれます。</pre>\n\t"
  :code: "import inspect\n\nclass Foo():\n    @classmethod\n    def test_classmethod(cls):\n
    \       print cls\n\n    @staticmethod\n    def test_staticmethod(x):\n        print
    x\n\n    def test_method(self):\n        print self\n\ntarget = Foo()\nfor name,
    method in inspect.getmembers(target):\n    if inspect.ismethod(method):\n        if
    method.im_self == target:\n            print \"call\", name\n            method()\n
    \   \n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1494'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1494
  :user_name: kawauchi
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/14/
  :language: Ruby
  :time: 2007/07/27 06:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    class Object
      def call_test(prvt = false)
        test_methods = self.methods.grep(/\Atest_/)
        test_methods += self.private_methods.grep(/\Atest_/) if prvt
        test_methods.each{|method|
          yield method, self.__send__(method)
        }
      end
    end

    if $0 == __FILE__
      class Sample
        def test_a
          true
        end
      end

      o = Sample.new
      o.call_test{|m, r|
        puts "#{m} #{r}"
      }
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1495'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1495
  :user_name: にしお
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/27 06:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">だいぶ言語が増えてきたので選びづらいですよね。JavaScriptとかで\r\n今までに投稿したことのある言語を簡単に選べるようにしようとは思いつつ\r\nまだできていません。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1496'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1496
  :user_name: tanuki
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/312/
  :language: Perl
  :time: 2007/07/27 06:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  CPANだよりですが。。。^^;\n\t"
  :code: |
    #!/usr/local/bin/perl

    use target;
    use Class::Inspector;

    foreach my $f (@{(Class::Inspector-&gt;functions( 'target' ))[0]}) {
        print eval{target-&gt;$f()} if ($f =~ /^test_.+$/);
    }
    exit;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1497'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1497
  :user_name: zigorou
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/64/
  :language: Perl
  :time: 2007/07/27 06:43 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Class::Inspector, Scalar::Util使用版\n\t"
  :code: |
    #!/usr/bin/perl

    package Foo;

    {
        no strict 'refs';

        for my $method (qw/foo bar baz test_foo test_bar test_baz/) {
            *{"Foo::$method"} = sub {
                print $method . "\n";
            };
        }
    }

    sub new {
        bless {} =&gt; shift;
    }

    package main;

    use strict;
    use warnings;

    use Scalar::Util qw(blessed);
    use Class::Inspector;

    sub call_methods_by_regex {
        my ($target, $regex) = @_;

        return unless (my $class = blessed($target));
        return unless (ref $regex eq 'Regexp');

        my @methods = grep { /$regex/o } @{Class::Inspector-&gt;methods($class, 'public')};

        for my $method (@methods) {
            $target-&gt;$method();
        }
    }

    call_methods_by_regex(Foo-&gt;new, qr/^test_/);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1501'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1501
  :user_name: zigorou
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/64/
  :language: Perl
  :time: 2007/07/27 07:42 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  CPANに頼らない版\n\t"
  :code: "#!/usr/bin/perl\n\npackage Foo;\n\n{\n    no strict 'refs';\n\n    for my
    $method (qw/foo bar baz test_foo test_bar test_baz/) {\n        *{\"Foo::$method\"}
    = sub {\n            print $method . \"\\n\";\n        };\n    }\n}\n\nsub new
    {\n    bless {} =&gt; shift;\n}\n\npackage main;\n\nuse strict;\nuse warnings;\n\n{\n
    \   no strict 'refs';\n    sub call_methods_by_regex {\n        my ($target, $regex)
    = @_;\n        my $class = ref $target;\n\n        return if (!$class || $class
    =~ /^(SCALAR|ARRAY|HASH|CODE|GLOB|LVALUE)$/);\n        return unless (ref $regex
    eq 'Regexp');\n\n        my @methods = \n            grep { *{${$class . \"::\"}{$_}}{CODE}
    } \n            grep { /$regex/o } \n                keys %{$class . \"::\"};\n
    \       \n        for my $method (@methods) {\n            $target-&gt;$method();\n
    \       }\n    }\n}\n\ncall_methods_by_regex(Foo-&gt;new, qr/^test_/);\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1505'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1505
  :user_name: lany
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/314/
  :language: Delphi
  :time: 2007/07/27 14:39 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">いけるのはpublishedで宣言されたもののみです。\r\nちなみにお題のタイトルのようにメソッド名一覧を表示する場合は、\r\nPos関数内で使ってるPShortString(...)^をWritelnしてやればOKです。</pre>\n\t"
  :code: |
    program EnumMethodNames;

    {$APPTYPE CONSOLE}

    type
        THoge = class(TObject)
        published
            procedure test_foo;
        end;
        THogeEx = class(THoge)
        published
            procedure test_bar;
            procedure foobar;
        end;
        THogeMethod = procedure of object;

    procedure THoge.test_foo;
    begin
        Writeln('foo');
    end;

    procedure THogeEx.test_bar;
    begin
        Writeln('bar');
    end;

    procedure THogeEx.foobar;
    begin
        Writeln('foobar');
    end;

    procedure EnumMethods(target: TObject);
    var
        ref: TClass;
        table: PChar;
        count: Word;
        method: TMethod;
    begin
        ref := target.ClassType;
        while ref &lt;&gt; nil do begin
            table := PPointer(PChar(ref) + vmtMethodTable)^;
            if Assigned(table) then begin
                count := PWord(table)^;
                Inc(table, SizeOf(Word));
                while count &gt; 0 do begin
                    if Pos('test_', PShortString(table+SizeOf(Word)+SizeOf(Pointer))^) = 1 then begin
                        method.Code := PPointer(table+SizeOf(Word))^;
                        method.Data := target;
                        THogeMethod(method);
                    end;
                    Inc(table, PWord(table)^);
                    Dec(count);
                end;
            end;
            ref := ref.ClassParent;
        end;
    end;

    var
        Hoge: THoge;

    begin
        Hoge := THogeEx.Create;
        try
            EnumMethods(Hoge);
        finally
            Hoge.Free;
        end;
    end.
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1507'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1507
  :user_name: ocean
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/177/
  :language: 
  :time: 2007/07/27 15:11 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">気づいたのですが、同一性の判定には、\r\nif method.im_self is
    target: のように\r\n==よりisを使った方がいいかもしれません。\r\n\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1511'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1511
  :user_name: kkobayashi
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/27 15:53 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">もう少し題意を反映した感じで書いてみました。\r\nRのメソッドは、初めにgenericなメソッドを定義した後\r\n「generic
    method名.クラス名」という形式で定義します。\r\n\r\ngeneric methodを実行すると、第一引数のクラスによって\r\n適切なメソッドが実行されます。\r\n\r\n&gt;
    test_f1(target)\r\n[1] \"f1\"\r\n</pre>\n\t"
  :code: |
    # define generic methods
    test_f1 &lt;- function(x){ UseMethod("test_f1") }
    text_f2 &lt;- function(x){ UseMethod("text_f2") }
    txet_f3 &lt;- function(x){ UseMethod("txet_f3") }
    tesx_f4 &lt;- function(x){ UseMethod("tesx_f4") }
    test_f5 &lt;- function(x){ UseMethod("test_f5") }

    # define class and object
    setClass("doukaku", representation(x ="numeric", y="numeric"))
    target &lt;- new("doukaku", x=1, y=2)

    # define methods
    test_f1.doukaku &lt;- function(x){ print("f1") } # OK
    text_f2.doukaku &lt;- function(x){ print("f2") } # NG
    txet_f3.doukaku &lt;- function(x){ print("f3") } # NG
    tesx_f4.doukaku &lt;- function(x){ print("f4") } # NG
    test_f5.doukaku &lt;- function(x){ print("f5") } # OK

    dummy &lt;- sapply(grep("^test_", methods(class=attr(target, "class")), value=TRUE),
                      (function(x) do.call(x, c(target))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1517'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1517
  :user_name: odz
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/212/
  :language: 
  :time: 2007/07/27 16:50 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  おぉ。なるほど。と、おもったら、im_self をチェックするというのネタを以前自分のブログに書いていた orz\r\nそれはそれとして、「x
    のメソッド」と表現したときに、メッセージのレシーバが x でないものを含めるかどうかというのはなかなか微妙な話かもしれない。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1529'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1529
  :user_name: にしお
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/28 00:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  なるほど、たしかに__eq__がオーバーライドされて同じインスタンスではなくてもTrueを返すようになっている可能性があるので==で判定してはダメですね。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1530'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1530
  :user_name: にしお
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/28 01:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">微妙な話ですね。\r\n「単純に「xのメソッド」と言った場合には\r\nclassmethodやstaticmethodで\r\nラップしてあるメソッドも含まれる」\r\nというのは言い過ぎだったかも。\r\n「メソッド」という言葉がの定義と、\r\nclassmethodやstaticmethodの実装を\r\n追わないと正確なことは言えなかったですね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1588'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1588
  :user_name: 匿名
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2007/07/30 10:50 GMT
  :vote_count: '4'
  :vote_score: '-4'
  :body: "\n\t  \n\t"
  :code: |
    return unless UNIVERSAL::isa($class, 'UNIVERSAL');
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1691'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1691
  :user_name: PHO
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/69/
  :language: Haskell
  :time: 2007/08/02 06:50 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <pre class=\"compact\">コンパイルには -package ghc が必要。\r\n引数で指定されたモジュールが
    export し、且つ test_ で始まる全部の IO モナドを実行する。\r\n型は IO () でなければならず、そうでないものが存在したら実行時エラーになる。\r\nGHC
    6.6.1 以外の GHC を使う場合は ghcLibDir の値を訂正する事。\r\n\r\n% ghc --make Main -package ghc\r\n%
    ./Main Test</pre>\n\t"
  :code: "import qualified GHC\nimport qualified DynFlags\nimport qualified Name\nimport
    Data.List\nimport System\n\n{-\n例: Test.hs\n\nmodule Test where\n\ntest_foo ::
    IO ()\ntest_foo = putStrLn \"called test_foo\"\n\ntest_bar :: IO ()\ntest_bar
    = putStrLn \"called test_bar\"\n\n% ghc --make Test -package-name test\n% ar cqs
    libHSTest.a Test.o\n% ld -r --whole-archive -o HSTest.o libHSTest.a (MacOS X 以外の場合)\n%
    ld -r -all_load -o HSTest.o libHSTest.a       (MacOS X の場合)\n-}\n\nghcLibDir ::
    String\nghcLibDir = \"/usr/local/lib/ghc-6.6.1\" -- % ghc --print-libdir\n\nmain
    = GHC.defaultErrorHandler DynFlags.defaultDynFlags $\n       do [modName] &lt;-
    getArgs\n          session &lt;- GHC.newSession GHC.Interactive (Just ghcLibDir)\n
    \         f0      &lt;- GHC.getSessionDynFlags session\n          GHC.setSessionDynFlags
    session f0 { GHC.hscTarget = GHC.HscInterpreted }\n\n          t  &lt;- GHC.guessTarget
    modName Nothing\n          GHC.addTarget session t\n          f  &lt;- GHC.getSessionDynFlags
    session\n          sf &lt;- GHC.defaultCleanupHandler f (GHC.load session GHC.LoadAllTargets)\n
    \         case sf of\n            GHC.Failed  \n                -&gt; fail \"Failed
    to load the module!\"\n            GHC.Succeeded\n                -&gt; do self
    &lt;- GHC.findModule session (GHC.mkModuleName modName) Nothing\n                      runNullaryIOMonads
    session self (any (== \"test_\") . inits)\n\nrunNullaryIOMonads :: GHC.Session
    -&gt; GHC.Module -&gt; (String -&gt; Bool) -&gt; IO ()\nrunNullaryIOMonads session
    self f\n    = do Just modInfo &lt;- GHC.getModuleInfo session self\n         \n
    \        let allFuncs      = map Name.getOccString $ GHC.modInfoExports modInfo\n
    \            selectedFuncs = filter f allFuncs\n\n         GHC.setContext session
    [self] []\n         mapM_ run selectedFuncs\n    where\n      run :: String -&gt;
    IO ()\n      run fName\n          = GHC.runStmt session (fName ++ \" :: IO ()\")\n
    \           &gt;&gt; return ()\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1724'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1724
  :user_name: tomatsu
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/323/
  :language: Pnuts
  :time: 2007/08/02 12:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    class Foo {
      test_foo(){println("test_foo")}
      test_foo2(){println("test_foo2")}
      test_foo3(){println("test_foo3")}
      public_foo(){println("public_foo")}
    }

    f = Foo()
    for(m:f.class.methods[{m-&gt;m.name.startsWith("test_")}]){
      m.invoke(f, [])
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1729'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1729
  :user_name: ether
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/96/
  :language: PowerShell
  :time: 2007/08/02 13:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "$target | get-member | \n  where { $_.name -like \"test_*\" } |\n  foreach
    { invoke-expression (\"`$target.\" + $_.name + \"()\") }\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1891'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1891
  :user_name: walf443
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/349/
  :language: Ruby
  :time: 2007/08/06 00:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  誰でも思いつく単純な回答\n\t"
  :code: |
    class Target
     def test_foo
      p "foo"
     end
     def test_bar
      p "bar"
     end
     def test_baz
      p "baz"
     end
     def not_test
      p "not test!!"
     end
    end
      #=&gt; nil

    target = Target.new
      #=&gt; #&lt;Target:0x107d1d0&gt;

    target.methods.grep(/^test_.*$/).each {|i| target.__send__ i }
    "baz"
    "foo"
    "bar"
      #=&gt; ["test_baz", "test_foo", "test_bar"]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1985'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/1985
  :user_name: jz5
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/08/07 12:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">引数0で。</pre>\n\t"
  :code: |
    Public Sub CallMethods(ByVal obj As Object)
        For Each m As MethodInfo In obj.GetType.GetMember("test_*", MemberTypes.Method, BindingFlags.Instance Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Static)
            m.Invoke(obj, Nothing)
        Next
    End Sub
  :tags: []
  :references:
    :url: /web/20091214051829/http://dobon.net/vb/dotnet/programing/typegetmember.html
    :title: 型に指定した名前のメンバがあるか調べる
- :id: '2040'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2040
  :user_name: yattom
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/335/
  :language: awk
  :time: 2007/08/09 03:19 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">指定された *.awk ファイルをサーチして、\r\ntest_XXX という関数をすべて実行するような
    .awk ファイルを作り、\r\nその .awk ファイルを実行します。\r\n対象にするのは、\r\n^function +test_.*\r\nというパターンにマッチする関数定義だけです。\r\n\r\nex)\r\n&gt;
    gawk -f testrunner.awk *.awk\r\n\r\ntest_XXX をすべて呼び出すために、_tmp_runner.awk というファイルを\r\n生成します。このファイルは削除せず残します。\r\n_tmp_runner.awk
    と同時に、test_XXX が含まれていた .awk ファイルをすべて、\r\n読み込みます。それ以外の .awk ファイルは読みません。\r\nこのあたりの仕様は、実用性を考えると検討したほうがいいかも。\r\n</pre>\n\t"
  :code: "BEGIN {\n\tTMPFILE = \"_tmp_runner.awk\"\n\tawk_cmd = ARGV[0]\n\ttargets
    = \" \"\n\n\tprint \"BEGIN {\" &gt; TMPFILE\n}\n\n/^function +test_.*\\(/ {\n\tfname
    = gensub(/^function +(test_[^(]*)\\(.*$/, \"\\\\1\", \"\")\n\tprintf \"\\t%s()\\n\",
    fname &gt;&gt; TMPFILE\n\n\tif(index(targets, \" -f \" FILENAME \" \") == 0) {\n\t\ttargets
    = targets \"-f \" FILENAME \" \"\n\t}\n}\n\nEND {\n\tprint \"}\" &gt;&gt; TMPFILE\n\tclose(TMPFILE)\n\n\tCMD
    = sprintf(\"%s -f%s %s\", awk_cmd, TMPFILE, targets)\n\tsystem(CMD)\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2163'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2163
  :user_name: tsekine
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/124/
  :language: Bash
  :time: 2007/08/14 13:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">とりあえず、シェル内で既に定義されている全ての関数の中から、test_ で始まるものを実行してみました。\r\n</pre>\n\t"
  :code: |
    declare -fp  | grep '^test_.*() $' | while read func paren; do
      $func
    done
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2179'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2179
  :user_name: miyamuko
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/382/
  :language: xtal
  :time: 2007/08/14 17:25 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">super クラスも検索するようにしてみました。\r\n\r\n「bar: || \"bar\".p」というのは引数なしの
    lambda 関数を bar に束縛しているような感じです。</pre>\n\t"
  :code: |
    String::start_with: method(sub) {
        return this.split("").take(sub.length).to_a.join("") == sub;
    }

    TargetTest: class {
        test_foo: || "test_foo".p;
        test_bar: || "test_bar".p;
        foo: || "foo".p;
        bar: || "bar".p;
    }
    TargetTest2: class(TargetTest) {
        test_foo: || "test_foo_sub".p;
        test_baz: || "test_baz".p;
    }

    TestRunner: class {
        suite: method(target, inherited_too: true) fiber {
            klasses: [target];
            if (inherited_too) {
                klasses ~= target.each_ancestor.to_a;
            }

            override: Map();
            klasses {|klass|
                klass.each_member {|name, x, meth|
                    if (! override[name] &amp;&amp; name.start_with("test_")) {
                        yield meth;
                    }
                   override[name] = true;
                }
            }
        }

        run: method(target) {
            suite(target) {
                it();
            }
        }
    }

    runner: TestRunner();
    "---".p;
    runner.run(TargetTest2);
    "---".p;
    runner.run(TargetTest);
  :tags:
  - xtal0.9.7
  :references:
    :url: 
    :title: 
- :id: '2198'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2198
  :user_name: yooskeh
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/91/
  :language: Prolog
  :time: 2007/08/15 08:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: ":- module(target, []).\ntest_a :- writeln(test_a).\ntest_b :- writeln(test_b).\ntest_x(_)
    :- writeln(test_x).\nno_test :- writeln(no_test).\n\n% 指定されたモジュールの'test_'で始まる引数0の述語を全て実行\ncall_tests(Module)
    :-\n\tforall((  current_predicate(Module:Predicate/0),\n\t          atom_prefix(Predicate,
    test_)),\n\t       Module:Predicate).\n\n:- call_tests(target).\n%=&gt; test_a
    test_b\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2221'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2221
  :user_name: higeorange
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/194/
  :language: Io
  :time: 2007/08/16 05:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    Object callMethods := method(str,
        self slotNames foreach(slotname,
            if(slotname beginsWithSeq(str),
                self perform(slotname)
            )
        )
    )

    obj := Object clone
    obj test_1 := method(
        "test_1" println
    )
    obj foobar := method(
        "foobar" println
    )
    obj test_2 := method(
        "test_2" println
    )
    obj test3 := method(
        "test3" println
    )
    obj test_4 := "fuga"

    obj callMethods("test_")
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2564'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/2564
  :user_name: 管理者
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/411/
  :language: 
  :time: 2007/08/28 08:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Perlでワンライナーで書いているブログがあったのでリンク。</pre>\n\t"
  :code: ''
  :tags:
  - Perl6
  :references:
    :url: /web/20091214051829/http://d.hatena.ne.jp/fbis/20070727/1185528914
    :title: ■[Perl]メソッド名一覧どーかく？
- :id: '3125'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/3125
  :user_name: tilde
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/446/
  :language: Objective
  :time: 2007/09/20 09:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n#import &lt;objc/objc-class.h&gt;\n\n@interface
    TestClass : NSObject {\n}\n+ (void)test_class_method;\n+ (void)testClassMethod;\n-
    (void)test_instance_method;\n- (void)testInstanceMethod;\n@end\n\n@implementation
    TestClass\n+ (void)test_class_method {\n\tNSLog( @\"test_class_method called\"
    );\n}\n+ (void)testClassMethod {\n\tNSLog( @\"testClassMethod called\" );\n}\n-
    (void)test_instance_method {\n\tNSLog( @\"test_instance_method called\" );\n}\n-
    (void)testInstanceMethod {\n\tNSLog( @\"testInstanceMethod called\" );\n}\n@end\n\nint
    main (int argc, const char * argv[]) {\n    NSAutoreleasePool * pool = [[NSAutoreleasePool
    alloc] init];\n\t\n\tClass cls[2] = { [TestClass class]-&gt;isa, [TestClass class]
    };\n\tTestClass* testClass = [[[TestClass alloc] init] autorelease];\n\t\n\t//forループ１回目はクラスメソッド、２回目はインスタンスメソッドの実行\n\tfor
    ( int i = 0; i &lt; 2; i++ ) {\n\t\tvoid* iterator = 0;\n\t\tstruct objc_method_list*
    mlist;\n\t\t\n\t\twhile ( mlist = class_nextMethodList( cls[i], &amp;iterator
    ) ) {\n\t\t\tfor ( int j = 0; j &lt; mlist-&gt;method_count; j++ ) {\n\t\t\t\tMethod
    method = mlist-&gt;method_list + j;\n\t\t\t\tNSString* methodName = [NSString
    stringWithUTF8String:(const char*)method-&gt;method_name];\n\t\t\t\tif ( [methodName
    hasPrefix:@\"test_\"] ) {\n\t\t\t\t\tif ( i == 0 )\n\t\t\t\t\t\t[TestClass performSelector:method-&gt;method_name];\n\t\t\t\t\telse\n\t\t\t\t\t\t[testClass
    performSelector:method-&gt;method_name];\n\t\t\t\t} else\n\t\t\t\t\tNSLog( @\"Skip
    %@\", methodName );\n\t\t\t}\n\t\t}\n\t}\n\t\n    [pool release];\n    return
    0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3205'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/3205
  :user_name: cooldaemon
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/451/
  :language: Erlang
  :time: 2007/10/01 07:24 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">foo:get(erlang). とかで使えます。</pre>\n\t"
  :code: |
    -module(foo).
    -export([get/1]).

    get(PackageName) -&gt;
      [X || {X, Y} &lt;- proplists:get_value(exports, PackageName:module_info()),
        lists:suffix("_test", atom_to_list(X))].
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3207'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/3207
  :user_name: cooldaemon
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/451/
  :language: Erlang
  :time: 2007/10/01 08:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">お題を誤って理解してしまった為、前回投稿したコードは、_test が関数名の末尾に付いた関数の一覧を返します。\r\n\r\n今回、投稿するコードは、test_
    が関数名の先頭に付いた関数の一覧を返します。\r\n\r\n修正箇所は、lists:suffix/2 を lists:prefix/2 にかえただけです。</pre>\n\t"
  :code: |
    -module(foo).
    -export([get/1]).

    get(PackageName) -&gt;
      [X || {X, Y} &lt;- proplists:get_value(exports, PackageName:module_info()),
        lists:prefix("test_", atom_to_list(X))].
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4460'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/4460
  :user_name: todogzm
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/550/
  :language: JavaFxScript
  :time: 2007/11/28 09:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>[obj].class.Operations\nで、[obj]のクラスのメソッド一覧を取得できます。\n上記で取得できるのはOperationクラスで、\nOperation.Name
    でオペレーション名を取得できます。</p>\n<p>念のためoperation, functionの両方で試しましたが、\n両方ともOperationsで取得できました。</p>\n\n\t"
  :code: "import java.lang.System;\n\npublic class TestClass {\n    public function
    test_function();\n    public operation test_operation();\n    public function
    notest_function();\n    public operation notest_operation();\n}\n\nvar a = new
    TestClass();\n\nvar testNames = select op.Name from op in a.class.Operations \n
    \   where op.Name.startsWith(\"test_\");\n\nfor(name in testNames) {\n    System.out.println(name);\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5151'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/5151
  :user_name: saws
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/642/
  :language: Ruby
  :time: 2008/01/03 15:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Privateメソッドも実行するために.</p>\n\n\t"
  :code: |
    STR = 'test_'
    module ExeTest_
      def exe_test_(x); eval(x) end
    end
    target = Object.new
    target.extend ExeTest_
    target.methods.grep(/\A#{STR}/).each{|x| target.exe_test_(x)}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7217'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/7217
  :user_name: genzou
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/08/19 08:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    outputMethod( target, "test_" )

    def outputMethod(object, prefix){
        object.class.metaClass.methods.findAll{ it.name.startsWith(prefix) }.each{ println it.name }
    }
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '8838'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/8838
  :user_name: 匿名
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/4/
  :language: Common
  :time: 2009/04/25 22:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>暇潰しにやってみた。</p>\n<p>反則っちゃ反則なんだけどPCLベースのCLOS実装やってる処理系だと似たようなことできるんちゃうかな</p>\n\n\t"
  :code: |
    (use-package :sb-mop)
    (defclass c0 ()
      ((x :initarg :x :accessor x)
       (y :initarg :y :accessor y)))
    (defgeneric magnitude (obj))
    (defmethod magnitude ((obj c0))
      (sqrt (+ (expt (x obj) 2) (expt (y obj) 2))))
    (mapcar #'(lambda (m)
            (slot-value (slot-value m 'SB-PCL::%GENERIC-FUNCTION)
                'SB-PCL::NAME))
        (car (slot-value (find-class 'c0) 'SB-PCL::DIRECT-METHODS)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8848'
  :parent_id: '32'
  :url: http://ja.doukaku.org/comment/8848
  :user_name: egtra
  :user_url: /web/20091214051829/http://ja.doukaku.org/user/759/
  :language: C
  :time: 2009/04/28 13:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ここでまさかのC++。ええと、WindowsでCOM使っています。VBやスクリプト言語用のIDispatch/ITypeInfoでリフレクションに相当する情報が得られるので、そこからメソッド名test_で始まるものを選び、IDipatchのInvokeメソッドで呼び出しています。</p>\n<p>main関数より後ろはヘルパ群、ITypeInfoの型情報やIDispatch対応オブジェクトの作成などといった関数が並んでいます。</p>\n<p>ITypeInfoはIDLから作るしかないと思っていたところ、このプログラムのようにCreateDispTypeInfo関数を使うとC++ソースコードの記述だけでITypeInfoを作れることを知りました。これを知らなければこの課題をC++でやることはなかったでしょう。</p>\n\n\t"
  :code: |
    //#define WIN32_LEAN_AND_MEAN

    #include &lt;iostream&gt;

    #include &lt;ole2.h&gt;
    #include &lt;windows.h&gt;
    #include &lt;comdef.h&gt;

    #include &lt;boost/implicit_cast.hpp&gt;
    using boost::implicit_cast;

    // ここでは再発明しましたが、COMSTL (WinSTLの兄弟)のcom_exceptionがお薦め
    class ComException
    {
    public:
        explicit ComException(HRESULT hr) : hr(hr) {}
        ComException(const ComException&amp; rhs) : hr(rhs.hr) {}
        ComException&amp; operator =(const ComException&amp; rhs)
        {
            hr = rhs.hr;
            return *this;
        }
        HRESULT GetErrorCode() const
        {
            return hr;
        }
        //swapは使わないので省略
    public:
        HRESULT hr;
    };

    void ThrowIfFailed(HRESULT hr)
    {
        if (FAILED(hr))
        {
            throw ComException(hr);
        }
    }

    // COM関係のヘッダに#define interface structとある。
    interface __declspec(uuid("c70cd2de-1285-4ec5-a78a-5600cf6fc79a")) __declspec(novtable)
    ITest : IUnknown
    {
        STDMETHOD(test_Hello)() PURE;
        STDMETHOD(test_Goodbye)() PURE;
        STDMETHOD(piyo_Dummy)() PURE;
        // マクロを全て展開するとこうなる。
        // virtual __declspec(nothrow) HRESULT __stdcall test_Hello() = 0;
    };

    // ITestの実装例
    class TestImpl : public ITest
    {
    public:
        TestImpl() : refCount(1) {}

        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv)
        {
            if (riid == __uuidof (IUnknown))
            {
                *ppv = implicit_cast&lt;IUnknown*&gt;(this);
            }
            else if (riid == __uuidof (ITest))
            {
                *ppv = implicit_cast&lt;ITest*&gt;(this);
            }
            else
            {
                *ppv = 0;
                return E_NOTIMPL;
            }
            return S_OK;
        }

        ULONG STDMETHODCALLTYPE AddRef()
        {
            return ++refCount;
        }

        ULONG STDMETHODCALLTYPE Release()
        {
            if (--refCount)
            {
                delete this;
                return 0;
            }
            return refCount;
        }

        HRESULT STDMETHODCALLTYPE test_Hello()
        {
            std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;
            return S_OK;
        }
        HRESULT STDMETHODCALLTYPE test_Goodbye()
        {
            std::cout &lt;&lt; "Goodbye!" &lt;&lt; std::endl;
            return S_OK;
        }
        HRESULT STDMETHODCALLTYPE piyo_Dummy()
        {
            return E_NOTIMPL;
        }
    private:
        ULONG refCount;
    };

    // もし、IホゲPtrが無くてエラーになるなら。
    //_COM_SMARTPTR_TYPEDEF(ITypeInfo, __uuidof (ITypeInfo));
    //_COM_SMARTPTR_TYPEDEF(IUnknown, __uuidof (IUnknown));
    //_COM_SMARTPTR_TYPEDEF(IDispatch, __uuidof (IDispatch));

    ITypeInfoPtr GetFirstInterfaceTypeInfo(ITypeInfo* pti);
    IDispatchPtr CreateDispTest(ITypeInfo* pti);
    ITypeInfoPtr GetTestTypeInfo();

    int main()
    {
        try
        {
            ThrowIfFailed(OleInitialize(0));
            ITypeInfoPtr pti = GetTestTypeInfo(); //クラスを表すITypeInfo
            IDispatchPtr target = CreateDispTest(pti); //オブジェクトの作成
            ITypeInfoPtr ptiInterface = GetFirstInterfaceTypeInfo(pti); //ITestを表すITypeInfo
            TYPEATTR* pta;
            ThrowIfFailed(ptiInterface-&gt;GetTypeAttr(&amp;pta));
            //DISPPARAMS dp2 = {};
            //ThrowIfFailed(pdisp-&gt;Invoke(2, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            //    DISPATCH_METHOD, &amp;dp2, 0, 0, 0));
            for (int i = 0; i &lt; pta-&gt;cFuncs; ++i)
            {
                // i個目の関数のMEMIDを取得
                FUNCDESC* pfd;
                ThrowIfFailed(ptiInterface-&gt;GetFuncDesc(i, &amp;pfd));
                // その関数の名前を取得
                _bstr_t name;
                UINT count;
                ThrowIfFailed(ptiInterface-&gt;GetNames(pfd-&gt;memid, name.GetAddress(), 1, &amp;count));
                if (wmemcmp(name, L"test_", 5) == 0)
                {
                     // その関数がtest_で始まっていれば引数なしで呼び出す
                    DISPPARAMS dp = {};
                    ThrowIfFailed(target-&gt;Invoke(pfd-&gt;memid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                        DISPATCH_METHOD, &amp;dp, 0, 0, 0));
                }
                ptiInterface-&gt;ReleaseFuncDesc(pfd);
            }
            ptiInterface-&gt;ReleaseTypeAttr(pta);
        }
        catch(ComException const&amp; e)
        {
            LPSTR msg;
            FormatMessageA(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL, e.GetErrorCode(), LANG_USER_DEFAULT,
                reinterpret_cast&lt;LPSTR&gt;(&amp;msg), 0, 0);
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            LocalFree(msg);
        }
        OleUninitialize();
    }

    // CreateDispTypeInfoを使ったお手軽ITypeInfoの作成。
    ITypeInfoPtr GetTestTypeInfo()
    {
        static METHODDATA md[] =
        {
            {
                /* szName = */ L"test_Hello",
                /* ppdata = */ 0, //引数情報
                /* dispid = */ 1, //IDispatch::Invokeで呼び出すときの識別番号。適当な正の値で良い。
                /* iMeth = */ 3, //VTBL上のインデックス
                /* cc = */ CC_STDCALL, //呼出規約
                /* cArgs = */ 0, //引数の個数
                /* wFlags = */ DISPATCH_METHOD, //メソッド・プロパティの種別
                /* vtReturn = */ VT_EMPTY, //戻り値の型
            },
            {
                /* szName = */ L"test_Goodbye",
                /* ppdata = */ 0,
                /* dispid = */ 2,
                /* iMeth = */ 4,
                /* cc = */ CC_STDCALL,
                /* cArgs = */ 0,
                /* wFlags = */ DISPATCH_METHOD,
                /* vtReturn = */ VT_EMPTY,
            },
            {
                /* szName = */ L"piyo_Dummy",
                /* ppdata = */ 0,
                /* dispid = */ 3,
                /* iMeth = */ 5,
                /* cc = */ CC_STDCALL,
                /* cArgs = */ 0,
                /* wFlags = */ DISPATCH_METHOD,
                /* vtReturn = */ VT_EMPTY,
            },
        };
        static INTERFACEDATA id =
        {
            md, ARRAYSIZE(md), // ARRAYSIZEは&lt;windows.h&gt;の中で定義されている配列の要素数を求めるマクロ
        };
        ITypeInfoPtr pti;
        ThrowIfFailed(CreateDispTypeInfo(&amp;id, LOCALE_SYSTEM_DEFAULT, &amp;pti));
        return pti;
    }

    // TestImplのディスパッチオブジェクトを作成。
    // ただし、ITypeInfを引数として与えること。
    IDispatchPtr CreateDispTest(ITypeInfo* pti)
    {
        TestImpl* p = new TestImpl;
        IUnknown* punkDispObj;
        ThrowIfFailed(CreateStdDispatch(p, p, pti, &amp;punkDispObj));
        return punkDispObj;
    }

    // あるITypeInfoから、1番目に継承もしくは実装しているインタフェースを返すヘルパ。
    ITypeInfoPtr GetFirstInterfaceTypeInfo(ITypeInfo* pti)
    {
        ITypeInfoPtr res;
        HREFTYPE hrt;
        ThrowIfFailed(pti-&gt;GetRefTypeOfImplType(0, &amp;hrt));
        ThrowIfFailed(pti-&gt;GetRefTypeInfo(hrt, &amp;res));
        return res;
    }
  :tags:
  - COM
  :references:
    :url: 
    :title: 
