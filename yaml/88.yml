---
:id: '88'
:title: 文字列の均等分割
:comments:
- :id: '4090'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4090
  :user_name: nobsun
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/11/16 00:07 GMT
  :vote_count: '3'
  :vote_score: '-1'
  :body: "\r\n\t  <pre class=\"compact\">一行の文字列を指定した数の行にできるだけ文字数が均等になるように分割してください．\r\nただし，除算や剰余算を使わないで書いてみてください．\r\n\r\nsample
    = \"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\"\r\n\r\ndivid 4 sample
    =&gt;\r\n \"ゆめよりもはかなき世のなかを\"\r\n \"なげきわびつゝあかしくらすほ\"\r\n \"どに四月十よひにもなりぬれ\"\r\n
    \"ば木のしたくらがりもてゆく\"\r\n\r\ndivid 5 sample =&gt; \r\n \"ゆめよりもはかなき世の\"\r\n \"なかをなげきわびつゝあ\"\r\n
    \"かしくらすほどに四月十\"\r\n \"よひにもなりぬれば木の\"\r\n \"したくらがりもてゆく\"\r\n\r\ndivid 6 sample =&gt;
    \r\n \"ゆめよりもはかなき\"\r\n \"世のなかをなげきわ\"\r\n \"びつゝあかしくらす\"\r\n \"ほどに四月十よひに\"\r\n \"もなりぬれば木のし\"\r\n
    \"たくらがりもてゆく\"\r\n</pre>\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4226'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4226
  :user_name: nobsun
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/11/19 05:48 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\r\n\t  <p>この問題は、除算だけでははく算術演算とか、文字列の長さをstrlenの類いで測るとかをしなくても、多分書けるのではないかと思います。</p>\n\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4214'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4214
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/11/19 03:55 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">「なるべく均等」にというのは\r\n■■■■\r\n■■■■\r\n■■\r\nではなく\r\n■■■■\r\n■■■\r\n■■■\r\nにすること、という意味だと思ってかまわないですか？\r\n（最長の行と最短の行の差が1文字以内で下の行は上の行以下の長さ、と定式化できる？）</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4215'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4215
  :user_name: herumi
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/564/
  :language: C
  :time: 2007/11/19 04:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">つまりはこういうことでしょうか．\r\n割り算を使わないという意図がいまいちくみ取れませんでした．すいません．\r\n#答えは2byte文字オンリーを仮定しています．\r\n</pre>\n\t"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;

    int main(int argc, char *argv[])
    {
        int m = atoi(argv[1]);
        const char *s = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
        int n = strlen(s) / 2;
        int lineLen = 0;
        int i, j;
        while (n &gt;= m) {
            lineLen++;
            n -= m;
        }
        for (i = 0; i &lt; m; i++) {
            for (j = 0; j &lt; lineLen; j++) {
                putchar(*s++);
                putchar(*s++);
            }
            if (n &gt; 0) {
                putchar(*s++);
                putchar(*s++);
                n--;
            }
            putchar('\n');
        }
        return 0;
    };
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4216'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4216
  :user_name: ところてん
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/166/
  :language: Python
  :time: 2007/11/19 04:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">昼休みの時間にさくっと書いてみる。\r\n割り算とほぼ同等なことをやってるあたりがダメダメだなぁ。\r\n\r\n以下出力結果\r\n\r\ndev4\r\nゆめよりもはかなき世のなかを\r\nなげきわびつゝあかしくらすほ\r\nどに四月十よひにもなりぬれ\r\nば木のしたくらがりもてゆく\r\ndev5\r\nゆめよりもはかなき世の\r\nなかをなげきわびつゝあ\r\nかしくらすほどに四月十\r\nよひにもなりぬれば木の\r\nしたくらがりもてゆく\r\ndev6\r\nゆめよりもはかなき\r\n世のなかをなげきわ\r\nびつゝあかしくらす\r\nほどに四月十よひに\r\nもなりぬれば木のし\r\nたくらがりもてゆく</pre>\n\t"
  :code: "#-*- coding: utf-8 -*-\n\ndef dev(s,num):\n    tempCount = [0]*num\n    outStr
    = [\"\"]*num\n    i = 0\n    for j in xrange(len(s)):\n        tempCount[i] +=
    1\n        i = i+1\n        if i == num:\n            i=0\n\n    for x in xrange(num):\n
    \       outStr[x] = s[:tempCount[x]]\n        s = s[tempCount[x]:]\n    return
    outStr\n\n#配列をそのままプリントするとユニコードがうまく表示されないので\ndef printArray(array):\n    for x
    in array:\n        print x\n \nsample = u\"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\"\nprint
    \"dev4\"\nprintArray(dev(sample,4))\nprint \"dev5\"\nprintArray(dev(sample,5))\nprint
    \"dev6\"\nprintArray(dev(sample,6))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4217'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4217
  :user_name: shiro
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/41/
  :language: Scheme
  :time: 2007/11/19 04:32 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  文字列の長さ分'1'を並べたリストをn要素ごとに分割(余りは0fill)し、i番目の要素を合計するとそれがi行目の文字数になる。\r<br><br>gosh&gt; (define *sample*\r<br>  \"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\")\r<br>*sample*\r<br>gosh&gt; (divid 4 *sample*)\r<br>(\"ゆめよりもはかなき世のなかを\" \"なげきわびつゝあかしくらすほ\" \"どに四月十よひにもなりぬれ\" \"ば木のしたくらがりもてゆく\")\r<br>gosh&gt; (divid 5 *sample*)\r<br>(\"ゆめよりもはかなき世の\" \"なかをなげきわびつゝあ\" \"かしくらすほどに四月十\" \"よひにもなりぬれば木の\" \"したくらがりもてゆく\")\r<br>gosh&gt; (divid 6 *sample*)\r<br>(\"ゆめよりもはかなき\" \"世のなかをなげきわ\" \"びつゝあかしくらす\" \"ほどに四月十よひに\" \"もなりぬれば木のし\" \"たくらがりもてゆく\")\r<br>"
  :code: |
    (use gauche.sequence)
    (use util.list)
    (use srfi-13)

    (define (divid n str)
      (values-ref
       (map-accum (lambda (n s) (values (string-take s n) (string-drop s n)))
                  str
                  (apply map + (slices (make-list (string-length str) 1) n #t 0)))
       0))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '4218'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4218
  :user_name: 匿名
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/4/
  :language: HSP
  :time: 2007/11/19 04:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">ジュースを複数のグラスに注ぎ分ける時と同じような考え方です。\r\n投稿間際に確認したところ、ところてん
    さんと同じ手法のようですね。</pre>\n\t"
  :code: |
    // 入力される値が2byte文字のみと仮定
    #module
    #deffunc divid str _target, int num
        if (num &lt;= 0) : return

        target = _target
        dim result, num
        count = 0
        repeat strlen(target) &gt;&gt; 1
            result(count) += 2
            count++
            if(count == num) : count = 0
        loop
        count = 0
        repeat num
            mes strmid(target, count, result(cnt))
            count += result(cnt)
        loop
        return
    #global
        sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく"
        divid sample, 4
        divid sample, 5
        divid sample, 6
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4220'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4220
  :user_name: 匿名
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/19 05:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>はい、まさにその通りの意図です。(例だけだと伝わらないか。。。)</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4222'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4222
  :user_name: nobsun
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/11/19 05:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>あれログインし忘れた。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4223'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4223
  :user_name: rucker
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/130/
  :language: PHP
  :time: 2007/11/19 05:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">昔、8bitCPUでグラフィック画面に直線を書いた方法の応用?\r\n\r\n&gt;php
    divstr.php 7\r\nゆめよりもはかな\r\nき世のなかをなげ\r\nきわびつゝあかし\r\nくらすほどに四\r\n月十よひにもなり\r\nぬれば木のしたく\r\nらがりもてゆく</pre>\n\t"
  :code: |
    &lt;?php
    $sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";

    $d=max($argv[1],1);
    $l=strlen($sample);
    $s=$l;
    for($i=0;($c=mb_substr($sample,$i,1))!='';++$i)
    {    echo $c;
        for($j=0;$j&lt;strlen($c);++$j)
            $s-=$d;
        if($s&lt;=0)
        {    echo "\n";
            $s+=$l;
        }
    }
    ?&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4226'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4226
  :user_name: nobsun
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/11/19 05:48 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>この問題は、除算だけでははく算術演算とか、文字列の長さをstrlenの類いで測るとかをしなくても、多分書けるのではないかと思います。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4227'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4227
  :user_name: yuin
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/11/19 05:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>0からnumまでの無限リスト(num=4なら0,1,2,3,0,1,2,3...)を作成し、文字列の長さ分takeします。\n</p>\n<p>そのリスト中のnの出現回数を求めると分割後のn個目要素の文字数になります。\n</p>\n<p>ちゅーか、無限リストをライブラリで用意するならcycleとかrepeatくらい提供してほしい・・・\n</p>\n\n\n\n\t"
  :code: |
    def cycle[A](s:Iterable[A]):Stream[A] = {
      def rep[A](s:Stream[A], p:int):Stream[A] = {
        val n = (if(p&lt;s.size){p}else{0})
        Stream.cons(s(n), rep(s, n+1))
      }; rep(s.toStream,0)
    }

    def divid(num:int, str:String) = {
      val table = (Array.make(num, 0) /: cycle(0 until num).take(str.length)){(r,n) =&gt;
        r(n) = r(n)+1;r
      }
      val result = new Array[String](num)
      (str /: (0 until num)){(s,n) =&gt;
        result(n) = s.substring(0, table(n))
        s.substring(table(n))
      }
      result
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4228'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4228
  :user_name: みよ
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/510/
  :language: Java
  :time: 2007/11/19 06:14 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>Javaで書いてみました。\n一応String::lengthを使わないことだけ意識しました。</p>\n\n\t"
  :code: |
    import java.io.IOException;
    import java.io.StringReader;

    public class Divid {

        public static void main(String[] args) throws IOException{
            int[] n = new int[Integer.parseInt(args[0])];
            String target = args[1];
            for (int i = 0; i &lt; n.length; i++) {
                n[i] = 0;
            }
            int turn = 0;
            StringReader reader = new StringReader(target);
            while(reader.read() != -1){
                n[turn++]++;
                if (turn == n.length)
                    turn = 0;
            }
            String v[] = new String[n.length];
            int pos = 0;
            for (int i = 0; i &lt; n.length; i++) {
                v[i] = target.substring(pos, (pos = (pos + n[i])));
                System.out.println(v[i]);
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4229'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4229
  :user_name: shiro
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/41/
  :language: Haskell
  :time: 2007/11/19 06:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  文字列分のTrueの後にFalseをいくつかくっつけたリストを作り、nで分割した後transposeして、Trueの分だけ先頭から切り出す。\r<br><br>例えばdivid 3 \"abcdefghijk\"なら\r<br><br> bools = [T,T,T,T,T,T,T,T,T,T,T,F,F,F]\r<br> slices = [[T,T,T],[T,T,T],[T,T,T],[T,T,F]]\r<br> transpose = [[T,T,T,T],[T,T,T,T],[T,T,T,F]]\r<br><br>boolsを無限リスト(Fが後ろに無限個付く)にしてもいけるかと思ったけど、無限リストのtransposeは止まらないみたい。そこまで見ないんだから止まってくれても良さそうな気がするけど…\r<br>"
  :code: |
    import Data.List

    divid n cs = snd $ mapAccumL taker cs
                     $ transpose
                     $ slices
                     $ bools cs
     where
       slices xs | n &gt; length xs = []
                 | otherwise     = (take n xs):(slices $ drop n xs)
       bools cs = (map (const True) cs) ++ (replicate n False)
       taker (c:cs) (True:bs) = let (cs',frag) = (taker cs bs)
                                  in (cs', c:frag)
       taker cs _             = (cs, [])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4230'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4230
  :user_name: shiro
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/41/
  :language: Haskell
  :time: 2007/11/19 06:57 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <p>いや、そもそも後ろにFalseをくっつける必要が無かった。takeはリストの方が短いと結果も短くしてくれるのね。(Gaucheのtake*の動作)</p>\n\n\t"
  :code: |
    import Data.List

    divid n cs = snd $ mapAccumL taker cs $ transpose $ slices cs
     where
       slices [] = []
       slices xs = (take n xs):(slices $ drop n xs)
       taker cs []         = (cs, [])
       taker (c:cs) (b:bs) = let (cs',frag) = (taker cs bs) in (cs', c:frag)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4231'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4231
  :user_name: kozima
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/11/19 07:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>行数以外は数値を使ってません。\nもっとよく考えればきれいに書けるかも。</p>\n\n\t"
  :code: |
    (defun divid-1 (string n)
      (loop
         with list = (coerce string 'list)
         with list2 = (nthcdr n list)
         for slow on list
         for fast = list2 then (or (nthcdr n fast) list2)
         if (eq list2 fast) collect slow))

    (defun divid-2 (string n)
      (loop with list = (divid-1 string n)
         with last = (last list)
         for sublist on (cdr list)
         while (car last)
         do (mapl (lambda (l) (pop (car l))) sublist)
         finally (return (mapcar #'ldiff list (cdr list)))))

    (defun divid (string n)
      (mapcar (lambda (l) (format nil "~{~C~}" l)) (divid-2 string n)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4232'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4232
  :user_name: nantan
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/535/
  :language: Java
  :time: 2007/11/19 07:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>先に何文字で分割するかを計算させてから文字分割しています。</p>\n\n\t"
  :code: |
    import java.util.*;
    public class Divide {
        public static void main(String[] args) {
            String sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
            System.out.println(Arrays.toString(devide(sample, 4)));
            System.out.println(Arrays.toString(devide(sample, 5)));
            System.out.println(Arrays.toString(devide(sample, 6)));
        }
        public static String[] devide(String s, int r) {
            int[] x = new int[r];
            for (int i = 0, j = 0; i &lt; s.length(); i++, j++) {
                if (j &gt;= x.length) j = 0;
                x[j]++;
            }
            List&lt;String&gt; list = new ArrayList&lt;String&gt;(r);
            for (int i = 0; i &lt; x.length; i++) {
                list.add(s.substring(0, x[i]));
                s = s.substring(x[i]);
            }
            return list.toArray(new String[0]);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4233'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4233
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/11/19 07:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">■■■■\r\n■■■■\r\n■■■\r\nの場合に\r\n■■■■\r\n■■■\r\n■■■■\r\nという出力がありなのか\r\nふと疑問に思ったもので…。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4234'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4234
  :user_name: kozima
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/11/19 07:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">だいたいこんな処理になってます。\r\n\r\ndivid-1: 分割すべき位置を近似的に見つける\r\n\"ゆめよりもはかなき世のなかを...\",
    4\r\n-&gt;\r\n(\"ゆめよりもはかなき世のなかを...\" \"をなげきわびつゝあかしくらす...\"\r\n \"すほどに四月十よひにもなりぬ...\"
    \"ぬれば木のしたくらがりもてゆく\"\r\n \"ゆく\")\r\n\r\ndivid-2: 末尾が空になるまでひとつずつずらす\r\n   (\"ゆめよりも...\"
    \"をなげきわ...\" \"すほどに四...\" \"ぬれば木の...\" \"ゆく\")\r\n-&gt; (\"ゆめよりも...\" \"なげきわ...\"
    \"ほどに四...\" \"れば木の...\" \"く\")\r\n-&gt; (\"ゆめよりも...\" \"なげきわ...\" \"どに四...\" \"ば木の...\"
    \"\")\r\n\r\ndivid: 重複部分を削る\r\n(\"ゆめよりもはかなき世のなかをなげき...\" \"なげきわびつゝあかしくらすほどに四...\"\r\n
    \"どに四月十よひにもなりぬれば木のし...\" \"ば木のしたくらがりもてゆく\" \"\")\r\n-&gt; \r\n(\"ゆめよりもはかなき世のなかを\"
    \"なげきわびつゝあかしくらすほ\"\r\n \"どに四月十よひにもなりぬれ\" \"ば木のしたくらがりもてゆく\")</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4235'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4235
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/11/19 07:51 GMT
  :vote_count: '13'
  :vote_score: '13'
  :body: "\n\t  <p>正規表現を使いました。</p>\n<p>countは0以上の無限リストを作成する命令で、0以上の各整数iについて「『i文字またはi+1文字』のブロックがn個ある」という正規表現を作ってマッチを試みます。マッチすればグループ分けをreturn。greedyなので前半のグループが長い方、後半のグループが短い方になります。</p>\n\n\t"
  :code: |
    def divid(n, s):
        import re
        from itertools import count
        for i in count():
            pat = "^%s$" % "(.?.{%d})" % i * n
            m = re.match(pat, s)
            if m:
                return m.groups()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4236'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4236
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/11/19 07:52 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>算術演算もstrlenに相当する関数も使ってないよ！(よっぽどうれしかったらしい)</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4238'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4238
  :user_name: nobsun
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/11/19 08:02 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">私の用意していたものはshiroさんの解と本質的に同じでした。\r\nslices と
    taker にも汎用性がありそうなのでトップレベルでの定義にしてあります。</pre>\n\t"
  :code: "import Data.List\nimport qualified System.IO.UTF8 as U\n\ndivid :: Int -&gt;
    [a] -&gt; [[a]]\ndivid n xs \n  = snd $ mapAccumL ((swap .) . flip splitWith)
    xs $  transpose $ slices n xs\n\nswap :: (a,b) -&gt; (b,a)\nswap (x,y) = (y,x)\n\nsplitWith
    :: [b] -&gt; [a] -&gt; ([a],[a])\nsplitWith _  [] = ([],[])\nsplitWith [] xs =
    ([],xs)\nsplitWith (x:xs) (y:ys) = case splitWith xs ys of (zs,ws) -&gt; (y:zs,ws)\n\nslices
    :: Int -&gt; [a] -&gt; [[a]]\nslices n = unfoldr phi\n  where \n    phi [] = Nothing\n
    \   phi xs = Just $ splitAt n xs\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4241'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4241
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: diff
  :time: 2007/11/19 08:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>括弧が抜けてました…</p>\n\n\t"
  :code: |
    - pat = "^%s$" % "(.?.{%d})" % i * n
    + pat = "^%s$" % ("(.?.{%d})" % i * n)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4243'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4243
  :user_name: kawasaq
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/342/
  :language: 
  :time: 2007/11/19 09:36 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">5 行目は、\r\npat = \"^%s$\" % (\"(.?.{%d})\" %
    i * n)\r\nのように括弧が必要だったりしませんか？\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4244'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4244
  :user_name: kawasaq
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/342/
  :language: 
  :time: 2007/11/19 09:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>修正済でしたね…。すみません。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4245'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4245
  :user_name: sumim
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/11/19 09:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Squeak Samlltalk で。\r<br><br>shiro さんの #4217 の考え方をお借りして。\n\t"
  :code: |
    | sample divide |
    divide := [:sourceStr :numOfLines |
        | stream ones zeros |
        stream := sourceStr readStream.
        ones := (sourceStr as: Array) atAllPut: 1.
        zeros := Array new: numOfLines withAll: 0.
        (ones, zeros groupsOf: numOfLines atATimeCollect: [:group | group]) sum
            collect: [:numOfChars | stream next: numOfChars]].

    sample := 'ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく'.

    divide value: sample value: 4.
    "=&gt; #('ゆめよりもはかなき世のなかを' 'なげきわびつゝあかしくらすほ' 'どに四月十よひにもなりぬれ' 'ば木のしたくらがりもてゆく') "

    divide value: sample value: 5.
    "=&gt; #('ゆめよりもはかなき世の' 'なかをなげきわびつゝあ' 'かしくらすほどに四月十' 'よひにもなりぬれば木の' 'したくらがりもてゆく') "

    divide value: sample value: 6.
    "=&gt; #('ゆめよりもはかなき' '世のなかをなげきわ' 'びつゝあかしくらす' 'ほどに四月十よひに' 'もなりぬれば木のし' 'たくらがりもてゆく') "
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '4246'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4246
  :user_name: rucker
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/130/
  :language: 
  :time: 2007/11/19 09:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">■■■■\r\n■■■■\r\n■■■\r\n■■■\r\nより\r\n■■■■\r\n■■■\r\n■■■■\r\n■■■\r\nの方が「より均等」に思えてしまう…。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4247'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4247
  :user_name: matyr
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/11/19 10:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  なるほどなるほど。では nongreedy なものを。\n\t"
  :code: |
    function doukaku88(n, s){
      for(var i = 0, m; !(m = s.match(RegExp('^'+ Array(n + 1).join('(.{'+ i +','+ ++i +'}?)') +'$'))););
      return m.slice(1);
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4250'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4250
  :user_name: kenaxt
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/456/
  :language: Ruby
  :time: 2007/11/19 10:55 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">例えば5分割の場合、以下のように配列を作成後、文字が入っている所に入力文字を当てはめていくようにしました。\r\n\r\n\"ゆはのげゝら四にれたも\"\r\n\"めかなきあす月もばくて\"\r\n\"よなかわかほ十な木らゆ\"\r\n\"りきをびしどよりのがく\"\r\n\"も世なつくにひぬしり\"\r\n\r\nshiroさんと同様のロジックですね。</pre>\n\t"
  :code: |
    def strDiv(n,s)
      r = [[]]
      s1 = s.split(//)
      while s1!=[]
        1.upto(n) {|i|
          (r[i-1] ||= []) &lt;&lt; s1.shift
        }
      end
      s1 = s.split(//)
      r.each {|i|
        i.each {|j|
          print s1.shift if j
        }
        puts
      }
    end


    strDiv(5,"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく")
  :tags:
  - Ruby1.8.6
  :references:
    :url: 
    :title: 
- :id: '4254'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4254
  :user_name: eeweiga
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/537/
  :language: Perl
  :time: 2007/11/19 12:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">divid(4, \"Perlわかるひとには長いよって思われそうだし、Perlわかんないひとには読めねえよって思われそうだけどいいんだ。ってこれ半角混ぜるとぐじゃぐじゃになるな\")</pre>\n\t"
  :code: "use strict;\nuse warnings;\nuse utf8;\nbinmode(STDOUT, \":utf8\");\n\nsub
    divid {\n    my $line = shift @_;\n    my $str = shift @_;\n    my @table;\n    my
    @str_array = split //, $str;\n    push @table, [] for 1..$line;\n    \n    while
    (@str_array) {\n        for (@table) {\n            push @$_, (shift @str_array);\n
    \       }\n    }\n    \n    for (@table) {\n        @$_ = grep { defined $_ }
    @$_;\n    }\n    \n    @str_array = split //, $str;\n    \n    for my $array_ref
    (@table) {\n        for (@$array_ref) {\n            $_ = shift @str_array;\n
    \       }\n    }\n    \n    for (@table) {\n        print \"\\\"\", join('', grep
    { defined $_ } @$_), \"\\\"\", \"\\n\";\n    }\n}\n\ndivid(4, \"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\");\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4255'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4255
  :user_name: ihag
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/560/
  :language: Ruby
  :time: 2007/11/19 13:10 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>最初に，行数分の文字ずつ(例えば，4分割なら4文字ずつ)与えられた文字列を走査し，[14, 14, 13, 13] のような各行の文字数からなる配列を作ります．次に，配列を走査しつ
    つ，この文字数ずつ文字列をとって配列の中身を置き換え，出力とします．</p>\n<pre class=\"literal-block\">\n% ./divid.rb\ndivid
    4:\n[\"ゆめよりもはかなき世のなかを\",\n \"なげきわびつゝあかしくらすほ\",\n \"どに四月十よひにもなりぬれ\",\n \"ば木のしたくらがりもてゆく\"]\n\ndivid
    5:\n[\"ゆめよりもはかなき世の\",\n \"なかをなげきわびつゝあ\",\n \"かしくらすほどに四月十\",\n \"よひにもなりぬれば木の\",\n
    \"したくらがりもてゆく\"]\n\ndivid 6:\n[\"ゆめよりもはかなき\",\n \"世のなかをなげきわ\",\n \"びつゝあかしくらす\",\n
    \"ほどに四月十よひに\",\n \"もなりぬれば木のし\",\n \"たくらがりもてゆく\"]\n</pre>\n\n\t"
  :code: |
    require 'pp'
    $KCODE='EUC'

    class String
      def divid(lines)
        out, x, y = [0] * lines, split(''), nil
        y.times {|i| out[i] += 1 } while (y = x.slice!(0, lines).size) &gt; 0

        rest = self
        out.map! do |len|
          _, ret, rest = *rest.match(/(.{#{len}})(.*)/)
          ret
        end
      end
    end

    sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく"
    (4..6).to_a.each do |i|
      puts "divid #{i}:"
      pp sample.divid(i)
      puts
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4258'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4258
  :user_name: kkobayashi
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/11/19 15:31 GMT
  :vote_count: '5'
  :vote_score: '5'
  :body: "\n\t  <pre class=\"compact\">例えば3分割なら1, 2, 3, 1, 2, 3, ... という配列を作ってソートし、1が並んでいるインデックスを1列目、\r\n2が並んでいるインデックスを2列目・・・という風に文字列をスライスしています。\r\n</pre>\n\t"
  :code: |
    divid &lt;- function(num, sample){
       string &lt;- unlist(strsplit(sample, ""))
       breaks &lt;- sort(rep(1:num, len=length(string)))
       cat(sapply(1:num, function(n)(paste(string[breaks==n], collapse=""))), sep="\n")
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4264'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4264
  :user_name: greentea
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/573/
  :language: Python
  :time: 2007/11/19 16:56 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">文字数数えるのが面倒だったので、スライスでn個飛ばしの文字列を作って、それの文字数を使いました。\r\nオフセット数えるのも、面倒なので再帰任せです。</pre>\n\t"
  :code: |
    # encoding: utf-8

    sample = u"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく"

    def divid(str, n, target_list=[]):
      def get_splitted_str(str, n):
        return str[:len(str[::n])]

      if str:
        s = get_splitted_str(str, n)
        return divid(str[len(s):], n-1, target_list+[s])
      else: return target_list

    for i in range(4,7):
      print "divid", i
      l = divid(sample, i)
      for line in l:
        print line
      print ""
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4266'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4266
  :user_name: にしお
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/11/19 22:49 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <p>なるほど。その発想を使ってみました。\ncycleは与えられたリストを巡回し続ける無限リストで、zipは短い方に会わせて切り詰めます。</p>\n<p>これでも算術演算やstrlenは必要ないですね…正規表現を使うよりは黒魔術っぽさがなくていいかも。</p>\n<pre
    class=\"literal-block\">\n&gt;&gt;&gt; cycle(range(3))\n&lt;itertools.cycle object
    at 0x0270AAA8&gt;\n&gt;&gt;&gt; zip(_, \"hoge\")\n[(0, 'h'), (1, 'o'), (2, 'g'),
    (0, 'e')]\n</pre>\n\n\t"
  :code: |
    def divid(n, s):
        from itertools import cycle
        xs = zip(cycle(range(n)), s)
        return ["".join(c for i, c in xs if i == j)
                 for j in range(n)]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4267'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4267
  :user_name: 匿名
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/11/20 03:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">算術演算も文字列長取得関数も使っていません。\r\n</pre>\n\t"
  :code: |
    #-*- coding: utf-8 -*-

    def divid(n, s):
      s = unicode(s, 'utf-8')
      sl = list(s)
      l = []
      while s:
        l.append(list(s[:n]))
        s = s[n:]

      print '\ndivid %d sample =&gt;' % n
      while l[0]:
        print ' "%s"' % ''.join([a.pop(0) and sl.pop(0) for a in l if a])

    sample = 'ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく'

    print '"sample = %s"' % sample
    divid(4, sample)
    divid(5, sample)
    divid(6, sample)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4268'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4268
  :user_name: uho
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/498/
  :language: C
  :time: 2007/11/20 03:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ごくごく普通ですが、\nC#が無かったので。</p>\n\n\t"
  :code: |
    using System;

    namespace bunkatsu
    {
        class Program
        {
            static void Main(string[] args)
            {
                string sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";

                divid(4, sample);
                divid(5, sample);
                divid(6, sample);
            }

            static public void divid(int n, string s)
            {
                int[] counts = new int[n];

                for (int i = 0, j = 0; i &lt; s.Length; ++i, ++j)
                {
                    if (j &gt;= n)
                        j = 0;

                    counts[j]++;
                }

                int start = 0;

                for (int i = 0; i &lt; n ; ++i)
                {
                    Console.WriteLine( s.Substring( start, counts[i] ) );
                    start += counts[i];
                }
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4269'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4269
  :user_name: SiroKuro
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/540/
  :language: C
  :time: 2007/11/20 07:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  残念。C# 先越されてしまいました。正規表現で文字数の算出と文字列の分割をやってます。\r\nそういえば C# で text * n
    みたいなことやるメソッドって無いのかな。PadLeft と Replace で代用したけど。\n\t"
  :code: |
    using System;
    using System.Text.RegularExpressions;
    static class Program {
        static void Main() {
            string text = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
            Divide(4, text);
            Divide(5, text);
            Divide(6, text);
        }
        static void Divide(int cnt, string text) {
            if (0 &lt; cnt) {
                int strlen = Regex.Matches(text, ".{1," + cnt + "}").Count;
                bool skip = true;
                foreach(Group g in Regex.Match(text, "".PadLeft(cnt).Replace(" ", "(.{" + (strlen - 1) + "," + strlen + "})")).Groups) {
                    Console.WriteLine(skip ? "" : g.Value);
                    skip = false;
                }
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4270'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4270
  :user_name: cho45
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/579/
  :language: Ruby
  :time: 2007/11/20 08:42 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <div class=\"section\">\n<ul>\n<li>\nhttp://ja.doukaku.org/comment/4258/\r\n</li>\n<li>http://ja.doukaku.org/comment/4266/\r</li>\n</ul>\n<p>\r</p>\n<p>を参考に
    ruby1.9 Enumerator とメソッドチェインで書いてみました。\r</p>\n<p>\r</p>\n<pre>\r\n$ ruby1.9 --version\r\nruby
    1.9.0 (2007-11-02 patchlevel 0) [i686-linux]\r\n</pre>\n</div>\n\t"
  :code: |
    def divid(n, str)
        (1..n).cycle.zip(str = str.split(//u)).sort.inject(["", 1]) {|(r,i),(j,_)|
            r &lt;&lt; ((i == j) ? "" : "\n") &lt;&lt; str.shift
            [r, j]
        }.first
    end
  :tags:
  - ruby1.9
  :references:
    :url: 
    :title: 
- :id: '4279'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4279
  :user_name: kkobayashi
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/232/
  :language: diff
  :time: 2007/11/20 15:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Pythonの便利さがすごい・・・。\r\n自分のコードは文字の長さを使っていたので、strlen相当の関数を使用しないように変更してみました。\r\n\r\nifelseは第1引数の条件がTRUEなら第2引数、FALSEなら第3引数の処理を実行します。\r\n条件にはTRUE/FALSEのリストを渡すこともでき、その長さに応じて後ろの処理のリストはコピーされていきます。\r\n</pre>\n\t"
  :code: |
    -   breaks &lt;- sort(rep(1:num, len=length(string)))
    +   breaks &lt;- sort(ifelse(string==string, 1:num))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4281'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4281
  :user_name: 匿名
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2007/11/20 19:03 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <p>器を作って埋めていく方式。</p>\n\n\t"
  :code: |
    require 'pp'
    sample = 'ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく'

    def divid(num,str)
       str_ = str.split(//)
       buf, _n = str_.inject([[],0]) do |acc,ch|
          tmp, n = acc
          tmp[n] ||= []
          tmp[n] &lt;&lt; ch
          [tmp, if (n_ = n + 1) &lt; num then n_ else 0 end]
       end

       str_.inject([0,0]) do |idx,ch|
          n, m = idx
          if buf[n][m].nil?
             n += 1
             m = 0
          end
          buf[n][m] = ch
          [n, m + 1]
       end

       buf.map {|ary| ary.join}
    end

    (4..6).each do |n|
       pp divid(n, sample)
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4283'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4283
  :user_name: kzfm
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/106/
  :language: Perl
  :time: 2007/11/21 03:54 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>予め行数分の長さの配列を作っておいて、文字数をカウントしながらぐるぐるまわしてみた。</p>\n\n\t"
  :code: |
    use utf8;
    binmode(STDOUT, ":utf8");
    sub divid {
      my ($num, $text) = @_;
      my @chars = split //, $text;
      my @length = (0) x $num;
      for (@chars) {unshift @length, pop(@length)+1;}

      map {print join '', splice(@chars, 0, $_), "\n"} @length;

    }

    divid(4, "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく");
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4295'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4295
  :user_name: fkmn
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/190/
  :language: Ruby
  :time: 2007/11/21 15:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">他の人のコードを見ずに書いてみました。\r\n見返してみると、kenaxt さんのコード（#4250）とほとんど同じですね。\r\n\r\n</pre>\n\t"
  :code: |
    def divid(num, str)
      a = Array.new(num){ [] }
      chrs = str.split('')
      tmp = chrs.clone

      until tmp.empty?
        a.each_index do |i|
          break if tmp.empty?
          a[i] &lt;&lt; tmp.shift
        end
      end

      a.each do |b|
        b.each_index do |i|
          b[i] = chrs.shift
        end
      end
      a.map{ |b| b.join('') }.join("\n")
    end

    sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく"
    puts divid(5, sample)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4377'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4377
  :user_name: whym
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/400/
  :language: C
  :time: 2007/11/23 18:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>strlen, 乗除算相当を抜きで、ということなので、\nとりあえず null terminator を利用した素朴な方法でやってみました。</p>\n<p>ブロックの長さを1から1ずつ増やしていって、あたえられた条件を満たすようになったら終わります。</p>\n<p>divid(4,
    \"ゆめよりもはかなき世のなかを\") のケースだと、</p>\n<pre class=\"literal-block\">\n\"ゆ\" \"め\" \"よ\"
    \"りもはかなき世のなかを\"  --&gt; fail\n\"ゆめ\" \"より\" \"もは\" \"かなき世のなかを\"  --&gt; fail\n\"ゆめよ\"
    \"りもは\" \"かなき\" \"世のなかを\"  --&gt; fail\n\"ゆめより\" \"もはかな\" \"き世のな\" \"かを\"  --&gt;
    ok\n</pre>\n<p>て感じです。</p>\n\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;locale&gt;

    using namespace std;

    vector&lt;wstring&gt; divid(uint size, const wchar_t* str, uint len) {
      vector&lt;wstring&gt; v;
      for ( int i = 0, n = 0; n &lt; size; i += len, ++n ) {
        v.push_back(wstring(str, i, len));
      }
      return v;
    }

    vector&lt;wstring&gt; divid(uint size, const wchar_t* str) {
      for ( int len = 1; ; ++len ) {
        for ( int i = 0, n = 0; n &lt; size; ++n ) {
          for ( int m = 0;  m &lt;= len; ++i, ++m ) {
            if ( str[i] == L'\0' ) {
              return divid(size, str, len);
            }
          }
          --i;
        }
      }
      return vector&lt;wstring&gt;(1, L"FAIL");
    }

    int main() {
      locale::global(locale(""));
      const wchar_t* sample = L"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
      vector&lt;wstring&gt; divided;
      divided = divid(4, sample);
      copy(divided.begin(), divided.end(), ostream_iterator&lt;wstring, wchar_t&gt;(wcout, L"\n"));
      divided = divid(5, sample);
      copy(divided.begin(), divided.end(), ostream_iterator&lt;wstring, wchar_t&gt;(wcout, L"\n"));
      divided = divid(6, sample);
      copy(divided.begin(), divided.end(), ostream_iterator&lt;wstring, wchar_t&gt;(wcout, L"\n"));
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4379'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4379
  :user_name: whym
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/400/
  :language: 
  :time: 2007/11/23 18:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>すいません、仕様を勘違いしていたので、\nこれはちゃんと動きません。</p>\n<p><a class=\"reference\"
    href=\"/web/20090329103833/http://ja.doukaku.org/comment/4214/\">http://ja.doukaku.org/comment/4214/</a>
    を読んでませんでした。</p>\n<p>またトライします。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4380'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/4380
  :user_name: whym
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/400/
  :language: C
  :time: 2007/11/23 21:06 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>C++のまちがった例を書いてしまったので、書き直しました。</p>\n\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;locale&gt;

    using namespace std;

    void divid(size_t size, const wchar_t* str) {
      vector&lt;size_t&gt; lengths(size);
      const wchar_t* p = str;
      for ( int i = 0; *p != L'\0'; ++p, ++i ) {
        if ( i == size )  i = 0;
        ++lengths[ i ];
      }

      vector&lt;size_t&gt;::const_iterator
        i = lengths.begin(),
        e = lengths.end();
      for ( ; i != e; ++i ) {
        wcout &lt;&lt; wstring(str, *i) &lt;&lt; endl;
        str += *i;
      }
    }

    int main() {
      locale::global(locale(""));
      const wchar_t* sample = L"ゆめよりもはかなき世のなかをなげきわびつゝ"
        "あかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
      divid(4, sample);
      divid(5, sample);
      divid(6, sample);
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5207'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/5207
  :user_name: szktty
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/648/
  :language: Other
  :time: 2008/01/06 08:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Mac OS X (PowerPC 32bit) アセンブリで。文字列を指定された行数で区切り、区切った回数を一行の文字数とする方法で。</p>\n\n\t"
  :code: ";; ------------------------------------------------\n;; strsplit.s for Mac
    OS X (PowerPC 32bit)\n;; % as -o strsplit.o strsplit.s\n;; ------------------------------------------------\n\n
    \       .machine ppc\n        .globl  _main\n\n;;\n;; r6: 均等分割する行数\n;; r7: 均等分割する文字列\n;;
    r8: 一行の文字列数\n;; r9: 一行の文字列数が r8 より少なくなる行\n;;\n_main:\n        ;; 初期化\n        li
    \     r6, 4           ; 適当な値\n        lis     r7, hi16(line)\n        addi    r7,
    r7, lo16(line)\n        li      r8, 1\n        li      r9, 0\n\n_count_init:\n
    \       mr      r3, r7          ; カウント用に文字列ポインタをコピー\n        li      r4, 0           ;
    カウント\n        \n_count:\n        ;; 2バイト決め打ち\n        lbz     r0, 0(r3)\n        cmpli
    \  cr7, r0, 0      ; 文字列の終端\n        beq     cr7, _count_end\n        addi    r3,
    r3, 2\n        addi    r4, r4, 1\n        cmpl    cr7, r4, r6\n        blt     cr7,
    _count\n\n        li      r4, 0           ; 行数をクリア\n        addi    r8, r8, 1\n
    \       b       _count\n\n_count_end:\n        mr      r9, r4          ; 文字数が少なくなる行のセット\n\n_print:\n
    \       lis     r4, ha16(temp)\n        addi    r4, r4, lo16(temp)\n        mr
    \     r2, r8          ; 一行の残り文字数\n\n_print_char:\n        ;; スタックに退避\n        stwu
    \   r2, -4(r1)\n        stwu    r4, -4(r1)\n        stwu    r6, -4(r1)\n        stwu
    \   r7, -4(r1)\n        stwu    r8, -4(r1)\n        stwu    r9, -4(r1)\n\n        ;;
    一文字ずつ temp にコピーして出力\n        lbz     r0, 0(r7)       ; r0: 文字コピー用\n        cmpli
    \  cr7, r0, 0\n        beq     cr7, _exit\n        stb     r0, 0(r4)\n        lbz
    \    r0, 1(r7)\n        stb     r0, 1(r4)\n        li      r3, 1           ; stdout\n
    \       li      r5, 2\n        li      r0, 4           ; sys_write\n        sc
    \                     ; system call\n\n        ;; スタックから復帰\n        lwz     r9,
    0(r1)\n        lwzu    r8, 4(r1)\n        lwzu    r7, 4(r1)\n        lwzu    r6,
    4(r1)\n        lwzu    r4, 4(r1)\n        lwzu    r2, 4(r1)\n        addi    r1,
    r1, 4\n        \n        ;; 次のループの処理\n        addi    r7, r7, 2       ; 2バイト\n
    \       subi    r2, r2, 1\n\n        ;; 折り返しの判断\n        cmplw   cr7, r6, r9     ;
    r6 &lt;= r9  cr7[lt,eq]=1\n        cmplwi  cr6, r2, 1      ; r2 == 1   cr6[eq]=1\n
    \       cror    2, 28, 30       ; cr0[eq] = cr7[lt] | cr7[eq]\n        crand   2,
    2, 26        ; cr0[eq] = cr0[eq] &amp; cr6[eq]\n        beq     cr0, _print_turn\n
    \       cmpli   cr7, r2, 0\n        bgt     cr7, _print_char\n\n_print_turn:\n
    \       ;; 折り返し地点\n        mr      r2, r8          ; 一行の残り文字数をクリア\n        subi
    \   r6, r6, 1\n\n        ;; スタックに退避\n        stwu    r2, -4(r1)\n        stwu
    \   r4, -4(r1)\n        stwu    r6, -4(r1)\n        stwu    r7, -4(r1)\n        stwu
    \   r8, -4(r1)\n        stwu    r9, -4(r1)\n\n        bl      _print_lf\n\n        ;;
    スタックから復帰\n        lwz     r9, 0(r1)\n        lwzu    r8, 4(r1)\n        lwzu    r7,
    4(r1)\n        lwzu    r6, 4(r1)\n        lwzu    r4, 4(r1)\n        lwzu    r2,
    4(r1)\n        addi    r1, r1, 4\n\n        b       _print_char\n\n;; 改行の出力\n_print_lf:\n
    \       mflr    r2              ; リンクレジスタをスタックに退避\n        stwu    r2, -4(r1)\n
    \       \n        lis     r4, hi16(temp)\n        addi    r4, r4, lo16(temp)\n
    \       li      r0, 10          ; '\\n'\n        stb     r0, 0(r4)\n        li
    \     r5, 1\n        li      r0, 4           ; sys_write\n        sc                      ;
    system call\n\n        lwz     r2, 0(r1)\n        mtlr    r2              ; リンクレジスタを復帰\n
    \       addi    r1, r1, 4\n        \n        blr\n\n_exit:\n        bl      _print_lf\n
    \       li      r3, 0\n        li      r0, 1           ; sys_exit\n        sc\n\n\n;;
    文字列\n\n        .data\n        .align 2\n\nline:\n        .asciz  \"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\"\n
    \       .align  2\n\ntemp:\n        .asciz  \"  \"\n"
  :tags:
  - Assembly
  - MacOSX
  - PowerPC
  :references:
    :url: 
    :title: 
- :id: '5320'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/5320
  :user_name: naranja
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/448/
  :language: D
  :time: 2008/01/14 12:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  D に移植してみました。文字列の長さと分割数次第ではひどく時間がかかります。\n\t"
  :code: |
    import std.stdio;
    import std.regexp;
    import std.string;

    string[] divid(uint n, string s){
        string[] ret;
        for(uint i;; i++){
            auto pat = "^" ~ format("(.{%d,%d})", i, i + 1).repeat(n) ~ "$";
            if(auto m = search(s, pat)){
                for(uint j = 1; j &lt;= n; j++){
                    ret ~= m.match(j);  // ret ~= m[j];
                }
                break;
            }
        }
        return ret;
    }

    void main(){
        auto sample = "ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく";
        writefln(divid(4, sample).join("\n"));
        writefln("----");
        writefln(divid(5, sample).join("\n"));
        writefln("----");
        writefln(divid(6, sample).join("\n"));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6815'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/6815
  :user_name: nemo_kaz
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/837/
  :language: Groovy
  :time: 2008/07/23 17:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Code golf的に、最短コードを目指しました。\r<br>これ以上圧縮できないと思います。\r<br><br>10行での実行例\r<br>--------------------------------\r<br>入力を10行に分割します\r<br><br>ゆめよりもは\r<br>かなき世のな\r<br>かをなげきわ\r<br>びつゝあかし\r<br>くらすほど\r<br>に四月十よ\r<br>ひにもなり\r<br>ぬれば木の\r<br>したくらが\r<br>りもてゆく\r<br>--------------------------------\r<br>"
  :code: "def sample = \"ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく\"\n\ndef
    lines = args[0].toInteger()\nprintln \"入力を${lines}行に分割します\\n\"\nelement= sample.toList()\n\nint
    p=0\nfor (i in 0..lines-1) { \n    for (j = i; j &lt; element.size(); j+=lines
    ) {\n        print sample.getAt(p++)\n    }\n    println \"\"\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7591'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/7591
  :user_name: 匿名
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2008/09/08 04:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>すばらしい！\nありがとうございます。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7877'
  :parent_id: '88'
  :url: http://ja.doukaku.org/comment/7877
  :user_name: 99yen
  :user_url: /web/20090329103833/http://ja.doukaku.org/user/591/
  :language: 
  :time: 2008/10/28 10:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    ●分割(sをnで)
        aとは配列
        bとは整数=0
        cとは文字列
        (sの文字数)回
            a[b]=a[b]&amp;"1"
            b=b+1
            もし、b=nならば、b=0
        aを反復
            c=c&amp;MID(s,1,対象の文字数)&amp;改行
            sの1から(対象の文字数)文字削除
        cで戻る

    sample="ゆめよりもはかなき世のなかをなげきわびつゝあかしくらすほどに四月十よひにもなりぬれば木のしたくらがりもてゆく"
    sampleを4で分割して表示
  :tags: []
  :references:
    :url: 
    :title: 
