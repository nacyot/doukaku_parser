---
:id: '247'
:title: 複素数
:comments:
- :id: '8845'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8845
  :user_name: syat
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/766/
  :language: 
  :time: 2009/04/28 10:30 GMT
  :vote_count: '6'
  :vote_score: '4'
  :body: "\r\n\t  以下の計算をしてください。\r<br><br>1. 加算  ( 3 + i ) + ( 4 - i )\r<br>2. 減算  ( 5 - 9i ) - ( 2 + 6i )\r<br>3. 乗算  ( 5 + 3i )  * ( 5 + 8i )\r<br>4. 除算  ( 9 - 7i )  /  ( 9 - 3i )\r<br>5. 絶対値  | 2 + 3i |\r<br><br>複素数計算を行う関数やクラスを定義して答えを求めること。\r<br>ライブラリがある場合はそれを利用してかまいません。\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: /web/20100628135508/http://ja.wikipedia.org/wiki/%E8%A4%87%E7%B4%A0%E6%95%B0
    :title: Wikipedia：複素数
- :id: '8849'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8849
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: Common
  :time: 2009/04/28 14:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    &gt; (+ #C(3 1) #C(4 -1))
    7
    &gt; (- #C(5 -9) #C(2 6))
    #C(3 -15)
    &gt; (* #C(5 3) #C(5 8))
    #C(1 55)
    &gt; (/ #C(9 -7) #C(9 -3))
    #C(17/15 -2/5)
    &gt; (abs #C(2 3))
    3.6055512
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8850'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8850
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: Scheme
  :time: 2009/04/28 15:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Common LispやSchemeだと問題になりませんね、これ。</p>\n\n\t"
  :code: |
    Welcome to MzScheme v4.0 [cgc], Copyright (c) 2004-2008 PLT Scheme Inc.
    &gt; (+ 3+i 4-i)
    7
    &gt; (- 5-9i 2+6i)
    3-15i
    &gt; (* 5+3i 5+8i)
    1+55i
    &gt; (/ 9-7i 9-3i)
    17/15-2/5i
    &gt; (magnitude 2+3i)
    3.6055512754639896
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8851'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8851
  :user_name: sna
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/819/
  :language: Scala
  :time: 2009/04/28 17:29 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  クラス定義・演算子定義で。\r<br><br>実行結果:\r<br>7.0\r<br>3.0 - 15.0i\r<br>1.0 + 55.0i\r<br>1.1333333333333333 - 0.4i\r<br>3.605551275463989\r<br>"
  :code: "object Complex {\n  \n  implicit def complex2richComplex(c: Complex) = new
    RichComplex(c)\n  class RichComplex(val self: Complex) extends Proxy {\n    def
    abs = self match {\n      case Complex(re, im) =&gt; Math.sqrt(re*re + im*im)\n
    \   }\n  }\n  \n  implicit def int2Complex   (n: Int   ): Complex = Complex(n,
    0)\n  implicit def double2Complex(n: Double): Complex = Complex(n, 0)\n  \n  val
    i = Complex(0, 1)\n  \n}\n\ncase class Complex(real: Double, imag: Double) {\n
    \ \n  // +(a + bi) = (a + bi)\n  def unary_+ = this\n  \n  // -(a + bi) = (-a
    - bi)\n  def unary_- = Complex(-real, -imag)\n  \n  // (a + bi) + (c + di) = (a
    + c) + (b + d)i\n  def + (that: Complex) = Complex(this.real + that.real, this.imag
    + that.imag)\n  \n  // (a + bi) - (c + di) = (a - c) + (b - d)i\n  def - (that:
    Complex) = Complex(this.real - that.real, this.imag - that.imag)\n  \n  // (a
    + bi) * (c + di) = (ac - bd) + (bc + ad)i\n  def * (that: Complex) = {\n    val
    Complex(a, b) = this\n    val Complex(c, d) = that\n    Complex(a*c - b*d, b*c
    + a*d)\n  }\n  \n  // (a + bi) / (c + di) = (ac + bd) / (c^2 + d^2) + (bc - ad)
    / (c^2 + d^2)\n  def / (that: Complex) = {\n    val Complex(a, b) = this\n    val
    Complex(c, d) = that\n    val deno = c*c + d*d\n    Complex((a*c + b*d) / deno,
    (b*c - a*d) / deno)\n  }\n  \n  override def toString = this match {\n    case
    Complex(re,  0) =&gt; re.toString\n    case Complex( 0,  1) =&gt; \"i\"\n    case
    Complex( 0, -1) =&gt; \"-i\"\n    case Complex( 0, im) =&gt; im.toString + \"i\"\n
    \   case Complex(re,  1) =&gt; re.toString + \" + i\"\n    case Complex(re, -1)
    =&gt; re.toString + \" - i\"\n    case Complex(re, im) if im &gt;= 0 =&gt; re.toString
    + \" + \" + im.toString + \"i\"\n    case Complex(re, im)            =&gt; re.toString
    + \" - \" + im.abs.toString + \"i\"\n  }\n  \n}\n\nobject Doukaku247 {\n  import
    Complex._\n  \n  def main(args: Array[String]) {\n    \n    println( (3 + i  )
    + (4 - i  ) )\n    println( (5 - 9*i) - (2 + 6*i) )\n    println( (5 + 3*i) *
    (5 + 8*i) )\n    println( (9 - 7*i) / (9 - 3*i) )\n    println( (2 + 3*i).abs
    \        )\n    \n  }\n  \n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8852'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8852
  :user_name: kkobayashi
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2009/04/28 18:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Rでは組み込みです。</p>\n\n\t"
  :code: |
    &gt; ( 3 + 1i ) + ( 4 - 1i )
    [1] 7+0i
    &gt; ( 5 - 9i ) - ( 2 + 6i )
    [1] 3-15i
    &gt; ( 5 + 3i ) * ( 5 + 8i )
    [1] 1+55i
    &gt; ( 9 - 7i )  /  ( 9 - 3i )
    [1] 1.133333-0.4i
    &gt; abs(2 + 3i)
    [1] 3.605551
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8853'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8853
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2009/04/28 20:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    &gt;&gt;&gt; (3 + 1j) + (4 - 1j)
    (7+0j)
    &gt;&gt;&gt; (5 - 9j) - (2 - 6j)
    (3-3j)
    &gt;&gt;&gt; (5 + 3j) * (5 + 8j)
    (1+55j)
    &gt;&gt;&gt; (9 - 7j) / (9 - 3j)
    (1.1333333333333333-0.40000000000000002j)
    &gt;&gt;&gt; abs(2 + 3j)
    3.6055512754639896
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8854'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8854
  :user_name: ポケット
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/828/
  :language: Perl
  :time: 2009/04/29 00:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Math::Complexをつかってやってみました。\r\nもう少しきれいにかけると思いますが、\r\nとりあえずわかりやすいように上で沢山の変数を宣言してみました。</pre>\n\t"
  :code: |
    use strict;
    use warnings;
    use Math::Complex;

    my $kasan_a = 3 + i;
    my $kasan_b = 4 - i;

    my $gensan_a = 5 - 9*i;
    my $gensan_b = 2 + 6*i;

    my $jyousan_a =  5 + 3*i;
    my $jyousan_b = 5 + 8*i;

    my $jyosan_a = 9 - 7*i;
    my $jyosan_b = 9 - 3*i;

    my $zettai = 2 + 3*i;

    sub Complex_add{
        my $a = $_[0];
        my $b = $_[1];
        print "$a + $b =",$a+$b,"\n";
    }

    sub Complex_minus{
        my $a = $_[0];
        my $b = $_[1];
        print "$a - $b =",$a-$b,"\n";
    }

    sub Complex_times{
        my $a = $_[0];
        my $b = $_[1];
        print "$a * $b =",$a*$b,"\n";
    }

    sub Complex_divide{
        my $a = $_[0];
        my $b = $_[1];
        print "$a / $b =",$a/$b,"\n";
    }

    sub Complex_abs{
        my $a = $_[0];
        print "| $a | =",abs($a),"\n";
    }
    Complex_add($kasan_a,$kasan_b);
    Complex_minus($gensan_a,$gensan_b);
    Complex_times($jyousan_a,$jyousan_b);
    Complex_divide($jyosan_a,$jyosan_b);
    Complex_abs($zettai);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8855'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8855
  :user_name: horiuchi
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/570/
  :language: Java
  :time: 2009/04/29 02:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Jakarta Commons Math を使ってみました。</p>\n\n\t"
  :code: |
    import org.apache.commons.math.complex.Complex;
    import static org.apache.commons.math.complex.ComplexFormat.*;

    public class Sample247 {
        public static Complex $(double real, double imaginary) {
            return new Complex(real, imaginary);
        }
        public static void main(String[] args) {
            System.out.println(formatComplex(
                    $(3, 1).add($(4, -1))
            ));
            System.out.println(formatComplex(
                    $(5, -9).subtract($(2, 6))
            ));
            System.out.println(formatComplex(
                    $(5, 3).multiply($(5, 8))
            ));
            System.out.println(formatComplex(
                    $(9, -7).divide($(9, -3))
            ));
            System.out.println($(2, 3).abs());
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8856'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8856
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: FORTRAN
  :time: 2009/04/29 03:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">深くは考えず、FORTRAN でやってみました☆\r\n\r\n (  7.0000000
    \   ,  0.0000000    )\r\n (  3.0000000    , -15.000000    )\r\n (  1.0000000    ,
    \ 55.000000    )\r\n (  1.1333333    ,-0.40000001    )\r\n   3.6055512</pre>\n\t"
  :code: |
    print *, ( 3, 1) + ( 4,-1)
    print *, ( 5,-9) - ( 2, 6)
    print *, ( 5, 3) * ( 5, 8)
    print *, ( 9,-7) / ( 9,-3)
    print *, abs(( 2, 3))
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8857'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8857
  :user_name: emasaka
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/852/
  :language: Bash
  :time: 2009/04/29 05:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>calc（apcalc）で。</p>\n\n\t"
  :code: |
    $ calc '( 3 + 1i ) + ( 4 - 1i )'
        7
    $ calc '( 5 - 9i ) - ( 2 + 6i )'
        3-15i
    $ calc '( 5 + 3i )  * ( 5 + 8i )'
        1+55i
    $ calc '( 9 - 7i )  /  ( 9 - 3i )'
        ~1.13333333333333333333-0.4i
    $ calc 'abs( 2 + 3i )'
        3.60555127546398929312
  :tags:
  - calc
  :references:
    :url: /web/20100628135508/http://www.isthe.com/chongo/tech/comp/calc/
    :title: Calc - C-style arbitrary precision calculator
- :id: '8858'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8858
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2009/04/29 12:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>実行結果：\n(3,1)+(4,-1)=(7,0)\n(5,-9)-(2,6)=(3,-15)\n(5,3)*(5,8)=(1,55)\n(9,-7)/(9,-3)=(1.13333,-0.4)\n<a
    href=\"/web/20100628135508/http://ja.doukaku.org/247/flatten/#id1\" name=\"id2\"><span
    class=\"problematic\" id=\"id2\">|</span></a>(2,3)|=3.60555</p>\n<div class=\"system-message\"
    id=\"id1\">\n<p class=\"system-message-title\">System Message: <a name=\"id1\">WARNING/2</a>
    (<tt class=\"docutils\">&lt;string&gt;</tt>, line 1); <em><a href=\"/web/20100628135508/http://ja.doukaku.org/247/flatten/#id2\">backlink</a></em></p>\nInline
    substitution_reference start-string without end-string.</div>\n\n\t"
  :code: |
    #include &lt;complex&gt;
    #include &lt;iostream&gt;

    using namespace std;

    int main(){
        complex&lt;double&gt; dc1(3.0, 1);
        complex&lt;double&gt; dc2(4.0,-1);
        complex&lt;double&gt; dc3(5.0,-9);
        complex&lt;double&gt; dc4(2.0, 6);
        complex&lt;double&gt; dc5(5.0, 3);
        complex&lt;double&gt; dc6(5.0, 8);
        complex&lt;double&gt; dc7(9.0,-7);
        complex&lt;double&gt; dc8(9.0,-3);
        complex&lt;double&gt; dc9(2.0, 3);

        cout &lt;&lt; dc1 &lt;&lt; '+' &lt;&lt; dc2 &lt;&lt; '=';
        cout &lt;&lt; dc1 + dc2 &lt;&lt; "\n";

        cout &lt;&lt; dc3 &lt;&lt; '-' &lt;&lt; dc4 &lt;&lt; '=';
        cout &lt;&lt; dc3 - dc4 &lt;&lt; "\n";

        cout &lt;&lt; dc5 &lt;&lt; '*' &lt;&lt; dc6 &lt;&lt; '=';
        cout &lt;&lt; dc5 * dc6 &lt;&lt; "\n";

        cout &lt;&lt; dc7 &lt;&lt; '/' &lt;&lt; dc8 &lt;&lt; '=';
        cout &lt;&lt; dc7 / dc8 &lt;&lt; "\n";

        cout &lt;&lt; '|' &lt;&lt; dc9 &lt;&lt; "|=";
        cout &lt;&lt; abs(dc9) &lt;&lt; endl;

    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8859'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8859
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2009/04/29 07:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">実行結果をもう一度\r\n(3,1)+(4,-1)=(7,0)\r\n(5,-9)-(2,6)=(3,-15)\r\n(5,3)*(5,8)=(1,55)\r\n(9,-7)/(9,-3)=(1.13333,-0.4)\r\n|(2,3)|=3.60555\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8860'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8860
  :user_name: pooq
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2009/04/29 08:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">J言語では複素数 a + bi を ajb で表現します。\r\n</pre>\n\t"
  :code: |2
       3j1 + 4j_1
    7
       5j_9 - 2j6
    3j_15
       5j3 * 5j8
    1j55
       9j_7 % 9j_3
    1.13333j_0.4
       | 2j3
    3.60555
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8861'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8861
  :user_name: selpo
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1013/
  :language: C
  :time: 2009/04/29 13:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>頑張ってみました。\n正直、めんどかったです。</p>\n\n\t"
  :code: |
    using System;
    class P
    {
        static void Main()
        {
            Complex a = new Complex(3, 1);
            Complex b = new Complex(4, -1);
            Complex c = new Complex(5, -9);
            Complex d = new Complex(2, 6);
            Complex e = new Complex(5, 3);
            Complex f = new Complex(5, 8);
            Complex g = new Complex(9, -7);
            Complex h = new Complex(9, -3);
            Complex i = new Complex(2, 3);
            Console.WriteLine("({0}) + ({1}) = {2}", a, b, a + b);
            Console.WriteLine("({0}) - ({1}) = {2}", c, d, c - d);
            Console.WriteLine("({0}) * ({1}) = {2}", e, f, e * f);
            Console.WriteLine("({0}) / ({1}) = {2}", g, h, g / h);
            Console.WriteLine("|{0}| = {1}", i, i.Abs);
        }
    }
    class Complex
    {
        protected double re;
        protected double im;
        protected double abs;
        protected double arg;
        protected static Complex IUnit = new Complex(0, 1);
        public double Re
        {
            set
            {
                this.re = value;
                this.abs = Math.Sqrt(this.re * this.re + this.im * this.im);
                if (this.abs == 0.0)
                    this.arg = 0;
                else
                    this.arg = Math.Atan2(im, re) * 180 / Math.PI;
            }
            get { return this.re; }
        }
        public double Im
        {
            set
            {
                this.im = value;
                this.abs = Math.Sqrt(this.re * this.re + this.im * this.im);
                if (this.abs == 0.0)
                    this.arg = 0;
                else
                    this.arg = Math.Atan2(im, re) * 180 / Math.PI;
            }
            get { return this.im; }
        }
        public double Abs
        {
            set
            {
                this.abs = Math.Abs(value);
                this.im = abs * Math.Sin(arg * Math.PI / 180);
                this.re = abs * Math.Cos(arg * Math.PI / 180);
            }
            get { return this.abs; }
        }
        public double Arg
        {
            set
            {
                this.arg = value;
                this.im = abs * Math.Sin(arg * Math.PI / 180);
                this.re = abs * Math.Cos(arg * Math.PI / 180);
            }
            get { return this.arg; }
        }
        public static Complex I
        {
            get { return IUnit; }
        }
        public Complex() : this(0, 0) { }
        public Complex(double a, double b)
        {
            re = a;
            Im = b;
        }
        public string MyToString(int n)
        {
            string str = "";
            double x = Math.Pow(10.0, n);
            double r = Math.Floor(re * x) / x;
            double i = Math.Floor(im * x) / x;
            if (r != 0)
            {
                str += r;
                if (i &gt; 0)
                {
                    if (i == 1) str += " + i";
                    else str += " + " + i + "i";
                }
                else if (i &lt; 0)
                {
                    if (i == -1) str += " - i";
                    else str += " - " + (-i) + "i";
                }
            }
            else
            {
                if (i &gt; 0)
                {
                    if (i == 1) str += "i";
                    else str += i + "i";
                }
                else if (i &lt; 0)
                {
                    if (i == -1) str += "-i";
                    else str += "-" + (-i) + "i";
                }
            }
            return str;
        }
        public static Complex FromArgAbs(double arg, double abs)
        {
            return new Complex(abs * Math.Cos(arg * Math.PI / 180), abs * Math.Sin(arg * Math.PI / 180));
        }
        public static Complex Sqrt(Complex x)
        {
            return Complex.FromArgAbs(x.arg / 2, Math.Sqrt(x.abs));
        }
        public static Complex PowRatio(Complex x, int num, int den)
        {
            Complex y = x ^ num;
            return Complex.FromArgAbs(y.arg / den, Math.Pow(y.abs, 1.0 / den));
        }
        public static Complex operator -(Complex x)
        {
            return (-1) * x;
        }
        public static Complex operator +(Complex x)
        {
            return x;
        }
        public static Complex operator ~(Complex x)
        {
            return new Complex(x.re, -x.im);
        }
        public static Complex operator ^(Complex x, int n)
        {
            if (n &gt; 0)
            {
                if (n == 1) return x;
                Complex z = 1;
                return (z ^ (n &gt;&gt; 1)) * (z ^ ((n &amp; 1) + (n &gt;&gt; 1)));
            }
            else if (n == 0)
                return 1;
            else
                return (1 / x) ^ (-n);
        }
        public static Complex operator +(Complex x, Complex y)
        {
            return new Complex(x.re + y.re, x.im + y.im);
        }
        public static Complex operator -(Complex x, Complex y)
        {
            return new Complex(x.re - y.re, x.im - y.im);
        }
        public static Complex operator *(Complex x, Complex y)
        {
            return Complex.FromArgAbs(x.arg + y.arg, x.abs * y.abs);
        }
        public static Complex operator /(Complex x, Complex y)
        {
            return Complex.FromArgAbs(x.arg - y.arg, x.abs / y.abs);
        }
        public static bool operator ==(Complex x, Complex y)
        {
            return (x.re == y.re &amp;&amp; x.im == y.im);
        }
        public static bool operator !=(Complex x, Complex y)
        {
            return !(x == y);
        }
        public static implicit operator Complex(double x)
        {
            return new Complex(x, 0);
        }
        public static explicit operator Complex(int x)
        {
            return new Complex(x, 0);
        }
        public override bool Equals(object o)
        {
            if (o is Complex)
                return this == (Complex)o;
            else
                return false;
        }
        public override int GetHashCode()
        {
            return (re + im).GetHashCode() ^ (re - im).GetHashCode();
        }
        public override string ToString()
        {
            return MyToString(4);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8862'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8862
  :user_name: mono
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/398/
  :language: Haskell
  :time: 2009/04/29 14:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Data.Complexを使いました。</p>\n\n\t"
  :code: |
    import Data.Complex

    main = putStrLn $ unlines $ map show
            [
               (3 :+ 1) + (4 :+ (-1))
              ,(5 :+ (-9)) - (2 :+ 6)
              ,(5 :+ 3) * (5 :+ 8)
              ,(9 :+ (-7)) / (4 :+ (-3))
              ,abs (2 :+ 3)
            ]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8863'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8863
  :user_name: egtra
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/759/
  :language: C
  :time: 2009/04/29 10:54 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>Cでも、C99から複素数演算が導入されました。こんな風になります。</p>\n<pre class=\"literal-block\">\n$
    gcc -std=c99 t.c -lm &amp;&amp; ./a.out\n(3 + 1i) + (4 - 1i) = (7 + 0i)\n(5 -
    9i) - (2 + 6i) = (3 - 15i)\n(5 + 3i) * (5 + 8i) = (1 + 55i)\n(9 - 7i) / (9 - 3i)
    = (1.13333 - 0.4i)\n|2 + 3i| = 3.60555\n</pre>\n<p>ここでは、FreeBSD 7.1付属gcc 4.2.1を使いました。</p>\n<p>記法がアレなのは仕方ありませんが、printf/scanf系書式での対応がないのは残念です。というより面倒です。</p>\n\n\t"
  :code: |
    $ cat t.c
    #include &lt;stdio.h&gt;
    #include &lt;complex.h&gt;
    #include &lt;math.h&gt;

    void print_complex(double complex c)
    {
        double i = cimag(c);
        printf("%g %c %gi",
            creal(c),
            i &gt;= 0. ? '+'
                    : '-',
            fabs(i));
    }

    void print_expression(double complex lhs, char ope, double complex rhs, double complex result)
    {
        putchar('(');
        print_complex(lhs);
        printf(") %c (", ope);
        print_complex(rhs);
        printf(") = (");
        print_complex(result);
        putchar(')');
        putchar('\n');
    }

    int main()
    {
        double complex al = 3 + I;
        double complex ar = 4 - I;
        double complex sl = 5 - 9 * I;
        double complex sr = 2 + 6 * I;
        double complex pl = 5 + 3 * I;
        double complex pr = 5 + 8 * I;
        double complex dl = 9 - 7 * I;
        double complex dr = 9 - 3 * I;
        double complex bs = 2 + 3 * I;

        double complex a = al + ar;
        double complex s = sl - sr;
        double complex p = pl * pr;
        double complex d = dl / dr;
        double b = cabs(bs);

        print_expression(al, '+', ar, a);
        print_expression(sl, '-', sr, s);
        print_expression(pl, '*', pr, p);
        print_expression(dl, '/', dr, d);
        putchar('|');
        print_complex(bs);
        printf("| = %g\n", b);
    }
  :tags:
  - C99
  :references:
    :url: /web/20100628135508/http://seclan.dll.jp/c99d/c99d06.htm
    :title: プログラミング言語Cの新機能 - 6. 複素数型
- :id: '8864'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8864
  :user_name: egtra
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/759/
  :language: Other
  :time: 2009/04/29 11:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>まさかのExcelです。Excel VBAではありません。いつのバージョンからなのか知りませんが、ワークシート関数として複素数関係のものが揃っています。以下のコードを適当なところに貼り付けてみてください。</p>\n<p>Excelでの複素数の扱い方はいたって単純、\"1+3i\"のような文字列です（虚部のない実数を演算に混ぜることは可能です）。そのままでは、書式指定でも単に文字列として扱われるので、面倒です。</p>\n<p>以下余談。Word/Excelでは、今まで自分が欲しいと思った機能が搭載されていなかった試しがありません。さすが最重量級だけのことはあります。というかあんな機能満載では大半の機能は見つけられないし、見つけても使いこなせませんって。</p>\n\n\t"
  :code: |
    =IMSUM("3+i", "4-i")
    =IMSUB("5-9i", "2+6i")
    =IMPRODUCT("5+3i", "5+8i")
    =IMDIV("9-7i", "9-3i")
    =IMABS("2+3i")
  :tags:
  - Excel
  :references:
    :url: 
    :title: 
- :id: '8865'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8865
  :user_name: sumim
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2009/04/29 19:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Squeak Smalltalk では複素数は組み込みです。リテラルはなく、整数にメッセージ i を送信することで対応する純虚数値を得るしくみになっています。</p>\n\n\t"
  :code: |
    ( 3 + 1i ) + ( 4 - 1i )   "=&gt; 7 + 0 i "
    ( 5 - 9i ) - ( 2 + 6i )   "=&gt; 3 - 15 i "
    ( 5 + 3i ) * ( 5 + 8i )   "=&gt; 1 + 55 i "
    ( 9 - 7i ) / ( 9 - 3i )   "=&gt; (17/15) - (2/5) i "
    ( 9.0 - 7.0i ) / ( 9.0 - 3.0i )   "=&gt; 1.133333333333333 - 0.4 i "
    ( 2 + 3i ) abs            "=&gt; 3.60555127546399 "
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '8866'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8866
  :user_name: Dubhead
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/785/
  :language: D
  :time: 2009/04/29 23:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">D言語で。複素数は組込みなので楽ちん。2.029で動作確認しました。\r\n\r\n実行結果:\r\n7+0i\r\n3+-15i\r\n1+55i\r\n1.13333+-0.4i\r\n3.60555\r\n</pre>\n\t"
  :code: |
    import std.stdio;
    import std.math;        // for abs

    void main()
    {
        writefln("%s", (3 + 1i) + (4 - 1i));
        writefln("%s", (5 - 9i) - (2 + 6i));
        writefln("%s", (5 + 3i) * (5 + 8i));
        writefln("%s", (9 - 7i) / (9 - 3i));
        writefln("%s", abs(2 + 3i));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8867'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8867
  :user_name: spoon
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1036/
  :language: OCaml
  :time: 2009/04/30 02:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    # open Complex;;
    # add { re = 3.0; im = 1.0 } { re = 4.0; im = -1.0 };;
    - : Complex.t = {re = 7.; im = 0.}
    # sub { re = 5.0; im = -9.0 } { re = 2.0; im = 6.0 };;
    - : Complex.t = {re = 3.; im = -15.}
    # mul { re = 5.0; im = 3.0 } { re = 5.0; im = 8.0 };;
    - : Complex.t = {re = 1.; im = 55.}
    # div { re = 9.0; im = -7.0 } { re = 9.0; im = -3.0 };;
    - : Complex.t = {re = 1.1333333333333333; im = -0.4}
    # norm { re = 2.0; im = 3.0 };;
    - : float = 3.60555127546398957
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8868'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8868
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2009/04/30 04:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    &gt;&gt; require 'complex'
    &gt;&gt; puts Complex(3.0, 1.0) + Complex(4.0, -1.0)
    7.0+0.0i
    &gt;&gt; puts Complex(5.0, -9.0) - Complex(2.0, 6.0)
    3.0-15.0i
    &gt;&gt; puts Complex(5.0, 3.0) * Complex(5.0, 8.0)
    1.0+55.0i
    &gt;&gt; puts Complex(9.0, -7.0) / Complex(9.0, -3.0)
    1.13333333333333-0.4i
    &gt;&gt; puts Complex(2.0, 3.0).abs
    3.60555127546399
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8869'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8869
  :user_name: sumim
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/88/
  :language: 
  :time: 2009/04/30 10:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>×整数にメッセージ i を　→　○実数にメッセージ i を</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8870'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8870
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2009/04/30 16:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">F#(fsi)での実行例\r\ndll の読み込みは、オプションでもできます。</pre>\n\t"
  :code: |
    &gt; #r "FSharp.PowerPack.dll";;
    &gt; open Math.Complex;;
    &gt; (complex 3. 1.) + (complex 4. -1.);;
    &gt; (complex 5. -9.) - (complex 2. 6.);;
    &gt; (complex 5. 3.) * (complex 5. 8.);;
    &gt; (complex 9. -7.) / (complex 9. -3.);;
    &gt; magnitude (complex 2. 3.) ;;
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '8871'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8871
  :user_name: spoon
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1036/
  :language: Ruby
  :time: 2009/04/30 19:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    &gt;&gt; require 'complex'
    &gt;&gt; puts (3.0 + 1.0.im) + (4.0 - 1.0.im)
    7.0+0.0i
    &gt;&gt; puts (5.0 - 9.0.im) - (2.0 + 6.0.im)
    3.0-15.0i
    &gt;&gt; puts (5.0 + 3.0.im) * (5.0 + 8.0.im)
    1.0+55.0i
    &gt;&gt; puts (9.0 - 7.0.im) / (9.0 - 3.0.im)
    1.13333333333333-0.4i
    &gt;&gt; puts (2.0 + 3.0.im).abs
    3.60555127546399
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8872'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8872
  :user_name: 匿名
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2009/05/01 10:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">結果を整形する場合には、\r\n&gt; printfn \"%O\" ((complex
    3. 1.) + (complex 4. -1.));;\r\nとかして下さい。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8881'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8881
  :user_name: vivisuke
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1039/
  :language: Other
  :time: 2009/05/03 12:59 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">言語は ViViScript\r\n実行結果：\r\n(7, 0)\r\n(3, -15)\r\n(1,
    55)\r\n(1.13333, -0.4)\r\n3.60555\r\n\r\n</pre>\n\t"
  :code: |
    class complex
    {
        function complex(r, i)
        {
            this.r = double(r);        //    実数部
            this.i = double(i);        //    虚数部
        }
        function format() { return "(" + this.r + ", " + this.i + ")"; }
    }
    function complex_add(lhs, rhs)
    {
        return new complex(lhs.r + rhs.r, lhs.i + rhs.i);
    }
    function complex_sub(lhs, rhs)
    {
        return new complex(lhs.r - rhs.r, lhs.i - rhs.i);
    }
    function complex_mul(lhs, rhs)
    {
        return new complex(lhs.r * rhs.r - lhs.i * rhs.i, lhs.r * rhs.i + lhs.i * rhs.r);
    }
    function complex_div(lhs, rhs)
    {
        $t = (rhs.r * rhs.r + rhs.i * rhs.i);
        return new complex((lhs.r * rhs.r + lhs.i * rhs.i) / $t, (lhs.i * rhs.r - lhs.r * rhs.i) / $t);
    }
    function complex_abs(c)
    {
        return Math.sqrt(c.r * c.r + c.i * c.i);
    }

    cout &lt;&lt; complex_add(new complex(3, 1), new complex(4, -1)).format() &lt;&lt; "\n";
    cout &lt;&lt; complex_sub(new complex(5, -9), new complex(2, 6)).format() &lt;&lt; "\n";
    cout &lt;&lt; complex_mul(new complex(5, 3), new complex(5, 8)).format() &lt;&lt; "\n";
    cout &lt;&lt; complex_div(new complex(9, -7), new complex(9, -3)).format() &lt;&lt; "\n";
    cout &lt;&lt; complex_abs(new complex(2, 3)) &lt;&lt; "\n";
  :tags:
  - ViViScript
  :references:
    :url: 
    :title: 
- :id: '8916'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8916
  :user_name: turugina
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/760/
  :language: XSLT
  :time: 2009/05/08 05:46 GMT
  :vote_count: '5'
  :vote_score: '3'
  :body: "\n\t  <p>絶対値を求めるのに必要な平方根を求める関数が標準では用意されないので頑張って作ってみたりなど、本質でない部分に労力が...\n使えるならEXSLTを使うといいかも。</p>\n<p>下記のようなxmlにxsltを適応すると計算できます。:</p>\n<pre
    class=\"literal-block\">\n&lt;complex-list&gt;\n  &lt;add&gt;\n    &lt;complex
    real=\"3\" imag=\"1\" /&gt;\n    &lt;complex real=\"4\" imag=\"-1\" /&gt;\n  &lt;/add&gt;\n
    \ &lt;sub&gt;\n    &lt;complex real=\"5\" imag=\"-9\" /&gt;\n    &lt;complex real=\"2\"
    imag=\"6\" /&gt;\n  &lt;/sub&gt;\n  &lt;mul&gt;\n    &lt;complex real=\"5\" imag=\"3\"
    /&gt;\n    &lt;complex real=\"5\" imag=\"8\" /&gt;\n  &lt;/mul&gt;\n  &lt;div&gt;\n
    \   &lt;complex real=\"9\" imag=\"-7\" /&gt;\n    &lt;complex real=\"9\" imag=\"-3\"
    /&gt;\n  &lt;/div&gt;\n  &lt;abs&gt;\n    &lt;complex real=\"2\" imag=\"3\" /&gt;\n
    \ &lt;/abs&gt;\n&lt;/complex-list&gt;\n</pre>\n\n\t"
  :code: |
    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;xsl:stylesheet version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:fn="http://www.w3.org/2005/xpath-functions"
      xmlns:my="uri:ja.doukaku.org:my-functions"
      exclude-result-prefixes="my"
      &gt;

      &lt;xsl:output method="text" /&gt;

      &lt;xsl:template match="/complex-list" &gt;
        &lt;xsl:for-each select="complex|add|sub|mul|div|abs"&gt;
          &lt;xsl:variable name="complex" as="xs:decimal*"&gt;
            &lt;xsl:sequence select="my:evaluate-node(.)" /&gt;
          &lt;/xsl:variable&gt;
          &lt;xsl:value-of select="my:complex-to-string($complex[1], $complex[2])" /&gt;
          &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:template&gt;

      &lt;xsl:function name="my:complex-to-string" as="xs:string"&gt;
        &lt;xsl:param name="real" as="xs:decimal" /&gt;
        &lt;xsl:param name="imag" as="xs:decimal" /&gt;

        &lt;xsl:variable name="realstr" as="xs:string" select="xs:string($real)" /&gt;
        &lt;xsl:variable name="imagsign" as="xs:string"&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test="$imag gt 0"&gt;
              &lt;xsl:value-of select="'+'" /&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="$imag lt 0"&gt;
              &lt;xsl:value-of select="'-'" /&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of select="''" /&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:variable name="imagstr" as="xs:string"&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test="fn:abs($imag)=1.0"&gt;
              &lt;xsl:value-of select="''" /&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of select="fn:abs($imag)" /&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:variable&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="$imag=0"&gt;
            &lt;xsl:value-of select="$realstr" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="fn:string-join(($realstr, $imagsign, fn:concat($imagstr, 'i')), ' ')" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-node" as="xs:decimal*"&gt;
        &lt;xsl:param name="node" as="node()" /&gt;

        &lt;xsl:variable name="node-name" as="xs:string" select="fn:name($node)" /&gt;
        &lt;xsl:variable name="complex" as="xs:decimal*"&gt;
          &lt;xsl:for-each select="$node/*"&gt;
            &lt;xsl:sequence select="my:evaluate-node(.)" /&gt;
          &lt;/xsl:for-each&gt;
        &lt;/xsl:variable&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="$node-name = 'complex'"&gt;
            &lt;xsl:sequence select="$node/@real" /&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="fn:exists($node/@imag)"&gt;
                &lt;xsl:sequence select="$node/@imag" /&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="0" /&gt;
              &lt;/xsl:otherwise&gt;
            &lt;/xsl:choose&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="$node-name = 'add'"&gt;
            &lt;xsl:sequence select="my:evaluate-add($complex)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="$node-name = 'sub'"&gt;
            &lt;xsl:sequence select="my:evaluate-sub($complex)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="$node-name = 'mul'"&gt;
            &lt;xsl:sequence select="my:evaluate-mul($complex)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="$node-name = 'div'"&gt;
            &lt;xsl:sequence select="my:evaluate-div($complex)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="$node-name = 'abs'"&gt;
            &lt;xsl:sequence select="my:evaluate-abs($complex)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:message terminate="yes"&gt;
              &lt;xsl:text&gt;*** unknown element name &lt;/xsl:text&gt;
              &lt;xsl:value-of select="$node-name" /&gt;
              &lt;xsl:text&gt; ***&lt;/xsl:text&gt;
            &lt;/xsl:message&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-add" as="xs:decimal*"&gt;
        &lt;xsl:param name="values" as="xs:decimal*" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="fn:empty($values)"&gt;
            &lt;xsl:sequence select="(0,0)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="fn:count($values)=2"&gt;
            &lt;xsl:sequence select="$values" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:variable name="intermediate" as="xs:decimal*"&gt;
              &lt;xsl:sequence select="$values[1] + $values[3]" /&gt;
              &lt;xsl:sequence select="$values[2] + $values[4]" /&gt;
              &lt;xsl:sequence select="$values[fn:count(.) gt 4]" /&gt;
            &lt;/xsl:variable&gt;
            &lt;xsl:sequence select="my:evaluate-add($intermediate)" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-sub" as="xs:decimal*"&gt;
        &lt;xsl:param name="values" as="xs:decimal*" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="fn:empty($values)"&gt;
            &lt;xsl:sequence select="(0,0)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="fn:count($values)=2"&gt;
            &lt;xsl:sequence select="$values" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:variable name="intermediate" as="xs:decimal*"&gt;
              &lt;xsl:sequence select="$values[1] - $values[3]" /&gt;
              &lt;xsl:sequence select="$values[2] - $values[4]" /&gt;
              &lt;xsl:sequence select="$values[fn:count(.) gt 4]" /&gt;
            &lt;/xsl:variable&gt;
            &lt;xsl:sequence select="my:evaluate-sub($intermediate)" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-mul" as="xs:decimal*"&gt;
        &lt;xsl:param name="values" as="xs:decimal*" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="fn:empty($values)"&gt;
            &lt;xsl:sequence select="(0,0)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="fn:count($values)=2"&gt;
            &lt;xsl:sequence select="$values" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:variable name="intermediate" as="xs:decimal*"&gt;
              &lt;xsl:sequence select="$values[1] * $values[3] - $values[2] * $values[4]" /&gt;
              &lt;xsl:sequence select="$values[1] * $values[4] + $values[2] * $values[3]" /&gt;
              &lt;xsl:sequence select="$values[fn:count(.) gt 4]" /&gt;
            &lt;/xsl:variable&gt;
            &lt;xsl:sequence select="my:evaluate-mul($intermediate)" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-div" as="xs:decimal*"&gt;
        &lt;xsl:param name="values" as="xs:decimal*" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="fn:empty($values)"&gt;
            &lt;xsl:sequence select="(0,0)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="fn:count($values)=2"&gt;
            &lt;xsl:sequence select="$values" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:variable name="intermediate" as="xs:decimal*"&gt;
              &lt;xsl:variable name="d" as="xs:decimal"
                select="$values[3] * $values[3] + $values[4] * $values[4]" /&gt;
              &lt;xsl:sequence select="($values[1] * $values[3] + $values[2] * $values[4]) div $d" /&gt;
              &lt;xsl:sequence select="($values[1] * $values[4] - $values[2] * $values[3]) div $d" /&gt;
              &lt;xsl:sequence select="$values[fn:count(.) gt 4]" /&gt;
            &lt;/xsl:variable&gt;
            &lt;xsl:sequence select="my:evaluate-div($intermediate)" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:evaluate-abs" as="xs:decimal*"&gt;
        &lt;xsl:param name="values" as="xs:decimal*" /&gt;

        &lt;xsl:sequence select="my:sqrt($values[1] * $values[1] + $values[2] * $values[2])" /&gt;
        &lt;xsl:sequence select="0" /&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:sqrt" as="xs:decimal"&gt;
        &lt;xsl:param name="n" as="xs:decimal" /&gt;
        &lt;xsl:variable name="base" as="xs:integer*"&gt;
          &lt;xsl:variable name="nstr" as="xs:string" select="xs:string($n)" /&gt;
          &lt;xsl:for-each select="0 to
            ($n idiv fn:string-length(if (fn:contains($nstr, '.'))
                                      then (fn:substring-before($nstr, '.'))
                                      else ($nstr)))" &gt;
            &lt;xsl:if test=". * . ge $n"&gt;
              &lt;xsl:sequence select="." /&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:value-of select="my:sqrt-search($n, $base[1], 10)" /&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:sqrt-search-base" as="xs:integer" &gt;
        &lt;xsl:param name="n" as="xs:decimal" /&gt;
        &lt;xsl:param name="m" as="xs:integer" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="$m * $m lt $n"&gt;
            &lt;xsl:value-of select="my:sqrt-search-base($n, $m + 1)" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="$m" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;

      &lt;xsl:function name="my:sqrt-search"&gt;
        &lt;xsl:param name="n" as="xs:decimal" /&gt;
        &lt;xsl:param name="m" as="xs:decimal" /&gt;
        &lt;xsl:param name="prec" as="xs:integer" /&gt;

        &lt;xsl:choose&gt;
          &lt;xsl:when test="$prec = 0"&gt;
            &lt;xsl:value-of select="$m" /&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="my:sqrt-search($n, (($m + ($n div $m)) div 2), $prec - 1)" /&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:function&gt;
    &lt;/xsl:stylesheet&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8929'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8929
  :user_name: turugina
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/760/
  :language: 
  :time: 2009/05/10 10:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>122,143,164,187行目の fn:count(.) gt 4 は fn:position() gt 4 の間違いでした。</p>\n<p>何という恥ずかしいミス...</p>\n<p>つーわけで、自分で-1</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8930'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/8930
  :user_name: airhead
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1026/
  :language: JavaScript
  :time: 2009/05/13 13:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  使うときに楽だろうと思い、引数の型に幅を持たせてみました。\r<br><br>例）\r<br>var c0 = new Complex(0, 1);\r<br>var c1 = new Complex([1, 1]);\r<br>var c2 = new Complex({r:3, i:-4});\r<br>var c3 = new Complex(\"5-8i\");\r<br><br>alert((new Complex(\"3+2i\")).mul(\"5-i\").mul(\"-6+2i\").div(\"5-i\").div(\"-6+2i\"));\r<br>"
  :code: |
    var Complex = function (arg0, arg1){
        arg0 = arg0 || 0;
        arg1 = arg1 || 0;
        if (typeof arg0 == "number" &amp;&amp; typeof arg1 == "number"){
            this.r = arg0;
            this.i = arg1;
        } else {
            var tmp = Complex.conv(arg0)
            this.r = tmp.r;
            this.i = tmp.i;
        }
    };

    // 加減乗除メソッドは破壊的
    Complex.prototype = {
        toString: function(){return Complex.toString(this);},
        valueOf:  function(){return Complex.toString(this);},
        abs: function(){return Complex.abs(this);},
        add: function(cn){
            var tmp = Complex.add(this, cn);
            this.r = tmp.r;
            this.i = tmp.i;
            return this;
        },
        sub: function(cn){
            var tmp = Complex.sub(this, cn);
            this.r = tmp.r;
            this.i = tmp.i;
            return this;
        },
        mul: function(cn){
            var tmp = Complex.mul(this, cn);
            this.r = tmp.r;
            this.i = tmp.i;
            return this;
        },
        div: function(cn){
            var tmp = Complex.div(this, cn);
            this.r = tmp.r;
            this.i = tmp.i;
            return this;
        }
    };

    // 以下はインスタンスのメソッドではない
    // 引数をインスタンスもどき（メソッドなしでプロパティr, iのみのオブジェクト）に変換する関数
    Complex.conv = function(arg){
        if (typeof arg == "object") {
            return {r: Number(arg.r || arg[0] || 0), i: Number(arg.i || arg[1] || 0)};
        } else if (typeof arg == "string") {
            var srcNum = "([+\\-]?(?:[0-9]+\\.?[0-9]*|0?\\.[0-9]+)(?:e[+\\-]?[0-9]+)?)";
            var reCNum = new RegExp("^(?:" + srcNum + "(?!i))?(?:" + srcNum + "i)?$", "i");
            reCNum.exec(arg.replace(/\s/g, "").replace(/(^|\+|-)i/i, "$11i"));
            return {r: Number(RegExp.$1), i: Number(RegExp.$2)};
        }
        return {r: Number(arg), i: 0};
    };

    // インスタンス相当を引数に取る関数
    Complex.toString = function(cn){
        cn = Complex.conv(cn);
        return cn.r.toString() + (cn.i &gt;= 0 ? "+" : "") + cn.i.toString() + "i";
    };
    Complex.abs = function(cn){
        cn = Complex.conv(cn);
        return Math.sqrt(cn.r * cn.r + cn.i * cn.i);
    };
    // 加減乗除関数は新しいインスタンスを返す
    Complex.add = function(cn0, cn1){
        cn0 = Complex.conv(cn0);
        cn1 = Complex.conv(cn1);
        return new Complex(cn0.r + cn1.r, cn0.i + cn1.i);
    };
    Complex.sub = function(cn0, cn1){
        cn0 = Complex.conv(cn0);
        cn1 = Complex.conv(cn1);
        return new Complex(cn0.r - cn1.r, cn0.i - cn1.i);
    };
    Complex.mul = function(cn0, cn1){
        cn0 = Complex.conv(cn0);
        cn1 = Complex.conv(cn1);
        return new Complex(cn0.r * cn1.r - cn0.i * cn1.i,
                           cn0.i * cn1.r + cn0.r * cn1.i);
    };
    Complex.div = function(cn0, cn1){
        cn0 = Complex.conv(cn0);
        cn1 = Complex.conv(cn1);
        var absSq = cn1.r * cn1.r + cn1.i * cn1.i;
        return new Complex((cn0.r * cn1.r + cn0.i * cn1.i) / absSq,
                           (cn0.i * cn1.r - cn0.r * cn1.i) / absSq);
    };
    // 定義部はここまで

    /* お題の計算。結果は以下
    7+0i
    3-15i
    1+55i
    1.1333333333333333-0.4i
    3.605551275463989
    */
    alert(
                 Complex.add(new Complex(3, 1),  new Complex(4, -1))
        + "\n" + Complex.sub(new Complex(5, -9), new Complex(2, 6))
        + "\n" + Complex.mul(new Complex(5, 3),  new Complex(5, 8))
        + "\n" + Complex.div(new Complex(9, -7), new Complex(9, -3))
        + "\n" + Complex.abs(new Complex(2, 3))
    );

    // インスタンスを作る。引数は数値2つ、
    // もしくは数値要素を2つ持つ（連想）配列か、複素数と解釈できる文字列
    var c0 = new Complex(0, 1);
    var c1 = new Complex([1, 1]);
    var c2 = new Complex({r:3, i:-4});
    var c3 = new Complex("5-8i");

    // 絶対値を出してみる。上3行と下3行の結果は同じ。
    alert(
                 "|" + c0 + "| = " + Complex.abs(c0)
        + "\n" + "|" + c1 + "| = " + Complex.abs(c1)
        + "\n" + "|" + c2 + "| = " + Complex.abs(c2)
        + "\n" + "|" + c0 + "| = " + c0.abs()
        + "\n" + "|" + c1 + "| = " + c1.abs()
        + "\n" + "|" + c2 + "| = " + c2.abs()
    );

    // 計算1。引数なら文字列のままでも可。
    // 下3行の計算は破壊的（c0の値が計算結果に変わる）
    alert(
            "(" + c0 + ") + (" + c1   + ") = " + Complex.add(c0, c1)
        + "\n(" + c0 + ") - (" + c2   + ") = " + Complex.sub(c0, c2)
        + "\n(" + c0 + ") / (" + "-i" + ") = " + Complex.div(c0, "-i")
        + "\n(" + c0 + ") + (" + c1   + ") = " + c0.add(c1)
        + "\n(" + c0 + ") - (" + c2   + ") = " + c0.sub(c2)
        + "\n(" + c0 + ") / (" + "-i" + ") = " + c0.div("-i")
    );

    // 計算2。iの2乗。加減乗除の組み合わせ2つ。複素数を0で割ると0/0
    alert(
          "i * i = " + Complex.mul("i", "i")

        + "\n(3+2i) * (5-i) * (-6+2i) / (5-i) / (-6+2i) = "
        + (new Complex("3+2i")).mul("5-i").mul("-6+2i").div("5-i").div("-6+2i")

        + "\n( (3+2i) + (4-i) ) * 2i * -.5i - (4-i) = "
        + Complex.add("3+2i", "4-i").mul("2i").mul("-.5i").sub("4-i")

        + "\n(1+2i) / 0 = " + Complex.div("1+2i", "0")
    );

    // 引数いろいろ。falsyな値や空配列は0+0iに
    var testcases = [
        "-3-8i", "5", [0, 4], [2, -8],
        "-2+i", "-2-i", {r:-2.5, i:3e-2}, "-2E8 + I",
        "0", "i", Infinity, NaN, "", {}, null, undefined
    ];
    for (var i = 0, rslt = ""; i &lt; testcases.length; i++){
        rslt += (typeof testcases[i]) + ": " + testcases[i]
            + "\n\t\t" + (new Complex(testcases[i])) + "\n";
    }
    alert(rslt);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9070'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/9070
  :user_name: bleis-tift
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/732/
  :language: SQL
  :time: 2009/06/08 09:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>SQL Server 2008 で確認しました。</p>\n<p>入力が微妙ですが、問題ID, 種類(左辺：1、演算子：2、右辺：3),
    実部, 虚部, 演算子(加算：1、減算：2、乗算：3、除算：4、絶対値：5)を与えます。</p>\n<p>すると、Resultsとして問題IDの答えの実部と虚部が取得できます。</p>\n\n\t"
  :code: |
    WITH
      Input(id, kind, real_part, img_part, op) AS (
        -- (3 + i) + (4 - i)
        SELECT 1, 1, 3, 1, CAST(NULL AS int)
        UNION ALL
        SELECT 1, 2, NULL, NULL, 1
        UNION ALL
        SELECT 1, 3, 4, -1, NULL
        UNION ALL
        -- (5 - 9i) - (2 + 6i)
        SELECT 2, 1, 5, -9, NULL
        UNION ALL
        SELECT 2, 2, NULL, NULL, 2
        UNION ALL
        SELECT 2, 3, 2, 6, NULL
        UNION ALL
        -- (5 + 3i) * (5 + 8i)
        SELECT 3, 1, 5, 3, NULL
        UNION ALL
        SELECT 3, 2, NULL, NULL, 3
        UNION ALL
        SELECT 3, 3, 5, 8, NULL
        UNION ALL
        -- (9 - 7i) / (9 - 3i)
        SELECT 4, 1, 9, -7, NULL
        UNION ALL
        SELECT 4, 2, NULL, NULL, 4
        UNION ALL
        SELECT 4, 3, 9, -3, NULL
        UNION ALL
        -- |2 + 3i|
        SELECT 5, 1, 2, 3, NULL
        UNION ALL
        SELECT 5, 2, NULL, NULL, 5
      )
    , Interval(id, l_real, l_img, op, r_real, r_img) AS (
        SELECT
            id
          , SUM(CASE kind WHEN 1 THEN real_part ELSE 0 END)
          , SUM(CASE kind WHEN 1 THEN img_part ELSE 0 END)
          , SUM(CASE kind WHEN 2 THEN op ELSE 0 END)
          , SUM(CASE kind WHEN 3 THEN real_part ELSE 0 END)
          , SUM(CASE kind WHEN 3 THEN img_part ELSE 0 END)
        FROM
            Input
        GROUP BY
            id
      )
    , Results(id, real_part, img_part) AS (
        SELECT
            id
          , CASE op
            WHEN 1 THEN l_real + r_real
            WHEN 2 THEN l_real - r_real
            WHEN 3 THEN (l_real * r_real) - (l_img * r_img)
            WHEN 4 THEN ((l_real * r_real) + (l_img * r_img)) /
                        (SQUARE(r_real) + SQUARE(r_img))
            WHEN 5 THEN SQRT(SQUARE(l_real) + SQUARE(l_img))
            END
          , CASE op
            WHEN 1 THEN l_img + r_img
            WHEN 2 THEN l_img - r_img
            WHEN 3 THEN (l_img * r_real) + (l_real * r_img)
            WHEN 4 THEN ((l_img * r_real) - (l_real * r_img)) /
                        (SQUARE(r_real) + SQUARE(r_img))
            WHEN 5 THEN 0
            END
        FROM
            Interval
      )
    SELECT * FROM Results
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9114'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/9114
  :user_name: Songmu
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/763/
  :language: Perl
  :time: 2009/06/11 00:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>演算子オーバーロードを使ってスクラッチで実装。\nPerlの真骨頂。</p>\n\n\t"
  :code: "#!/usr/bin/perl\nuse strict;\nuse warnings;\n\npackage ComplexNumber;\nuse
    overload\n    '\"\"' =&gt; \\&amp;toString,\n    '+'  =&gt; \\&amp;add,\n    '-'
    \ =&gt; \\&amp;sub,\n    '*'  =&gt; \\&amp;mul,\n    '/'  =&gt; \\&amp;div,\n
    \   '0+' =&gt; \\&amp;val,\n;\nsub new{\n    my ($class, $real, $imagin) = @_;\n
    \   return unless defined($real);\n    \n    if($real =~ /^[-+]?\\d+(\\.\\d+)?$/
    and \n       (!defined($imagin) or $imagin =~ /^[-+]?\\d*(\\d\\.\\d+)?i?$/))\n
    \   {#$real, $imagin両方に数値が渡ってきた時。$imaginが未定義/末尾にiは許容\n        $real   =~ s/\\+//;\n
    \       $imagin =~ s/[i+]//g if $imagin;\n        $imagin = 0 unless $imagin;\n
    \       return bless {a=&gt;$real, b=&gt;$imagin}, $class;\n    }\n    return
    if $imagin;\n    if($real =~ /^[-+]?\\d+(\\.\\d+)?i$/){#第1引数 に 文字列'5i'とかが渡された時\n
    \       $real =~ s/[i+]//g;\n        return bless {a=&gt;0, b=&gt;$real}, $class;\n
    \   }\n    $real =~ s/\\s//g;\n    if(my ($real2, $imagin2) = $real =~ /^([-+]?\\d+(?:\\.\\d+)?)([-+]\\d+(?:\\.\\d+)?)i$/){\n
    \   #第1引数 に 文字列(ex. '5+4.8i')が渡された時\n        $real2 =~ s/\\+//;\n        $imagin2
    =~ s/\\+//;\n        return bless {a=&gt;$real2, b=&gt;$imagin2}, $class;\n    }\n
    \   return;\n}\nsub toString{\n    my $self = shift;\n    return $self-&gt;{'a'}
    if $self-&gt;{'b'} == 0;\n    return (abs($self-&gt;{'b'}) != 1 ? $self-&gt;{'b'}
    : '-') . 'i'\n        if $self-&gt;{'a'} == 0;\n    return $self-&gt;{'a'} . \n
    \          ($self-&gt;{'b'} &gt; 0 ? '+' : '') . \n           (abs($self-&gt;{'b'})
    != 1 ? $self-&gt;{'b'} : '-') .'i';\n}\nsub add{\n    my ($self, $src) = @_;\n
    \   $src = ComplexNumber-&gt;new($src) unless eval{$src-&gt;isa('ComplexNumber')};\n
    \   return $src ?\n        ComplexNumber-&gt;new($self-&gt;{'a'}+$src-&gt;{'a'},
    $self-&gt;{'b'}+$src-&gt;{'b'}) : ();\n}\nsub sub{\n    my ($dest, $src, $rev)
    = @_;\n    $src = ComplexNumber-&gt;new($src) unless eval{$src-&gt;isa('ComplexNumber')};\n
    \   return unless $src;\n    ($dest, $src) = ($src, $dest) if $rev;\n    return
    ComplexNumber-&gt;new($dest-&gt;{'a'}-$src-&gt;{'a'}, $dest-&gt;{'b'}-$src-&gt;{'b'});\n}\nsub
    mul{\n    my ($dest, $src) = @_;\n    $src = ComplexNumber-&gt;new($src) unless
    eval{$src-&gt;isa('ComplexNumber')};\n    return $src ?\n        ComplexNumber-&gt;new(\n
    \           $dest-&gt;{'a'}*$src-&gt;{'a'} - $dest-&gt;{'b'}*$src-&gt;{'b'},\n
    \           $dest-&gt;{'a'}*$src-&gt;{'b'} + $dest-&gt;{'b'}*$src-&gt;{'a'}\n
    \       ) : ();\n}\nsub div{\n    my ($dest, $src, $rev) = @_;\n    $src = ComplexNumber-&gt;new($src)
    unless eval{$src-&gt;isa('ComplexNumber')};\n    return unless $src;\n    ($dest,
    $src) = ($src, $dest) if $rev;\n    return ComplexNumber-&gt;new(\n        ($dest-&gt;{'a'}*$src-&gt;{'a'}+$dest-&gt;{'b'}*$src-&gt;{'b'})/($src-&gt;{'a'}**2
    + $src-&gt;{'b'}**2),\n        ($dest-&gt;{'b'}*$src-&gt;{'a'}-$dest-&gt;{'a'}*$src-&gt;{'b'})/($src-&gt;{'a'}**2
    + $src-&gt;{'b'}**2),\n    );\n}\nsub abs{\n    my $self = shift;\n    return
    sqrt($self-&gt;{'a'}**2 + $self-&gt;{'b'}**2)\n}\nsub val{\n    my $self = shift;\n
    \   return $self-&gt;{'a'};\n}\n\npackage main;\n\nmy $comp1 = ComplexNumber-&gt;new(8,
    6.3);\nmy $comp2 = ComplexNumber-&gt;new('4 - 8.5i');\n\nprint $comp1 + $comp2
    .\"\\n\";\nprint $comp1 - $comp2 .\"\\n\";\nprint $comp1 * $comp2 .\"\\n\";\nprint
    $comp1 / $comp2 .\"\\n\\n\";\n\nprint $comp1 + 8 .\"\\n\";\nprint $comp1 - 8 .\"\\n\";\nprint
    8 - $comp1 .\"\\n\";\nprint $comp1 * 8 .\"\\n\";\nprint $comp1 / 8 .\"\\n\";\nprint
    8 / $comp1 .\"\\n\";\n\nprint $comp1-&gt;abs;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9160'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/9160
  :user_name: yamamoto
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1064/
  :language: Scala
  :time: 2009/06/14 02:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>#8851をパラメタ付に改造してみました。\nComplex[Int],Complex[Double]</p>\n<p>もう、ぐだぐだ。</p>\n<p>制限事項\n整数と実数の混合ができない
    orz</p>\n\n\t"
  :code: "// 複素数(お題:http://ja.doukaku.org/247/)\n// http://ja.doukaku.org/comment/----/\n//
    snaさん作を改変( : http://ja.doukaku.org/comment/8851/)\n// 参考 : http://en.literateprograms.org/Complex_numbers_(Scala)\n\ntrait
    Arithmetic[T&lt;:AnyVal]{\n  def unary_+ : T\n  def unary_- : T\n  def + (that:T):T\n
    \ def - (that:T):T\n  def * (that:T):T\n  def / (that:T):T\n  def abs : T\n  //\n
    \ def lt0 : Boolean  // &gt;   0\n  def gt0 : Boolean  // &lt;   0\n  def eq0
    : Boolean  // ==  0\n  //\n  def eqp1 : Boolean // ==  1\n  def eqm1 : Boolean
    // == -1\n  //\n}\n\ncase class Complex[ T&lt;%Arithmetic[T] ](real:T, imag:T)
    {\n  // +(a + bi) = (a + bi)\n  def unary_+ = this\n  \n  // -(a + bi) = (-a -
    bi)\n  def unary_- = Complex[T](-real, -imag)\n  \n  // (a + bi) + (c + di) =
    (a + c) + (b + d)i\n  def + (that: Complex[T]) = Complex(this.real + that.real,
    this.imag + that.imag)\n  \n  // (a + bi) - (c + di) = (a - c) + (b - d)i\n  def
    - (that: Complex[T]) = Complex(this.real - that.real, this.imag - that.imag)\n
    \ \n  // (a + bi) * (c + di) = (ac - bd) + (bc + ad)i\n  def * (that: Complex[T])
    = {\n    val Complex(a, b) = this\n    val Complex(c, d) = that\n    Complex(a*c
    - b*d, b*c + a*d)\n  }\n  \n  // (a + bi) / (c + di) = (ac + bd) / (c^2 + d^2)
    + (bc - ad) / (c^2 + d^2)\n  def / (that: Complex[T]) = {\n    val Complex(a,
    b) = this\n    val Complex(c, d) = that\n    val deno = c*c + d*d\n    Complex((a*c
    + b*d) / deno, (b*c - a*d) / deno)\n  }\n  \n  // Conjugate\n  def conjugate()
    : Complex[T] = Complex(real,-imag)\n  \n  override def toString = this match {\n
    \   case Complex(re, im) if im.eq0            =&gt; re.toString\n    case Complex(re,
    im) if re.eq0 &amp;&amp; im.eqp1 =&gt; \"i\"\n    case Complex(re, im) if re.eq0
    &amp;&amp; im.eqm1 =&gt; \"-i\"\n    case Complex(re, im) if re.eq0            =&gt;
    im.toString + \"i\"\n    case Complex(re, im) if           im.eqp1 =&gt; re.toString
    + \" + i\"\n    case Complex(re, im) if           im.eqm1 =&gt; re.toString +
    \" - i\"\n    case Complex(re, im) if           im.gt0  =&gt; re.toString + \"
    + \" + im.toString + \"i\"\n    case Complex(re, im) if           im.lt0  =&gt;
    re.toString + \" - \" + im.abs.toString + \"i\"\n  }\n\n}\n\nobject test{\n  implicit
    def int2Arithmeic(n:Int) : Arithmetic[Int] = \n                    new Arithmetic[Int]{\n
    \                        def unary_+ : Int  = n.unary_+\n                         def
    unary_- : Int  = n.unary_-\n                         def + (that:Int):Int = n+that\n
    \                        def - (that:Int):Int = n-that\n                         def
    * (that:Int):Int = n*that\n                         def / (that:Int):Int = n/that\n
    \                        def abs = Math.abs(n)\n                         //\n
    \                        def lt0 = n&lt;0\n                         def gt0 =
    n&gt;0\n                         def eq0 = n==0\n                         //\n
    \                        def eqp1 = n==1 \n                         def eqm1 =
    n== -1  }\n  \n  implicit def double2Arithmeic(n:Double) : Arithmetic[Double]
    = \n                    new Arithmetic[Double]{\n                         def
    unary_+ : Double  = n.unary_+\n                         def unary_- : Double  =
    n.unary_-\n                         def + (that:Double):Double = n+that\n                         def
    - (that:Double):Double = n-that\n                         def * (that:Double):Double
    = n*that\n                         def / (that:Double):Double = n/that\n                         def
    abs = Math.abs(n)\n                         //\n                         def lt0
    = n&lt;0\n                         def gt0 = n&gt;0\n                         def
    eq0 = n==0\n                         //\n                         def eqp1 = n==1
    \n                         def eqm1 = n== -1  }\n  \n  implicit def int2Complex
    \  (n:Int   ):Complex[Int   ] = Complex(n,0)\n  implicit def double2Complex(n:Double):Complex[Double]
    = Complex(n,0)\n  implicit def icomp2dcomp   (z:Complex[Int]):Complex[Double]
    = Complex(z.real,z.imag)\n  \n  implicit def dcomp2richer  (z:Complex[Double])
    = new Proxy{\n       val self=z\n       def abs = self match {\n         case
    Complex(re, im) =&gt; Math.sqrt(re*re + im*im)\n       }\n    }\n  \n  implicit
    def icomp2richer  (z:Complex[int]) = new Proxy{\n       val self=z\n       def
    abs = self match {\n         case Complex(re, im) =&gt; Math.sqrt(re*re + im*im)\n
    \      }\n    }\n  \n  \n  def main( args:Array[String] ) : Unit = {\n    {\n
    \     val i = Complex(0,1)\n      println( (3 + i  ) + (4 - i  ) )\n      println(
    (5 - 9*i) - (2 + 6*i) )\n      println( (5 + 3*i) * (5 + 8*i) )\n      println(
    (9 - 7*i) / (9 - 3*i) )\n      println( (2 + 3*i).abs         )\n    }\n    \n
    \   {\n      val i = Complex(0.,1.)\n      println( (3. + i  ) + (4. - i  ) )\n
    \     println( (5. - 9.*i) - (2. + 6.*i) )\n      println( (5. + 3.*i) * (5. +
    8.*i) )\n      println( (9. - 7.*i) / (9. - 3.*i) )\n      println( (2. + 3.*i).abs
    \        )\n    }\n  }\n}\n"
  :tags:
  - 移植
  :references:
    :url: 
    :title: 
- :id: '9455'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/9455
  :user_name: uehaj
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/959/
  :language: Groovy
  :time: 2009/08/07 21:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Groovyで。結果は以下の通り。\n.iあたりが気に入っている。</p>\n<p>7.0+0.0i\n3.0-15.0i\n1.0+55.0i\n1.1333333333333333-0.4i\n3.605551275463989</p>\n\n\t"
  :code: |
    class Complex {
      double re
      double im

      Complex(re, im) { this.re = re; this.im = im }
      Complex plus(c) { new Complex(re+c.re, im+c.im) }
      Complex minus(c) { new Complex(re-c.re, im-c.im)  }
      Complex multiply(c) { new Complex(re*c.re - im*c.im, re*c.im + im*c.re) }
      Complex div(c) {
        def denom = (c.re ** 2) + (c.im ** 2)
        new Complex((re*c.re+im*c.im)/denom, (im*c.re-re*c.im)/denom)
      }
      double abs(){ Math.sqrt(re ** 2 + im ** 2) }
      static final i = new Complex(0, 1)
      String toString() { re+(im&gt;=0?'+':'')+im+'i' }
    }

    ['plus','minus','multiply','div'].each {
      Number.metaClass."$it" = { Complex c -&gt; new Complex(delegate, 0)."$it"(c) }
    }
    Number.metaClass.getI = {new Complex(0, delegate)}


    def i = Complex.i

    println ((3 + i) + (4 - i))
    println ((5 - 9.i) - (2 + 6.i))
    println ((5 + 3.i) * (5 + 8.i))
    println ((9 - 7.i) / (9 - 3.i))
    println ((2 - 3.i).abs())
  :tags:
  - complex
  - dsl
  - groovy
  :references:
    :url: 
    :title: 
- :id: '10482'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/10482
  :user_name: rennos
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1024/
  :language: HSP
  :time: 2010/05/01 06:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>モジュールによる疑似クラス機能を使ってみました。\n一時オブジェクトの構築ができないのと、演算子オーバーロードができないのはちょっと辛いです……。</p>\n\n\t"
  :code: "#module MCComplex mr, mi\n\n#defcfunc pow_own@MCComplex double src\n    return
    src * src\n    \n//*******************************************\n//        構築\n//*******************************************\n#define
    global complex_new(%1, %2 = 0, %3 = 0) newmod %1, MCComplex@, %2, %3\n#modinit
    double re_, double im_\n    complex_set thismod, re_, im_\n    return\n    \n#modfunc
    complex_set double re_, double im_\n    mr = re_\n    mi = im_\n    return\n    \n//*******************************************\n//
    \       取得系\n//*******************************************\n#modcfunc complex_re\n
    \   return mr\n    \n#modcfunc complex_im\n    return mi\n    \n#modcfunc complex_abs\n
    \   return sqrt( pow_own(mr) + pow_own(mi) )\n    \n#modcfunc complex_arg\n    return
    atan( mi, mr )\n    \n//*******************************************\n//        演算系\n//*******************************************\n#modfunc
    complex_add var rhs\n    mr += complex_re(rhs)\n    mi += complex_im(rhs)\n    return\n
    \   \n#modfunc complex_sub var rhs\n    mr -= complex_re(rhs)\n    mi -= complex_im(rhs)\n
    \   return\n    \n#modfunc complex_mul var rhs,  local rhsRe, local rhsIm, local
    re_, local im_\n    rhsRe = complex_re(rhs)\n    rhsIm = complex_im(rhs)\n    re_
    = (mr * rhsRe) - (mi * rhsIm)\n    im_ = (mr * rhsIm) + (mi * rhsRe)\n    complex_set
    thismod, re_, im_\n    return\n    \n#modfunc complex_div var rhs,  local rhsRe,
    local rhsIm, local re_, local im_, local denominator\n    rhsRe = complex_re(rhs)\n
    \   rhsIm = complex_im(rhs)\n    denominator = pow_own(rhsRe) + pow_own(rhsIm)\n
    \   re_ = double( mr * rhsRe + mi * rhsIm) / denominator\n    im_ = double(-mr
    * rhsIm + mi * rhsRe) / denominator\n    complex_set thismod, re_, im_\n    return\n
    \   \n#modcfunc complex_toDbgStr\n    return strf( \"(%.3f + %.3fi)\", mr, mi
    )\n    \n#global\n\n#if 1\n\n    complex_new lhs\n    complex_new rhs\n    \n//
    \   1. 加算  ( 3 + i ) + ( 4 - i )\n    complex_set lhs, 3,  1\n    complex_set
    rhs, 4, -1\n    complex_add lhs, rhs    // lhs += rhs\n    mes \"(3 +  i) + (4
    -  i) = \" + complex_toDbgStr( lhs )\n    \n//    2. 減算  ( 5 - 9i ) - ( 2 + 6i
    )\n    complex_set lhs, 5, -9\n    complex_set rhs, 2,  6\n    complex_sub lhs,
    rhs\n    mes \"(5 - 9i) - (2 + 6i) = \" + complex_toDbgStr( lhs )\n    \n//    3.
    乗算  ( 5 + 3i ) * ( 5 + 8i )\n    complex_set lhs, 5, 3\n    complex_set rhs, 5,
    8\n    complex_mul lhs, rhs\n    mes \"(5 + 3i) * (5 + 8i) = \" + complex_toDbgStr(
    lhs )\n    \n//    4. 除算 ( 9 - 7i )  /  ( 9 - 3i )\n    complex_set lhs, 9, -7\n
    \   complex_set rhs, 9, -3\n    complex_div lhs, rhs\n    mes \"(9 - 7i) / (9
    - 3i) = \" + complex_toDbgStr( lhs )\n    \n//    5. 絶対値  | 2 + 3i |\n    complex_set
    lhs, 2, 3\n    r = complex_abs( lhs )\n    mes \"|2 + 3i| = \" + r\n    \n    stop\n
    \   \n#endif\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10506'
  :parent_id: '247'
  :url: http://ja.doukaku.org/comment/10506
  :user_name: tfviv
  :user_url: /web/20100628135508/http://ja.doukaku.org/user/1163/
  :language: Erlang
  :time: 2010/05/15 11:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">エラー処理とか入ってません。\r\n\r\nerlc complex.erl &amp;&amp;
    erl -noshell -s complex main -s init stop \r\n\r\nでテスト。\r\n\r\n数値誤差が激しそうです。</pre>\n\t"
  :code: "-module(complex). \n-export([main/0]).\n-record(complex_number, {real=0,
    imaginary=0}).\nmain() -&gt;\n    io:format(\"(3+i) + (4-i) = ~p~n\", [dump(add(complex(3,1),
    complex(4,-1)))]),\n    io:format(\"(5-9i) - (2+6i) = ~p~n\", [dump(sub(complex(5,-9),
    complex(2,6)))]),\n    io:format(\"(5+3i) * (5+8i) = ~p~n\", [dump(multi(complex(5,3),
    complex(5,8)))]),\n    io:format(\"(9-7i) / (9-3i) = ~p~n\", [dump(divide(complex(9,-7),
    complex(9,-3)))]),\n    io:format(\"|2 + 3i| = ~p~n\", [cabs(complex(2,3))]).\n\ncomplex(R,
    I) -&gt; #complex_number{real=R, imaginary=I}.\n\nadd(X, Y) -&gt; complex(real(X)
    + real(Y), imaginary(X) + imaginary(Y)).\nsub(X, Y) -&gt; add(X, Y#complex_number{real=-real(Y),
    imaginary=-imaginary(Y)}).\ncomplex_conjugate(X) -&gt; complex(real(X), -imaginary(X)).\nmulti(X,
    Y) -&gt;\n    complex(real(X) * real(Y) - imaginary(X)*imaginary(Y),\n        imaginary(X)
    * real(Y) + real(X) * imaginary(Y)).\n\ndivide(X, Y) -&gt;\n    Div = real(double(Y)),\n
    \   Z = multi(X, complex_conjugate(Y)),\n    complex(real(Z)/Div, imaginary(Z)/Div).\n\ndouble(X)
    -&gt; multi(X, complex_conjugate(X)).\n\ncabs(X) -&gt; math:sqrt(real(double(X))).\n\nreal(X)
    -&gt; X#complex_number.real.\nimaginary(X) -&gt; X#complex_number.imaginary.\n\ndump(X)
    -&gt; {real(X), imaginary(X)}.\n"
  :tags: []
  :references:
    :url: /web/20100628135508/http://www.trapexit.org/Complex_Numbers
    :title: ''
