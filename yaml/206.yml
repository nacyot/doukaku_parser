---
:id: '206'
:title: 2^i * 3^j * 5^k なる整数
:comments:
- :id: '7554'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7554
  :user_name: leque
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/840/
  :language: 
  :time: 2008/09/02 10:56 GMT
  :vote_count: '3'
  :vote_score: '1'
  :body: "\r\n\t  <p>2^i * 3^j * 5^k の形で表される整数を小さい方から順に 100 個列挙するプログラムを書いてください。 i,
    j, k は 0 以上の整数です。アルゴリズムのオーダーについても考えてみてください。</p>\n<p>例えば最初の 10 個は次のようになります:</p>\n<pre
    class=\"literal-block\">\n 1 = 2^0 * 3^0 * 5^0\n 2 = 2^1 * 3^0 * 5^0\n 3 = 2^0
    * 3^1 * 5^0\n 4 = 2^2 * 3^0 * 5^0\n 5 = 2^0 * 3^0 * 5^1\n 6 = 2^1 * 3^1 * 5^0\n
    8 = 2^3 * 3^0 * 5^0\n 9 = 2^0 * 3^2 * 5^0\n10 = 2^1 * 3^0 * 5^1\n12 = 2^2 * 3^1
    * 5^0\n</pre>\n<p>※解答では i, j, k の各値を示す必要はありません。</p>\n\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7637'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7637
  :user_name: こう。
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/134/
  :language: C
  :time: 2008/09/16 18:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">何も考えずに。</pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n\nint main(){\n    int m=1;\n    int n=0;\n    int
    i,j,k;\n    int v;\n    \n    do{\n        v=m;\n        i=0;\n        j=0;\n
    \       k=0;\n        while(v%2==0)v/=2,i++;\n        while(v%3==0)v/=3,j++;\n
    \       while(v%5==0)v/=5,k++;\n        if(v==1){\n            printf(\"%d = 2^%d
    * 3^%d * 5^%d\\n\",m,i,j,k);\n            n++;\n        }\n        m++;\n    }while(n&lt;100);\n
    \   return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7638'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7638
  :user_name: 84q
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/927/
  :language: C
  :time: 2008/09/17 01:17 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <p>priority queue で。</p>\n\n\t"
  :code: "#include &lt;cstdio&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nconst
    int DNUM = 100;\n\nint main(void)\n{\n    int pre = 0, i = 0;\n    priority_queue&lt;int,
    vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;\n    pq.push(1);\n    \n    while(i
    &lt; DNUM)\n    {\n        int a = pq.top();\n        pq.pop();\n        if(a
    == pre) continue;\n        \n        printf(\"%d\\n\", a);\n        pq.push(a
    * 2);\n        pq.push(a * 3);\n        pq.push(a * 5);\n        \n        pre
    = a;\n        i++;\n    }\n    \n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7639'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7639
  :user_name: tnk
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/30/
  :language: Java
  :time: 2008/09/16 20:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">おなじアルゴリズムになってしまいました。\r\n100個目は1536。</pre>\n\t"
  :code: |
    public class Int235 {
        public static void main(String[] a) {
            int limit = 100;
            for (int n = 0, i = 1; n &lt; limit; i++) {
                int tmp = i;
                while (tmp % 2 == 0) tmp /= 2;
                while (tmp % 3 == 0) tmp /= 3;
                while (tmp % 5 == 0) tmp /= 5;
                if (tmp == 1) {
                    System.out.println(i);
                    n++;
                }
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7640'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7640
  :user_name: M.Suzuki
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/771/
  :language: Haskell
  :time: 2008/09/17 02:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">軽く候補の絞込み(2と3と5の倍数しか回答は無いので)を入れてみました。\r\n</pre>\n\t"
  :code: |
    list max b n
        | (b^n) &gt; max   =   []
        | otherwise = n : list max b (n+1)

    scan n = [(n,i,j,k)|i&lt;-list n 2 0,j&lt;-list n 3 0,k&lt;-list n 5 0,n == (2^i*3^j*5^k)]

    result = take 100 $ concatMap (scan) $ filter (check) [1..]

    check n
        | n == 1            =   True
        | (n `mod` 2) == 0  =   True
        | (n `mod` 3) == 0  =   True
        | (n `mod` 5) == 0  =   True
        | otherwise         =   False

    main=do
        mapM (\x-&gt; putStrLn $ format x) result
        where
            format (n,i,j,k) = concat [show n," = ",fmt 2 i," * ",fmt 3 j," * ",fmt 5 k]
            fmt b n = show b ++ "^" ++ show n
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7641'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7641
  :user_name: turugina
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/760/
  :language: C
  :time: 2008/09/17 02:32 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  <pre class=\"compact\">i,j,k は示さなくてもいいそうなので、簡単に。</pre>\n\t"
  :code: |
    #include &lt;iostream&gt;

    int main()
    {
      int n = 0;
      for ( int i = 1; n &lt; 100; ++i )
        if ( i == 1 || i % 2 == 0 || i % 3 == 0 || i % 5 == 0 ) {
          std::cout &lt;&lt; i &lt;&lt; ", ";
          ++n;
        }
      std::cout &lt;&lt; "\n";
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7642'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7642
  :user_name: Dubhead
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/785/
  :language: Python
  :time: 2008/09/17 03:07 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#7638 さんのアルゴリズムを借用。\r\npriority queueの代わりに、標準ライブラリのヒープキューを使います。</pre>\n\t"
  :code: |
    #!/usr/bin/python

    from heapq import heappush, heappop

    def doukaku206(num_answers):
        answers = []
        heap = [1]
        prev_answer = 0
        while len(answers) &lt; num_answers:
            a = heappop(heap)
            if a == prev_answer:
                continue
            answers.append(a)
            heappush(heap, a * 2)
            heappush(heap, a * 3)
            heappush(heap, a * 5)
            prev_answer = a
        return answers

    print doukaku206(100)

    # eof
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7643'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7643
  :user_name: turugina
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/760/
  :language: C
  :time: 2008/09/17 03:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">しまった、これでは12の次が15(3*5)じゃなくて14(2*7)になってしまう。\r\n反省して--self。\r\nそして、まともに動くものを。</pre>\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;map&gt;

    std::map&lt;int,int&gt; factor(int n)
    {
      std::map&lt;int, int&gt; r;
      r[2] = r[3] = r[5] = 0;
      while ( n%2==0 ) { n/=2; ++r[2]; }
      while ( n%3==0 ) { n/=3; ++r[3]; }
      while ( n%5==0 ) { n/=5; ++r[5]; }

      if ( n != 1 ) r.clear();
      return r;
    }

    int main()
    {
      for ( int i = 1, n = 0; n &lt; 100; ++i ) {
        std::map&lt;int,int&gt; f = factor(i);

        if ( !f.empty() ) {
          std::cout &lt;&lt; i &lt;&lt; " = 2^" &lt;&lt; f[2] &lt;&lt;
                            " * 3^" &lt;&lt; f[3] &lt;&lt;
                            " * 5^" &lt;&lt; f[5] &lt;&lt; "\n";
          ++n;
        }
      }
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7644'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7644
  :user_name: sumim
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2008/09/17 03:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Squeak Smalltalk で。</p>\n\n\t"
  :code: |
    | count n |
    count := 0.
    n := 0.
    World findATranscript: nil.
    [n := n + 1. count &lt; 100] whileTrue: [
        (#(2 3 5) inject: n into: [:quo :each |
                [quo isDivisibleBy: each] whileTrue: [quo := quo / each]. quo]) = 1
             ifTrue: [
                count := count + 1.
                Transcript cr; show: n]]
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '7645'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7645
  :user_name: kozima
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2008/09/17 03:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>適当に生成しながら小さい順に並べてます。動けばいい的な作りですが。考え方は 84q さんのと同じでしょうか。</p>\n<p>計算量は時間
    O(N^2) 空間 O(N) かと思いましたが、実際に試してみた感じだともっと小さいかもしれません。また balanced tree をつかうなど真面目に効率化をやればもっと速くなると思います。</p>\n\n\t"
  :code: |
    (defun add (n list)
      (if (find n list) list (merge 'list list (list n) #'&lt;)))

    (defun h (n)
      (let ((a (list 1)) (c 0))
        (loop (let ((m (pop a)))
                (print m)
                (setf a (add (* m 2) (add (* m 3) (add (* m 5) a))))
                (if (= (incf c) n) (return))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7646'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7646
  :user_name: horiuchi
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/570/
  :language: Java
  :time: 2008/09/16 22:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>別のアルゴリズムで解いてみました。\r</p>\n<p>数が大きくなれば有利かな？</p>\n</div>\n\t"
  :code: |
    public class Sample206 {
        public static void main(String[] args) {
            OUTER: for (int i = 1, n = 0; n &lt; 100; i++) {
                for (int p = 7; p &lt;= i; p += 2) {
                    if (p % 3 == 0) continue;
                    if (p % 5 == 0) continue;
                    if (i % p == 0) {
                        continue OUTER;
                    }
                }
                System.out.println(i);
                n++;
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7647'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7647
  :user_name: syat
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/766/
  :language: JavaScript
  :time: 2008/09/17 04:48 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Javascript@Firebug。\nn2,n3,n5の最大値は試行錯誤で決めてます</p>\n\n\t"
  :code: |
    var o={};
    for(var n2=0; n2&lt;=11; n2++)
      for(var n3=0; n3&lt;=8; n3++)
        for(var n5=0; n5&lt;=7; n5++)
          o[Math.pow(2,n2)*Math.pow(3,n3)*Math.pow(5,n5)] = [n2,n3,n5];
    for(var i=0,c=0;c&lt;100;i++)
      if(o[i]!=null)
        console.debug(++c, ". ", i, "= 2^", o[i][0], " + 3^", o[i][1], " + 5^", o[i][2]);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7648'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7648
  :user_name: turugina
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/760/
  :language: Perl
  :time: 2008/09/17 00:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">one-linerというかgolfというか...\r\nアルゴリズムは他の皆さんと同じです。</pre>\n\t"
  :code: |
    1==shift@z&amp;&amp;++$n&amp;&amp;printf"%d = 2^%d * 3^%d *%s 5^%d\n",@z
    while$n&lt;100&amp;&amp;(@z=(++$i,$i,0,0,'',0))&amp;&amp;
    map{$z[0]/=$_,++$z[$_]until$z[0]%$_}2,3,5
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7649'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7649
  :user_name: matarillo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/136/
  :language: C
  :time: 2008/09/17 02:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>ちゃんと計算してないけど、時間計算量はO(n logn)、空間計算量はO(1)ぐらい？\n再帰してるから空間計算量はO(logn)なのかな。</p>\n\n\t"
  :code: |
    class P
    {
      static void Main(string[] args)
      {
        for (int i = 1, c = 0; c &lt; 100; i++)
        {
          int[] f = F(i);
          if (f != null)
          {
            ++c;
            System.Console.WriteLine
              ("{0} = 2^{1} * 3^{2} * 5^{3}", i, f[2], f[3], f[5]);
          }
        }
      }

      static int[] F(int n)
      {
        if (n == 1) return new int[6];
        int[] a = { 2, 3, 5 };
        foreach (int d in a)
          if (n % d == 0)
          {
            int[] r = F(n / d);
            if (r == null) return null;
            ++r[d];
            return r;
          }
        return null;
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7650'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7650
  :user_name: emasaka
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/852/
  :language: Bash
  :time: 2008/09/17 03:54 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>アプローチとしては#7638と同じでしょうか。配列。</p>\n\n\t"
  :code: |
    n=1
    for ((i = 0; i &lt; 100; i++));do
        echo $n
        ary[$((n*2))]=1
        ary[$((n*3))]=1
        ary[$((n*5))]=1
        while [ "${ary[$((++n))]}" != 1 ];do :;done
    done
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7652'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7652
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2008/09/17 04:02 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ハミング数ですね。\r\nanarchy golf の Hamming Numbers問題\r\nhttp://golf.shinh.org/p.rb?Hamming+Numbers\r\nのときに投稿した
    golf用の富豪コードです。\r\n\r\n30のx乗 ≡ 0 (mod x) となる x がハミング数に\r\nなることを使っています。（30 は 2,3,5
    の最小公倍数）\r\n\r\n富豪だから、け、計算量なんて気にしてないんだからね！\r\n</pre>\n\t"
  :code: |
    main = do
      n &lt;- readLn
      mapM_ print $ take n [x| x &lt;- [1..], mod (30^x) x == 0]

    {- anarchy golf に投稿したコードはこちら

    main=readLn&gt;&gt;=mapM print.(`take`[x|x&lt;-[1..],mod(30^x)x&lt;1])

    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7653'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7653
  :user_name: turugina
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/760/
  :language: Vim
  :time: 2008/09/17 10:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">素因数分解していくバージョンで</pre>\n\t"
  :code: |
    :new
    :let s:n=1
    :let s:m=0
    :while s:m &lt; 100
    : if s:n != 1 &amp;&amp; s:n % 2 != 0 &amp;&amp; s:n % 3 != 0 &amp;&amp; s:n % 5 != 0
    :   let s:n = s:n + 1
    :   continue
    : endif
    : let s:_ = s:n
    : let s:i = 0
    : let s:j = 0
    : let s:k = 0
    : while s:_ % 2 == 0
    :   let s:_ = s:_ / 2
    :   let s:i = s:i + 1
    : endwhile
    : while s:_ % 3 == 0
    :   let s:_ = s:_ / 3
    :   let s:j = s:j + 1
    : endwhile
    : while s:_ % 5 == 0
    :   let s:_ = s:_ / 5
    :   let s:k = s:k + 1
    : endwhile
    : if s:_ == 1
    :   call append(s:m, printf("%d = 2^%d * 3^%d * 5^%d", s:n, s:i, s:j, s:k))
    :   let s:m = s:m + 1
    : endif
    : let s:n = s:n + 1
    :endwhile
    :unlet! s:n
    :unlet! s:m
    :unlet! s:i
    :unlet! s:j
    :unlet! s:k
    :unlet! s:_
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7656'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7656
  :user_name: emasaka
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/852/
  :language: Bash
  :time: 2008/09/17 08:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>配列の添字が冗長だったので微修正します。</p>\n\n\t"
  :code: |
    n=1
    for ((i = 0; i &lt; 100; i++));do
        echo $n
        ary[n*2]=1
        ary[n*3]=1
        ary[n*5]=1
        while [ "${ary[++n]}" != 1 ];do :;done
    done
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7657'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7657
  :user_name: lunlumo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/813/
  :language: Ruby
  :time: 2008/09/17 11:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>　#7652を参考に書いてみました。</p>\n</div>\n\t"
  :code: |
    class HummingNumbers
        def self.get(c)
            (30**c % c == 0) ? c : get(c+1)
        end
        def self.take(n,c=1)
            (n==0) ? [] : ((c = get(c)) &amp;&amp; take(n-1,c+1).unshift(c))
        end
    end

    puts HummingNumbers.take(ARGV.length == 1 ? ARGV[0].to_i : 100).join("\n")
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7658'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7658
  :user_name: lunlumo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/813/
  :language: Scala
  :time: 2008/09/17 11:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>　[1..100]&gt;&gt;=penさんの投稿を参考に書いてみました。</p>\n</div>\n\t"
  :code: |
    class CHummingNumbers {
        def next(c:Int):Int = (BigInt(30).pow(c) % c).intValue match {
                case 0 =&gt; c
                case _ =&gt; next(c+1)
            }
        def take(n:Int,c:Int):List[Int] = n match {
                case 0 =&gt; List()
                case _ =&gt; next(c) match { case v =&gt; v::take(n-1,v+1) }
            }
        def take(n:Int):List[Int] = take(n,1)
    }
    object HummingNumbers {
        def main(args:Array[String]):Unit = {
            try {
                val    n:Int = args.length match {
                    case 1 =&gt; args(0).toInt
                    case _ =&gt; 100
                }
                println((new CHummingNumbers).take(n).mkString("\n"))
            } catch {
                case e =&gt; e.printStackTrace
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7659'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7659
  :user_name: nobsun
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2008/09/17 20:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Haskellらしく素直に無限リストで  :)</p>\n\n\t"
  :code: |
    main :: IO ()
    main = print $ take 100 hamming

    hamming :: [Integer]
    hamming = 1 : foldr1 (#) (zipWith map (map (*) [2,3,5]) (repeat hamming))

    (#) :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
    xxs@(x:xs) # yys@(y:ys) | x &lt; y     = x : xs  # yys
                            | y &lt; x     = y : xxs # ys
                            | otherwise = x : xs  # ys
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7660'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7660
  :user_name: こう。
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/134/
  :language: C
  :time: 2008/09/17 20:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">よく考えたら2で割るのにループはいりませんね。\r\ni,j,kも省いてこんな感じかな。</pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n\nint main(){\n    int m,n,v;\n    \n    for(n=0,m=1;n&lt;100;m++){\n
    \       v=m/(m&amp;-m);\n        while(v%3==0)v/=3;\n        while(v%5==0)v/=5;\n
    \       if(v==1){\n            printf(\"%d\\n\",m);\n            n++;\n        }\n
    \   }\n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7661'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7661
  :user_name: nori
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/59/
  :language: 
  :time: 2008/09/17 20:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>25までのものが出てくるようにDNUMを指定したときに16が出てくるのでしょうか？</p>\n<p>(注：2 ^ 4 = 16,
    5 ^ 2 = 25)</p>\n<p>25までの数を表示するようにDNUMを指定すると、heapに入っている数はi + j + k &lt;= 3を満たすものしかない気がします。しかし、16も指定の数です。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7662'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7662
  :user_name: nori
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/59/
  :language: Python
  :time: 2008/09/17 20:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>dictでmemo化</p>\n<p>本来は配列でmemo化したほうがよいのだが、pythonでListのreserveを適切に行う方法がわからない。index
    errorをexceptするのもだるいし・・・。</p>\n<p>appendするならdictを使うほうがマシでしょう。</p>\n\n\t"
  :code: |
    class IsN235WithMemo(object):
      def __init__(self):
        self.memo = dict()
      def __call__(self, n):
        r = self.memo.get(n, None)
        if r is not None:
          return r
        if n == 1:
          return True
        d, m = divmod(n, 2)
        if d and m == 0:
          return is_n235(d)
        d, m = divmod(n, 3)
        if d and m == 0:
          return is_n235(d)
        d, m = divmod(n, 5)
        if d and m == 0:
          return is_n235(d)
        return False

    is_n235 = IsN235WithMemo()

    for i in range(10):
      print i, is_n235(i)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7663'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7663
  :user_name: nori
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/59/
  :language: 
  :time: 2008/09/17 20:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>元になったコードへのコメントを確認してください。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7664'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7664
  :user_name: kozima
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2008/09/17 22:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>DNUM=16 としてみました。25 まで正しく列挙されているように思いますが……\n<a class=\"reference\"
    href=\"/web/20091213151814/http://codepad.org/QQfKglM7\">http://codepad.org/QQfKglM7</a></p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7665'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7665
  :user_name: nori
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/59/
  :language: 
  :time: 2008/09/17 23:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>勘違いです。失礼しました。\n8が先にqueueから抜かれますね。orz</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7666'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7666
  :user_name: '186'
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/352/
  :language: 
  :time: 2008/09/17 23:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>8を取り出したときに, 16, 24, 40が入れられるので, 25の前に16出ますよ.</p>\n<p>あとこのアルゴリズムの正当性も証明できます.\nn
    (&gt; 1) 回目が終わったとき出てなかったものの最小値をAとします. このAがn回目に出た数より小さいと仮定します.\nA = 2^i 3^j 5^kで,
    queのことを考えると, A/2またはA/3またはA/5のどれかも出ていません. なので最小性に反します. よって矛盾.</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7667'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7667
  :user_name: leque
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/840/
  :language: Scheme
  :time: 2008/09/18 00:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>出題時に考えていた答。平衡木を使うので、求める数の個数を n としたとき、時間計算量は O(log n)、空間計算量は O(n)
    のはず。</p>\n\n\t"
  :code: |
    (define (main args)
      (let ((tm (alist-&gt;tree-map '((1 . #t)) = &lt;)))
        (let loop ((n (string-&gt;number (cadr args)))
                   (rs '()))
          (cond
           ((zero? n)
            (print (reverse rs))
            0)
           (else
            (let ((m (car (tree-map-pop-min! tm))))
              (for-each (cut tree-map-put! tm &lt;&gt; #t)
                        (map (cute * m &lt;&gt;) '(2 3 5)))
              (loop (- n 1) (cons m rs))))))))
  :tags:
  - gauche
  :references:
    :url: /web/20091213151814/http://practical-scheme.net/gauche/man/gauche-refj_52.html
    :title: 'Gauche ユーザリファレンス: 6.14 ツリーマップ'
- :id: '7668'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7668
  :user_name: tsuwabuki
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/479/
  :language: Ruby
  :time: 2008/09/18 00:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  無限リストのつもりです。\n\t"
  :code: |
    class Hamming &lt; Array
      def hamming(&amp;p)
        x = 1
        loop {
          p.call x if 30**x%x == 0
          x += 1
        }
      end
    end

    p Enumerable::Enumerator.new(Hamming.new, :hamming).take(100)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7669'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7669
  :user_name: nobsun
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2008/09/18 00:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">求める数の個数 n なのに 時間計算量 O(log n) というのがよく判らないんです。\r\n素人考えだと、最低
    O(n)はかかるような気がするんですけど、解説をお願いできますでしょうか\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7671'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7671
  :user_name: matarillo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/136/
  :language: Other
  :time: 2008/09/18 02:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>VBA for Excel (2003)</p>\n\n\t"
  :code: |
    Sub main()
      Dim r, s, t
      Range("B1").Value = "2^x"
      Range("C1").Value = "3^y"
      Range("D1").Value = "5^z"
      Range("B2:D2").Value = 0
      Set r = Range("A1")
      n = 1
      c = 0
      While c &lt; 100
        Set s = r.Offset(n)
        s.Value = n
        If Not IsEmpty(s.Offset(0, 1)) Then
          c = c + 1
          For i = 0 To 2
            Set t = r.Offset(n * ((i * (i + 1) / 2) + 2))
            For j = 0 To 2
              t.Offset(0, j + 1).Value = s.Offset(0, j + 1).Value + IIf(i = j, 1, 0)
            Next
          Next
        End If
        n = n + 1
      Wend
      Cells.AutoFilter Field:=1, Criteria1:="&lt;&gt;"
      Cells.AutoFilter Field:=2, Criteria1:="&lt;&gt;"
    End Sub
  :tags:
  - vba
  :references:
    :url: 
    :title: 
- :id: '7672'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7672
  :user_name: Dubhead
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/785/
  :language: 
  :time: 2008/09/18 04:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>確認しました。問題ないということでよろしいですね。</p>\n<p>#7642 にマイナス評価が付いてるけど、\nジェネレイタにしなかった罰だと思うことにしますw</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7673'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7673
  :user_name: kgbu
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/847/
  :language: Erlang
  :time: 2008/09/18 08:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>しらみつぶしに計算してからsortする方式ですが、その境界の目処はたてるようにしてみました。
    http://en.wikipedia.org/wiki/Image:Regular_divisibility_lattice.svg　の図を、3次元空間のある象限に存在する三角錐とみて、それを含む直方体の中の格子点を取り出します。最低でも、およそ5/6が無駄なデータなのですが、うまく三角錐の部分だけの格子点を巡回する順序を決めるアルゴリズムが思い浮かばなかったので、そのままにしてあります。\r</p>\n<p>\r</p>\n<p>$
    erlc スクリプトのファイル名\r</p>\n<p>$ erl -noshell -s len main 100 -s init stop \r</p>\n<p>\r</p>\n<p>として実行します。</p>\n</div>\n\t"
  :code: |
    -module(len).
    -export([main/1]).

    main([N|_]) -&gt;
            Limit = list_to_integer(atom_to_list(N)),
            Factor = math:pow(Limit * math:log(5) * math:log(2)/ (math:log(2) * math:log(3)), 1 / 3),
            L = lists:sort([round(math:pow(2, X)*math:pow(3,Y)*math:pow(5,Z)) ||
                     X &lt;- lists:seq(0,round(1 + Factor * math:log(5) / math:log(2)) ),
                     Y &lt;- lists:seq(0,round(1 + Factor * math:log(5) / math:log(3)) ),
                     Z &lt;- lists:seq(0,round(1 + Factor))]),
            io:format("~p~n",[lists:sublist(L,Limit)]).
  :tags: []
  :references:
    :url: /web/20091213151814/http://en.wikipedia.org/wiki/Hamming_numbers
    :title: ハミング数
- :id: '7674'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7674
  :user_name: nskj77
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/375/
  :language: Haskell
  :time: 2008/09/18 09:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">もりっとArrowで</pre>\n\t"
  :code: "module Main where\n\nimport Control.Arrow\n\nf = Left &gt;&gt;&gt; f' 2
    &gt;&gt;&gt; f' 3 &gt;&gt;&gt; f' 5 &gt;&gt;&gt; const False ||| const True                                                           \n
    \ where f' n = g n ||| Right\n\ng n = loop ((snd &amp;&amp;&amp; fst &gt;&gt;&gt;
    app) &amp;&amp;&amp; (snd &gt;&gt;&gt; g'))\n  where g' f m | n &gt; m = Right
    ()\n               | True  = case m `divMod` n of (x,0) -&gt; f x; _ -&gt; Left
    m\n\nmain = runKleisli func [1..]\n  where func = arr (filter f) &gt;&gt;&gt;
    arr (take 100) &gt;&gt;&gt; Kleisli (mapM_ print)\n"
  :tags:
  - Control.Arrow
  :references:
    :url: 
    :title: 
- :id: '7675'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7675
  :user_name: 匿名
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/4/
  :language: Haskell
  :time: 2008/09/18 10:18 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>有名なエラトステネスのふるいを変形して。Haskellはあんまりやったことがないから勝手が分かりませんが。</p>\n\n\t"
  :code: |
    sieve (x:xs) | divide235 x = x:sieve xs
                 | otherwise = sieve [a | a &lt;- xs, a `mod` x /= 0]
        where divide235 x = x `mod` 2 == 0 || x `mod` 3 == 0 || x `mod` 5 == 0

    take 100 $ [1..6] ++ sieve [7..]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7676'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7676
  :user_name: athos
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/755/
  :language: 
  :time: 2008/09/18 10:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>あー、またログインし忘れ…orz</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7678'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7678
  :user_name: syat
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/766/
  :language: 
  :time: 2008/09/18 20:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  （雑談です）\r<br>この v=m/(m&amp;-m) というのは私には逆立ちしても思いつきそうにないんですが、有名なテクニックなんですか？\r<br>いまだになぜ上手くいくのかよくわかってないけど、ビットを書き出してみると確かにそうなるぽいですが・・・教えてえらいひと\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7679'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7679
  :user_name: こう。
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/134/
  :language: 
  :time: 2008/09/19 03:57 GMT
  :vote_count: '5'
  :vote_score: '5'
  :body: "\n\t  m&amp;-mの部分は一応知られたコードのはずです。\r<br>下位ビットから見て最初に1になるビットを検出するというコードとして知ったと思います。(この数字の意味は今回はじめて気づきましたが^^;;)\r<br><br>-mって言うのはmと足したとき0になる数字ですので、2進表記した場合の下位ビットから見て最初に1が出て来る場所まではmと同じ、それ以上は反転となる数字です。\r<br>-m=~m+1でもありますね。\r<br>4ビットでの例：\r<br> 2=0010\r<br>-2=1110\r<br><br> 3=0011\r<br>-3=1101\r<br><br>ここでm&amp;-mをとれば、下から見て一番最初の1のみが残ることがわかります。\r<br>証明：\r<br>m=1*A+2*B+4*C+8*Dとすると\r<br>~m=1*~A+2*~B+4*~C+8*~D\r<br><br>-m=~m+1=1*A'+2*B'+4*C'+8*D'とすると\r<br>ビット加算はsum=a^b,Carry=a&amp;bなので\r<br>A'=~A^1  = A\r<br>B'=~B^(~A&amp;1) = ~B^~A =B^C\r<br>C'=~C^(~B&amp;(~A&amp;1)) =~C^(~B&amp;~A)=C^(B|A)\r<br>D'=~D^(~C&amp;(~B&amp;(~A&amp;1))) = ~D^(~C&amp;~B&amp;~A)=D^(C|B|A)\r<br><br>m&amp;-m=1*A''+2*B''+4*C''+8*D''\r<br><br>a&amp;(a^b)=a&amp;(a&amp;~b|~a&amp;b)=a&amp;~bより\r<br><br>A''=A&amp;A'=A\r<br>B''=B&amp;B'=B&amp;(B^A) = B&amp;~A\r<br>C''=C&amp;C'=C&amp;(C^(B|A)) = C&amp;~(B|A) = C&amp;~B&amp;~A\r<br>D''=D&amp;D'=D&amp;(D^(C|B|A))=D&amp;~(C|B|A)=D&amp;~C&amp;~B&amp;~A\r<br><br>下位ビットがすべて0のときのみビットがたつことがわかる。\r<br>～～証明ここまで\r<br><br>さて、2で割るということは2進数で考えれば、右シフトです。2で割った余りというのはm&amp;1となるわけなので、最下位ビットが0なら2の倍数です。\r<br>ここから考えれば最下位ビットから見て0の数だけ2で割れるわけです。\r<br><br>つまり先ほど求めたm&amp;-mというのは、設問で言う2^iとなっていることがわかると思います。\r<br><br>というのでどうでしょう？\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7681'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7681
  :user_name: syat
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/766/
  :language: 
  :time: 2008/09/19 07:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  解説ありがとうございます。何をやっているかがようやく理解できました。\r<br>（式変形はこれからじっくり解読しようと思います。。）\r<br>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7682'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7682
  :user_name: emasaka
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/852/
  :language: Emacs
  :time: 2008/09/19 09:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>#7671のExcelの解が面白かったので、GNU Emacsに移植してみました。ネタ実装です。</p>\n<p>できるだけプログラミング言語というよりエディターのマクロって感じの書きかたを目指しました。カラムの表現は面倒なのでS式にしちゃいましたが。</p>\n\n\t"
  :code: |
    (defun hamming (num)
      (interactive (list (read-minibuffer "Number: " "100")))
      (let ((n 1) (c 0))
        (switch-to-buffer "*Hamming*")
        (erase-buffer)
        (insert "(nil 0 0 0)")
        (beginning-of-buffer)
        (while (&lt; c num)
          (unless (eolp)
            (save-excursion
              (let ((s (read (current-buffer))))
                (setq c (1+ c))
                (backward-kill-sexp)
                (prin1 (cons n (cdr s)) (current-buffer))
                (mapc (lambda (i)
                        (hamming::goto-line-force (* n i))
                        (if (eolp)
                            (prin1 (cons nil
                                         (mapcar (lambda (j)
                                                   (+ (nth (/ (1+ j) 2) s)
                                                      (if (= i j) 1 0) ))
                                                 '(2 3 5) ))
                                   (current-buffer) )))
                      '(2 3 5) ))))
          (setq n (1+ n))
          (forward-line) ))
      (setq outline-regexp "([0-9]")
      (outline-mode)
      (hide-body) )

    (defun hamming::goto-line-force (n)
      (let ((r (goto-line n)))
        (unless (bolp) (insert ?\n))
        (while (&lt; 0 r)
          (insert ?\n)
          (setq r (1- r) ))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7685'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7685
  :user_name: pooq
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2008/09/19 20:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">1 2 3 5 のリストを掛け合わせ uniq して、を繰り返す。\r\n最後にソートして
    n 個とりだす。</pre>\n\t"
  :code: |
    wd"0(100){./:~~.,1 2 3 5*/^:10[1
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7686'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7686
  :user_name: 99yen
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/591/
  :language: 
  :time: 2008/09/19 21:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>#7639を参考に移植。for文がないのがきつい・・・</p>\n\n\t"
  :code: |
    limit=100
    n=0
    i=1
    (n&lt;limit)の間
        tmp=i
        (tmp%2=0)の間,tmp=tmp/2
        (tmp%3=0)の間,tmp=tmp/3
        (tmp%5=0)の間,tmp=tmp/5
        もし(tmp=1)ならば
            iを表示
            n=n+1
        i=i+1
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7691'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7691
  :user_name: syat
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/766/
  :language: SQL
  :time: 2008/09/21 01:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  SQLiteで。2,3,5の11乗まで計算し、その直積をとるだけ。\r<br>SQLiteで100行だけ取り出す方法がわからなかったので結果テーブルに一度格納してます。Oracleだとwhere rowno&lt;=100が使えたような\n\t"
  :code: |
    -- 数字テーブル
    create table d (
      n   integer,
      p2  integer,
      p3  integer,
      p5  integer
    );
    insert into d values (0,1,1,1);
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    insert into d select max(n)+1, max(p2)*2, max(p3)*3, max(p5)*5 from d;
    -- 結果テーブル
    create table result (
      id  integer primary key,
      i   integer,
      j   integer,
      k   integer,
      val integer
    );
    insert into result (i, j, k, val)
      select a.n, b.n, c.n, a.p2 * b.p3 * c.p5 val from d a, d b, d c order by val;
    select val,'2^'||i||' * 3^'||j||' * 5^'||k from result where id &lt;= 100;
  :tags:
  - SQLite
  :references:
    :url: 
    :title: 
- :id: '7692'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7692
  :user_name: silverwire
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/646/
  :language: SQL
  :time: 2008/09/20 23:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">バージョン 2.7.3の頃に使ったのでちょっと自信がありませんが、先頭から 100件という\r\nことであれば、\r\n\r\n
    \ e.g.\r\n    select ... from ... limit 100;\r\n\r\nのように limit句で、Oracleのrownumと同等のことを実現できたと思います。\r\n\r\n#
    先頭の位置(オフセット)はoffset句で調節します。</pre>\n\t"
  :code: ''
  :tags:
  - SQLite
  :references:
    :url: /web/20091213151814/http://www.sqlite.org/lang_select.html
    :title: SQL As Understood By SQLite
- :id: '7695'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7695
  :user_name: lunlumo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/813/
  :language: Scala
  :time: 2008/09/21 10:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>　Streamを使って書いてみました。</p>\n\n\t"
  :code: |
    object HammingNumbers {
        def from(n:Int):Stream[Int] = Stream.cons(n,from(n+1))
        def hammings(s:Stream[Int]):Stream[Int] = {
            def divide(n:Int,b:Int):Int = (n % b == 0) match {
                    case false =&gt; n
                    case _ =&gt; divide(n/b,b)
                }
            Stream.cons(s.head,hammings(s.tail.filter { n =&gt; List(2,3,5).foldLeft(n) { (v,b) =&gt; divide(v,b) } == 1 }))
        }
        def hammings():Stream[Int] = hammings(from(1))
        def main(args:Array[String]):Unit = {
            try {
                val    n:Int = args.length match {
                    case 1 =&gt; args(0).toInt
                    case _ =&gt; 100
                }
                println(hammings().take(n).mkString("\n"))
            } catch {
                case e =&gt; e.printStackTrace
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7696'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7696
  :user_name: lunlumo
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/813/
  :language: Scala
  :time: 2008/09/21 10:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>　#7638と#7671のやり方で。</p>\n\n\t"
  :code: |
    import    scala.collection.immutable.SortedSet
    import    scala.collection.immutable.TreeSet
    abstract class CHammingNumbers {
        def take(n:Int):List[Int]
    }
    class CHammingNumbersG extends CHammingNumbers {
        def next(s:List[Int],h:List[Int]):Tuple2[List[Int],List[Int]] = {
            val    m:List[Int] = s.zip(List(2,3,5)).map { v =&gt; h.apply(v._1)*v._2 }
            val    n:Int = m.sort { (a,b) =&gt; a &lt; b }.head
            (s.zip(m).map { v =&gt; (v._2 == n) match { case true =&gt; v._1 + 1; case _ =&gt; v._1 } },h+n)
        }
        def take(n:Int,s:List[Int],h:List[Int]):Tuple2[List[Int],List[Int]] = n match {
                case 0 =&gt; (s,h)
                case _ =&gt; next(s,h) match { case v =&gt; take(n-1,v._1,v._2) }
            }
        def take(n:Int):List[Int] = take(n-1,List(0,0,0),List(1))._2
    }
    class CHammingNumbersS extends CHammingNumbers {
        def next(c:SortedSet[Int]):Tuple2[Int,SortedSet[Int]] = (c.firstKey,(TreeSet(c.firstKey*2,c.firstKey*3,c.firstKey*5)++(c-c.firstKey)))
        def take(n:Int,c:SortedSet[Int]):List[Int] = n match {
                case 0 =&gt; List()
                case _ =&gt; next(c) match { case v =&gt; v._1::take(n-1,v._2) }
            }
        def take(n:Int):List[Int] = take(n,TreeSet(1))
    }
    object HammingNumbers {
        def main(args:Array[String]):Unit = {
            try {
                val    n:Int = args.length match {
                    case 1 =&gt; args(0).toInt
                    case _ =&gt; 100
                }
                List(new CHammingNumbersG,new CHammingNumbersS).foreach { h =&gt; println(h.take(n).mkString("\n")) }
            } catch {
                case e =&gt; e.printStackTrace
            }
        }
    }
  :tags: []
  :references:
    :url: /web/20091213151814/http://itpro.nikkeibp.co.jp/article/MAG/20080122/291623/
    :title: 「レッツ・チャレンジ！ パソコン甲子園」第11回の解答例
- :id: '7698'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7698
  :user_name: syat
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/766/
  :language: Other
  :time: 2008/09/23 04:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  グッドです。以下のように書いて結果テーブルは不要になりました。\r<br>バージョン 2.8.17 と 3.6.1 で動くことを確認してあります。\n\t"
  :code: |
    select (a.p2*b.p3*c.p5) val, a.n, b.n, c.n from d a, d b, d c order by val limit 100;
  :tags:
  - SQLite
  :references:
    :url: 
    :title: 
- :id: '7699'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7699
  :user_name: GEOJ
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/650/
  :language: sed
  :time: 2008/09/23 09:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">sedだと割り算のコストが高すぎるので、他のアルゴリズムでは難しそうです。\r\n乗算＋ソートのために内部は2進で計算しています。</pre>\n\t"
  :code: |
    #!/bin/sed
    s/.*/lol/
    : loop
        s/^\([^l]*\)l*o\([lo]*\)\(\n.*\)\?$/\1a\2\3\nx\2o\nx\2o+\2=\nx\2oo+\2=/
        : 2-&gt;10
            s/[f-j]/#&amp;/g
            s/[a-j][#l]/\U&amp;/g
            y/AbBcCdDeEfFgGhHiIjJ/bcdefghijabcdefghij/
            s/^#/b/m
            s/#//g
            s/\([a-j]\)[Lo]/\1/
        /[a-j][lo]/ b 2-&gt;10
        y/abcdefghij/0123456789/
        : add
            s/\([xo]l*\)l+\([lo]*\)l=/\U\1\E+\2=o/g
            s/X/xl/g
            y/LO/ol/
            s/l+\([lo]*\)o=/+\1=l/g
            s/o+\([lo]*\)\([lo]\)=/+\1=\2/g
            s/+=//g
        t add
        s/^x\([lo]*\)$/\U\1\Eo\1/gm
        y/LO/ll/
        : sort
            s/^\([lo]*\)\n\1$/\1/gm
            s/^\(\([lo]*\)l[lo]*\)\n\(\2o[lo]*\)$/\3\n\1/gm
        t sort
        s/^\(\(\w*\n\)\{99\}\w*\)\n.*$/\1/
    /[lo]/ b loop
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7700'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7700
  :user_name: kh
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/654/
  :language: D
  :time: 2008/09/24 08:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>因数分解する方針で。</p>\n\n\t"
  :code: "import std.stdio;\n\nstruct HammingNumbers {\n    static bool isHammingNumber(uint
    n) {\n        static bool[uint] memo;\n        \n        if(n == 1) return true;\n
    \       if(auto p = n in memo) return *p;\n        \n        if(n % 2 == 0)\n
    \           return memo[n] = isHammingNumber(n / 2);\n        if(n % 3 == 0)\n
    \           return memo[n] = isHammingNumber(n / 3);\n        if(n % 5 == 0)\n
    \           return memo[n] = isHammingNumber(n / 5);\n        return memo[n] =
    false;\n    }\n    \n    static int opApply(int delegate(ref const(size_t), ref
    const(uint)) dg) {\n        size_t i = 0;\n        uint n = 1;\n        while(true)
    {\n            if(isHammingNumber(n)) {\n                if(auto result = dg(i,
    n))\n                    return result;\n                i++;\n            }\n
    \           n++;\n        }\n    }\n}\n\nvoid main(){\n    foreach(i, n; HammingNumbers)
    {\n        if(i == 100) break;\n        writeln(i, \": \", n);\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7701'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7701
  :user_name: ocean
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2008/09/24 12:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>itertoolsを使って。</p>\n\n\t"
  :code: |
    import itertools

    def numbers():
        for n in itertools.count(1):
            t = n
            for i in (2, 3, 5):
                while t != 1 and t % i == 0:
                    t //= i
            if t == 1:
                yield n

    def main():
        for n in itertools.islice(numbers(), 100):
            print n

    if __name__ == '__main__':
        main()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7784'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7784
  :user_name: 匿名
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2008/10/11 20:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>2,3,5以外の素数の組合せ(3,7,11)にも対応。</p>\n\n\t"
  :code: |
    def hamming(n ,a = [1 ,2 ,3 ,5])
      r = []
      h = {}
      a.each{|x|h[x] = true}
      1.upto(n){
        r &lt;&lt; cnt = h.keys.sort[0]
        a.each{|x|h[x * cnt] = true}
        h.delete(cnt)
      }
      r
    end

    p "n = "
    p hamming(gets.chomp.to_i)
  :tags:
  - 1.8.6
  - Ruby
  :references:
    :url: 
    :title: 
- :id: '7866'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/7866
  :user_name: horiuchi
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/570/
  :language: Other
  :time: 2008/10/27 02:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Forth の実績追加のため、実装してみました。</p>\n\n\t"
  :code: |
    : DIV_CHECK ( n d -- n/d^m )
    BEGIN
      2DUP MOD 0=
    WHILE
      DUP -ROT / SWAP
    REPEAT
    DROP ;

    : HummingNumbers ( n -- )
    1
    BEGIN
      OVER 0&gt;
    WHILE
      DUP
      2 DIV_CHECK
      3 DIV_CHECK
      5 DIV_CHECK
      1 = IF
        DUP .
        SWAP 1- SWAP
      THEN
      1+
    REPEAT
    2DROP
    ;
  :tags:
  - Forth
  :references:
    :url: 
    :title: 
- :id: '8160'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/8160
  :user_name: taninsw
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/973/
  :language: Haskell
  :time: 2008/12/13 23:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>オーダーは考えていませんが。</p>\n\n\t"
  :code: |
    import List
    main = print $ take 100 $ sort $ [2^i*3^j*5^k|lm&lt;-[0..99],i&lt;-[0..lm],j&lt;-[0..lm-i],let k = lm-i-j]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8239'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/8239
  :user_name: 匿名
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/4/
  :language: OCaml
  :time: 2008/12/21 00:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>SICP Prloblem 3.56を参考にストリームで。\nただし、OCamlではvalue recursionは容易ではないので、ストリーム構築時に一部黒魔術(Objモジュール)を使っています。</p>\n<p>時間効率性はO(n)
    (のはず)</p>\n\n\t"
  :code: |
    type 'a t = Nil | Cons of 'a * 'a t lazy_t

    let (!) = Lazy.force

    let rec ( ** ) factor = function
        | Nil -&gt; Nil
        | Cons (a, b) -&gt; Cons (a * factor, lazy (factor ** !b))

    let rec ( ++ ) s1 s2 = match s1, s2 with
        | Nil,          _            -&gt; s2
        | _,            Nil          -&gt; s1
        | Cons(h1, t1), Cons(h2, t2) -&gt;
            if h1 &lt; h2 then Cons(h1, lazy (!t1 ++  s2)) else
            if h1 &gt; h2 then Cons(h2, lazy ( s1 ++ !t2)) else
                            Cons(h1, lazy (!t1 ++ !t2))

    let hamming =
        let s = Cons(1, lazy Nil) in
        let _ = Obj.set_field (Obj.repr s) 1
            (Obj.repr (lazy (2**s ++ 3**s ++ 5**s) )) in
        s

    let rec print n s = if n &gt; 0 then match s with
        | Nil -&gt; ()
        | Cons (a, b) -&gt; Printf.printf "%d\n" a; print (n-1) !b

    let _ = print 100 hamming
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8425'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/8425
  :user_name: 匿名
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2009/01/30 20:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>C++でO(n)のがなさげだったので．</p>\n\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;list&gt;

    int main(int,char**)
    {
      std::list&lt;int&gt; q;
      q.push_back(1);
      std::cout &lt;&lt; "1\n";

      std::list&lt;int&gt;::iterator i2,i3,i5;
      i2 = i3 = i5 = q.begin();

      for(int i=0;i&lt;100-1;++i)
      {
        int n = std::min(2**i2,std::min(3**i3,5**i5));
        q.push_back(n);
        if(2**i2==n)++i2;
        if(3**i3==n)++i3;
        if(5**i5==n)++i5;

        if(q.front()&lt;std::min(*i2,std::min(*i3,*i5)))
          q.pop_front();

        std::cout &lt;&lt; n &lt;&lt; std::endl;
      }
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8470'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/8470
  :user_name: genzou
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2009/02/07 11:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>素因数分解用の関数があればもっと楽になるかな</p>\n\n\t"
  :code: |
    def 素因数分解(num){
        def map = [:]
        for( int i = 2; i &lt;= num ;i++ ){
            if( num%i == 0 ){
                map[i] = (map[i]?:0) + 1
                num = (int)(num/i)
                i--
            }
        }
        map
    }

    def list = [:]
    def oklist = [2, 3, 5]
    for(def i = 1;list.size()&lt;100;i++){
        def map = 素因数分解(i)
        if(map.keySet() - oklist)
            continue
        list[i] = map
    }
    list.each{ key, value -&gt;
        println("${key}".padLeft(4) + " = " + oklist.collect{ "${it}^${value[it]?:0}" }.join(" * "))
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8740'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/8740
  :user_name: rennos
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/1024/
  :language: HSP
  :time: 2009/03/28 07:28 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  関数名に困ったので、こういう数の集合を「アンダロート数」と呼ぶことにします。\n\t"
  :code: "#module\n\n#define true  1\n#define false 0\n\n// 可能な限り割り続ける\n#defcfunc
    div_force int p1, int p2, var count, local val\n    val   = p1\n    count = 0\n
    \   \n    repeat\n        if ( (val \\ p2) == 0 ) {\n            val /= p2\n            count
    ++\n        } else {\n            break\n        }\n    loop\n    \n    return
    val\n    \n// アンダロート数の集合かどうか\n#defcfunc IsSetOfAndarote int p1, array condition,
    array result, local num, local count\n    num = p1\n    dim result, length(condition)\n
    \   foreach condition\n        num = div_force(num, condition(cnt), result(cnt))\n
    \   loop\n    return ( num == 1 )\n    \n#global\n\n#define MAX_COUNT 100\n\n*main\n
    \   dim condition, 3\n        condition = 2, 3, 5\n    dim result, 3\n    sdim
    buf, 32000\n    \n    buf = \"集合 { \"\n    foreach condition\n        if ( cnt
    != 0 ) { buf += \", \" }\n        buf += condition(cnt)\n    loop\n    buf +=
    \" } に対するアンダロート数を\"+ MAX_COUNT +\"個列挙します。\\n----------\\n\"\n    \n    count =
    0\n    repeat , 1\n        if ( IsSetOfAndarote(cnt, condition, result) ) {\n
    \           buf += strf(\"%5d = \", cnt)\n            foreach condition\n                buf
    += \"(\"+ condition(cnt) +\" ^\"+ strf(\"%2d\", result(cnt)) +\")\"\n            loop\n
    \           buf += \"\\n\"\n            count ++\n            if ( count == MAX_COUNT
    ) { break }\n        }\n        await 0\n    loop\n    \n    objmode 2\n    mesbox
    buf, ginfo(12), ginfo(13)\n    stop\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9170'
  :parent_id: '206'
  :url: http://ja.doukaku.org/comment/9170
  :user_name: pooq
  :user_url: /web/20091213151814/http://ja.doukaku.org/user/606/
  :language: BASIC
  :time: 2009/06/14 23:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">十進BASICで。\r\n</pre>\n\t"
  :code: |
    LET n = 100
    DO WHILE(n &gt; 0)
       LET i = i + 1
       LET t = i
       LET h = 2
       DO WHILE(h &lt; 6)
          DO WHILE(MOD(t,h) = 0)
             LET t = t / h
          LOOP
          LET h = h * 2 - 1
       LOOP
       IF t = 1 THEN
          PRINT i
          LET n = n - 1
       END IF
    LOOP
    END
  :tags:
  - 十進BASIC
  :references:
    :url: 
    :title: 
