---
:id: '276'
:title: ラングトンのアリの描画
:comments:
- :id: '9331'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9331
  :user_name: Songmu
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/763/
  :language: JavaScript
  :time: 2009/07/09 11:18 GMT
  :vote_count: '10'
  :vote_score: '8'
  :body: "\r\n\t  ラングトンのアリを描画してください。ラングトンのアリは、以下のような動きをする、セル・オートマトンです。(Wikipediaより引用)\r<br>- 黒いマスにアリがいた場合、90°右に方向転換し、そのマスの色を反転させ、1マス前進する。\r<br>- 白いマスにアリがいた場合、90°左に方向転換し、そのマスの色を反転させ、1マス前進する。\r<br>詳しくはWikipedia等で調べるか、参考ページに拙作のデモがありますのでご覧下さい。\r\n\t"
  :code: "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n&lt;html
    lang=\"ja\"&gt;\n&lt;head&gt;\n       &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;\n
    \      &lt;meta http-equiv=\"content-script-type\" content=\"text/javascript\"&gt;\n
    \      &lt;meta http-equiv=\"content-style-type\" content=\"text/css\"&gt;\n       &lt;title&gt;ラングトンの蟻&lt;/title&gt;\n&lt;style
    type=\"text/css\"&gt;\n#canvas{\n       border: 1px solid #999;\n       width:
    300px;\n       height: 300px;\n}\n#canvas div{\n       width: 3px;\n       height:
    3px;\n       float: left;\n}\n&lt;/style&gt;\n&lt;script&gt;\nvar earth = [];\nvar
    WORLD_SIZE = 100;\nvar lang_ant;\n\nfunction Ant(){}\nAnt.prototype = {\n    age
    : 0,\n    ageDisplay : undefined,\n    id : undefined,\n    speed: 200,\n    direction:
    [0,-1],//向き。x軸 y軸。最初は上に動く\n    position: [60,40],//初期位置\n    world: [],\n    start:
    function(){\n        var self = this;\n        this.id = setInterval(function(){self.move()},
    1000/this.speed);\n    },\n    move: function(){\n        this.ageDisplay.innerHTML
    = ++this.age;\n        this.moveNextCell();\n        var cell = this.getCellInfo();\n
    \       var color = cell.getAndToggleColor();\n        this.setNextDirection(color);\n
    \   },\n    moveNextCell: function(){\n        this.position[0] += this.direction[0];\n
    \       this.position[1] += this.direction[1];\n        if(this.position[0] &lt;
    0 || this.position[1] &lt; 0 ||\n           this.position[0] &gt;= WORLD_SIZE
    || this.position[1] &gt;= WORLD_SIZE){\n            clearInterval(this.id);\n
    \           this.die();\n        }\n    },\n    getCellInfo: function(){\n        var
    idx = this.position[0] + this.position[1] * WORLD_SIZE;\n        return this.world[idx];\n
    \   },\n    setNextDirection: function(bool){//colorがfalse(白)なら右へ、true(黒)なら左へ転回\n
    \       if(bool){//黒\n            var tmp = this.direction[0];\n            this.direction[0]
    = this.direction[1];\n            this.direction[1] = -tmp;\n        }\n        else{//白\n
    \           var tmp = this.direction[0];\n            this.direction[0] = -this.direction[1];\n
    \           this.direction[1] = tmp;\n        }\n    },\n    die: function(){\n
    \       alert('Langton\\'s ant is dead.');\n        throw true;\n    }\n};\n\nfunction
    Cell(elm){\n    this.elm = elm;\n}\nCell.prototype = {\n    elm: undefined,\n
    \   color: false, //colorは2値なのでbooleanで表す\n    colorList: ['#FFF','#000'],\n    getAndToggleColor:
    function(){\n        this.color = !this.color;\n        var i = this.color ? 1
    : 0;\n        this.elm.style.backgroundColor = this.colorList[i];\n        return
    !this.color;\n    }\n}\nwindow.onload = function(){\n    var canvas = document.getElementById('canvas');\n
    \   var div = '&lt;div&gt;&lt;/div&gt;';\n    var inner_canvas = \"\";\n    for(var
    i=0; i&lt; WORLD_SIZE*WORLD_SIZE; i++){\n        inner_canvas += div;\n    }\n
    \   canvas.innerHTML = inner_canvas;\n    \n    var cells = canvas.childNodes;\n
    \   for(var i=0; i&lt;cells.length; i++){//世界の誕生\n        earth[i] = new Cell(cells[i]);\n
    \   }\n    lang_ant = new Ant();//蟻の誕生\n    lang_ant.world = earth;//地球に降り立つ\n
    \   lang_ant.ageDisplay = document.getElementById('step');\n    \n    document.getElementById('run').disabled
    = false;\n}\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;&lt;input
    type=\"button\" value=\"run\" onclick=\"lang_ant.start();this.disabled=true;\"
    id=\"run\" disabled=\"disabled\"&gt;　&lt;span id=\"step\"&gt;&lt;/span&gt;\n　&lt;input
    type=\"button\" value=\"stop &amp;amp; refresh\" onclick=\"location.reload();\"&gt;&lt;/p&gt;\n&lt;div
    id=\"canvas\"&gt;&lt;/div&gt;\n"
  :tags: []
  :references:
    :url: /web/20100712030836/http://www.songmu.jp/riji/archives/2009/07/javascript_1.html
    :title: JavaScriptでラングトンの蟻
- :id: '9371'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9371
  :user_name: egtra
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/759/
  :language: C
  :time: 2009/07/15 09:29 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>C++でWTL使いました。GDIで描画、Windowsのタイマーメッセージ (WM_TIMER) を使って回数を進めるようにしています。高速に結果を見たかったので、1度のタイマイベントで複数回進めるようにしています。</p>\n<p>ありを進める部分はなんの工夫もないですが。</p>\n\n\t"
  :code: |
    #define WINVER 0x0400
    #define _WIN32_WINDOWS 0
    #define _WIN32_WINNT 0
    #define _WIN32_IE 0x0300 // IE3以上を指定しないとWTLがコンパイルエラーを起こす。

    #define WIN32_LEAN_AND_MEAN
    #define _ATL_NO_AUTOMATIC_NAMESPACE
    #define _WTL_NO_AUTOMATIC_NAMESPACE

    #include &lt;cassert&gt;
    #include &lt;sstream&gt;

    #include &lt;tchar.h&gt; // _tWinMain

    #include &lt;windows.h&gt;
    #include &lt;atlbase.h&gt; // ATL共通ヘッダ
    #include &lt;atlwin.h&gt; // CWindowImplほか
    #include &lt;atlcrack.h&gt; // MSG_*
    #include &lt;atlapp.h&gt; // &lt;atlmisc.h&gt;
    #include &lt;atlmisc.h&gt; // CPoint

    const int ID_TIMER = 1;

    enum Direction {Up, Right, Down, Left};

    class MainWindow :
        public ATL::CWindowImpl&lt;MainWindow, ATL::CWindow, ATL::CFrameWinTraits&gt;
    {
    public:
        MainWindow() : field(), x(100), y(100), direction(Up), step() {} // このxとyの値が初期位置

        // ウィンドウクラス名を登録
        DECLARE_WND_CLASS(TEXT("Langton's ant"));

        // メッセージマップ
        BEGIN_MSG_MAP(MainWindow)
            MSG_WM_TIMER(OnTimer)
            MSG_WM_PAINT(OnPaint)
            MSG_WM_CREATE(OnCreate)
            MSG_WM_DESTROY(OnDestroy)
        END_MSG_MAP()
    private:
        void OnTimer(UINT /*idEvent*/)
        {
            for (int i = 0; i &lt; 16; ++i) // 1度のタイマイベントで複数回進める。
            {
                NextStep();
                ++step;
            }
            std::basic_ostringstream&lt;TCHAR&gt; oss;
            oss &lt;&lt; TEXT("Langton's ant - step: ") &lt;&lt; step;
            SetWindowText(oss.str().c_str());
            Invalidate(FALSE);
        }

        static const int TILE_WIDTH = 2, TILE_HEIGHT = 2;
        static const int X = 200, Y = 200;

        void OnPaint(HDC)
        {
            WTL::CPaintDC dc(m_hWnd);
            for (int i = 0; i &lt; Y; ++i)
            {
                for (int j = 0; j &lt; X; ++j)
                {
                    dc.FillSolidRect(j * TILE_WIDTH, i * TILE_HEIGHT,
                        TILE_WIDTH, TILE_HEIGHT,
                        field[i][j] ? RGB(255, 255, 255)
                                    : RGB(0, 0, 0));
                }
            }
        }

        LRESULT OnCreate(CREATESTRUCT const* pcs)
        {
            RECT rc = {0, 0, TILE_WIDTH * X, TILE_HEIGHT * Y};
            AdjustWindowRectEx(&amp;rc, pcs-&gt;style, FALSE, pcs-&gt;dwExStyle);
            SetWindowPos(0, &amp;rc, SWP_NOMOVE | SWP_NOZORDER);
            SetTimer(ID_TIMER, 10, 0);
            return 0;
        }

        void OnDestroy()
        {
            PostQuitMessage(0);
        }

        void NextStep()
        {
            if (field[y][x]) // trueが白、falseが黒としている
            {
                if (direction == Up)
                {
                    direction = Left;
                }
                else
                {
                    --direction;
                }
            }
            else
            {
                if (direction == Left)
                {
                    direction = Up;
                }
                else
                {
                    ++direction;
                }
            }
            field[y][x] = !field[y][x];
            switch (direction)
            {
            case Up:
                y--;
                if (y == -1)
                {
                    y = Y - 1;
                }
                break;
            case Right:
                x++;
                if (x == X)
                {
                    x = 0;
                }
                break;
            case Down:
                y++;
                if (y == Y)
                {
                    y = 0;
                }
                break;
            case Left:
                x--;
                if (x == -1)
                {
                    x = X - 1;
                }
                break;
            default:
                assert(0);
            }
        }

        bool field[Y][X];
        int y;
        int x;
        int direction; //Direction（列挙）型では++と--できない（できるようにするのが面倒）。
        int step;
    };

    int WINAPI _tWinMain(HINSTANCE, HINSTANCE, LPTSTR, int cmdShow)
    {
        MainWindow wnd;
        wnd.Create(NULL, ATL::CWindow::rcDefault, TEXT("Langton's ant"),
            WS_CAPTION | WS_SYSMENU | WS_DLGFRAME | WS_MINIMIZEBOX
            | WS_OVERLAPPED | WS_SYSMENU, WS_EX_APPWINDOW);
        wnd.ShowWindow(cmdShow);
        wnd.UpdateWindow();

        WTL::CMessageLoop msgLoop;
        return msgLoop.Run();
    }
  :tags:
  - WTL
  :references:
    :url: 
    :title: 
- :id: '9372'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9372
  :user_name: syat
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/766/
  :language: C
  :time: 2009/07/15 14:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>C#でビットマップにごりごり描画します。\nフレームスキップして速度を稼いでいます。</p>\n<p>今回一番はまったのは、Color.FromArgb(255,
    0, 0, 0) が Color.Black とイコールではないってこと。ColorはARGB以外の情報を持っているので、ToArgb()で比較するように、とMSDNにある。</p>\n\n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    using System.Drawing;
    using System.Windows.Forms;

    namespace LangtonsAnt {
        class Ant {
            Point pos;
            int direction;
            public int X { get { return pos.X; } }
            public int Y { get { return pos.Y; } }

            public Ant(int x, int y) {
                pos.X = x;
                pos.Y = y;
                direction = 0;
            }
            public void Advance(bool IsBlack) {
                if (IsBlack) {
                    direction = (direction + 1) % 4;
                } else {
                    direction = (direction + 3) % 4;
                }
                switch (direction) {
                    case 0: pos.Y--; break; //北
                    case 1: pos.X++; break; //東
                    case 2: pos.Y++; break; //南
                    case 3: pos.X--; break; //西
                }
            }
        }
        class Form1 : Form {
            Bitmap bitmap;                  //世界＝ビットマップ
            List&lt;Ant&gt; ants;                 //アリたち
            Timer timer;                    //タイマー
            long step_count;                //ステップ数
            Color Black = Color.FromArgb(255, 0, 0, 0);
            Color White = Color.FromArgb(255, 255, 255, 255);
            public Form1() {
                //マップの初期化
                this.Width = 300; this.Height = 200;
                bitmap = new Bitmap(300, 200, Graphics.FromHwnd(this.Handle));
                //100,100を中心に黒点を打つ
                Random r = new Random();
                for (int i = 0 ; i &lt; 100 ; i++) {
                    int x = r.Next(40) + bitmap.Width / 2 - 20;
                    int y = r.Next(40) + bitmap.Height / 2 - 20;
                    bitmap.SetPixel(x, y, Black);
                }
                //アリの初期化
                ants = new List&lt;Ant&gt;();
                ants.Add(new Ant(r.Next(20) + bitmap.Width / 2 - 10, r.Next(20) + bitmap.Height / 2 - 10));
                ants.Add(new Ant(r.Next(20) + bitmap.Width / 2 - 10, r.Next(20) + bitmap.Height / 2 - 10));
                ants.Add(new Ant(r.Next(20) + bitmap.Width / 2 - 10, r.Next(20) + bitmap.Height / 2 - 10));
                //タイマー初期化
                step_count = 0;
                timer = new Timer();
                timer.Interval = 300;       //300msに１度再描画
                timer.Tick += new EventHandler(timer_Tick);
                timer.Start();
            }
            void timer_Tick(object sender, EventArgs e) {
                //高速化のため１描画につき150周回す
                for (int step = 0 ; step &lt; 150 ; step++) {
                    foreach (Ant ant in ants) {
                        int x = (ant.X + bitmap.Width) % bitmap.Width;
                        if (x &lt; 0) x += bitmap.Width;
                        int y = (ant.Y + bitmap.Height) % bitmap.Height;
                        if (y &lt; 0) y += bitmap.Height;
                        Color color = bitmap.GetPixel(x, y);
                        if (color == Black) {
                            ant.Advance(true);
                            bitmap.SetPixel(x, y, White);
                        } else {
                            ant.Advance(false);
                            bitmap.SetPixel(x, y, Black);
                        }
                    }
                }
                Refresh();
                step_count += 150;
                Text = step_count.ToString();
            }
            protected override void OnPaint(PaintEventArgs e) {
                base.OnPaint(e);
                e.Graphics.DrawImage(bitmap, ClientRectangle);
            }
            protected override void OnClosed(EventArgs e) {
                timer.Stop(); timer = null;
                base.OnClosed(e);
            }
        }
        static class Program {
            [STAThread]
            static void Main() {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                Application.Run(new Form1());
            }
        }
    }
  :tags: []
  :references:
    :url: /web/20100712030836/http://msdn.microsoft.com/ja-jp/library/system.drawing.color.op_equality.aspx
    :title: Color.Equality 演算子
- :id: '9373'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9373
  :user_name: ivoryworks
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/647/
  :language: PHP
  :time: 2009/07/15 16:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ブラウザ向けに結果を出力します。\r\n\r\nパラメータはフィールドの「幅」と「高さ」で、以下のように使用します。\r\n（アリはフィールドの中心に落ちます）\r\n\r\nlang_ant(300,
    300);\r\n</pre>\n\t"
  :code: |
    &lt;?php
    function lang_ant($w, $h)
    {
        $world = array_fill(0, $h, array_fill(0, $w, 1));
        $x = (int)($w/2);
        $y = (int)($h/2);
        $dct = 0; /* 0:N 1:E 2:S 3:W */
        $stp_ant = array('$x++;', '$y++;', '$x--;', '$y--;');
        $chg_dct = array('$dct = (((++$dct)%4)+2)%4;', '$dct = (++$dct)%4;');
        $print_world = array('0', '&amp;nbsp;');

        for ( $i = 0; $i &lt; 20000; $i++) {
            eval($chg_dct[$world[$y][$x]]);
            eval($stp_ant[$dct]);
            if ($x&lt;0 || $w&lt;=$x || $y&lt;0 || $h&lt;=$y) {
                break;
            }
            $world[$y][$x] = (++$world[$y][$x])%2;
        }
        foreach ( $world as $cels) {
            foreach ($cels as $cel) {
                echo $print_world[$cel];
            }
            echo "&lt;br /&gt;";
        }
    }
    ?&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9374'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9374
  :user_name: sumim
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2009/07/15 21:59 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <p>Squeak Smalltalk で。</p>\n\n\t"
  :code: |
    Display fillWhite; restoreAfter: [
        | pen black white |
        pen := Pen new.
        black := pen color: Color black; color.
        white := Color white.
        [Sensor leftShiftDown] whileFalse: [
            (Display colorAt: pen location) caseOf: {
                [black] -&gt; [pen color: white; turn: -90].
                [white] -&gt; [pen color: black; turn: 90]} otherwise: [].
            pen down; go: 0; up; go: 1.
            pen instVarNamed: #direction put: pen direction \\ 360]
    ]
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '9376'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9376
  :user_name: horiuchi
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/570/
  :language: Java
  :time: 2009/07/16 03:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>JPanelに直接描画してみました。\n今時のJVMだと結構早い描画ができると思います。</p>\n\n\t"
  :code: "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic
    class Sample276 extends JFrame {\n    private final LangtonsAntPanel mainPanel_;\n
    \   private final JButton startButton_ = new JButton(new AbstractAction(\"start\")
    {\n        public void actionPerformed(ActionEvent e) {\n            timer_.start();\n
    \           changeMode(true);\n        }\n    });\n    private final JButton stopButton_
    = new JButton(new AbstractAction(\"stop\") {\n        public void actionPerformed(ActionEvent
    e) {\n            timer_.stop();\n            changeMode(false);\n        }\n
    \   });\n    private final JButton resetButton_ = new JButton(new AbstractAction(\"reset\")
    {\n        public void actionPerformed(ActionEvent e) {\n            timer_.stop();\n
    \           changeMode(false);\n\n            mainPanel_.reset();\n            mainPanel_.repaint();\n
    \       }\n    });\n    private final JButton endButton_ = new JButton(new AbstractAction(\"end\")
    {\n        public void actionPerformed(ActionEvent e) {\n            Sample276.this.dispose();\n
    \       }\n    });\n\n    private final Timer timer_;\n\n    public Sample276(int
    size) {\n        super(\"Langton's ant.\");\n        this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n\n
    \       mainPanel_ = new LangtonsAntPanel(size);\n\n        JPanel panel = new
    JPanel(new BorderLayout(3, 3));\n        panel.add(mainPanel_, BorderLayout.CENTER);\n
    \       panel.add(createButtonPanel(), BorderLayout.SOUTH);\n        this.add(panel);\n
    \       this.pack();\n\n        timer_ = new Timer(5, new ActionListener() {\n
    \           public void actionPerformed(ActionEvent e) {\n                boolean
    res = mainPanel_.tick();\n                mainPanel_.repaint();\n                if
    (!res) {\n                    timer_.stop();\n                    changeMode(false);\n
    \                   JOptionPane.showMessageDialog(Sample276.this, \"Langton's
    ant is dead.\");\n                }\n            }\n        });\n    }\n\n    private
    JComponent createButtonPanel() {\n        JPanel panel = new JPanel(new FlowLayout(FlowLayout.RIGHT,
    3, 3));\n        panel.add(startButton_);\n        panel.add(stopButton_);\n        panel.add(resetButton_);\n
    \       panel.add(endButton_);\n        return panel;\n    }\n\n    private void
    changeMode(boolean isMoving) {\n        startButton_.setEnabled(!isMoving);\n
    \       stopButton_.setEnabled(isMoving);\n    }\n\n\n    public static void main(String[]
    args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public
    void run() {\n                try{\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n
    \               } catch(Exception e) {\n                    throw new InternalError(e.toString());\n
    \               }\n                Sample276 frame = new Sample276(100);\n                frame.setVisible(true);\n
    \           };\n        });\n    }\n}\n\nclass LangtonsAntPanel extends JPanel
    {\n    public enum Direction {\n        N(0, -1),\n        E(1, 0),\n        S(0,
    1),\n        W(-1, 0);\n\n        public final int dx;\n        public final int
    dy;\n        private Direction(int x, int y) {\n            dx = x;\n            dy
    = y;\n        }\n\n        public Direction turn(boolean isRight) {\n            int
    dd = this.ordinal() + (isRight? 1: 3);\n            return Direction.values()[dd
    % 4];\n        }\n    }\n\n    public class Ant {\n        private int x_;\n        private
    int y_;\n        private Direction d_ = Direction.N;\n        private int counter_
    = 0;\n\n        public Ant(int x, int y) {\n            x_ = x;\n            y_
    = y;\n        }\n\n        public int getX() {\n            return x_;\n        }\n
    \       public int getY() {\n            return y_;\n        }\n\n        public
    int getCounter() {\n            return counter_;\n        }\n\n        public
    void next(boolean isBlack) {\n            d_ = d_.turn(isBlack);\n            x_
    += d_.dx;\n            y_ += d_.dy;\n            counter_++;\n        }\n    }\n\n
    \   private static final int ANT_SIZE = 3;\n\n    private final int size_;\n    private
    final boolean[][] land_;\n    private Ant ant_;\n\n    public LangtonsAntPanel(int
    size) {\n        super(true);\n\n        size_ = size;\n        land_ = new boolean[size][];\n
    \       for (int index = 0; index &lt; land_.length; index++) {\n            land_[index]
    = new boolean[size];\n        }\n        ant_ = new Ant(size / 2, size / 2);\n\n
    \       setBackground(Color.WHITE);\n        setForeground(Color.BLACK);\n        setSize(size
    * ANT_SIZE, size * ANT_SIZE);\n        setPreferredSize(getSize());\n    }\n\n
    \   public boolean tick() {\n        int y = ant_.getY();\n        int x = ant_.getX();\n
    \       boolean b = land_[y][x];\n        land_[y][x] = !b;\n        ant_.next(b);\n
    \       \n        y = ant_.getY();\n        if (y &lt; 0 || size_ &lt;= y) {\n
    \           return false;\n        }\n        x = ant_.getX();\n        if (x
    &lt; 0 || size_ &lt;= x) {\n            return false;\n        }\n        return
    true;\n    }\n\n    public void reset() {\n        for (int y = 0; y &lt; land_.length;
    y++) {\n            for (int x = 0; x &lt; land_[y].length; x++) {\n                land_[y][x]
    = false;\n            }\n        }\n        ant_ = new Ant(size_ / 2, size_ /
    2);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n
    \       Graphics2D g2d = (Graphics2D) g;\n        g2d.setBackground(Color.WHITE);\n
    \       g2d.setColor(Color.BLACK);\n\n        g2d.clearRect(0, 0, this.getWidth(),
    this.getHeight());\n        for (int y = 0; y &lt; land_.length; y++) {\n            for
    (int x = 0; x &lt; land_[y].length; x++) {\n                if (land_[y][x]) {\n
    \                   g2d.fillRoundRect(x * ANT_SIZE, y * ANT_SIZE, ANT_SIZE, ANT_SIZE,
    1, 1);\n                }\n            }\n        }\n        g2d.drawString(String.format(\"turn:
    %d\", ant_.getCounter()), 2, 12);\n    }\n}\n"
  :tags:
  - Java1.5
  :references:
    :url: 
    :title: 
- :id: '9377'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9377
  :user_name: creeper
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/994/
  :language: C
  :time: 2009/07/16 03:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>アリ1匹につき1スレッドで。</p>\n\n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Threading;

    namespace doukaku276
    {
        class Program
        {
            const int ANT_NUM = 10;
            const int FIELD_WIDTH = 100;
            const int FIELD_HEIGHT = 100;
            static Random rnd = new Random();

            static void Main(string[] args)
            {
                new FormMain().ShowDialog();
            }

            class Ant
            {
                int x, y;
                int direction;//0:↑ 1:→ 2:↓ 3:←
                Color color;
                public Ant()
                {
                    x = rnd.Next(FIELD_WIDTH);
                    y = rnd.Next(FIELD_HEIGHT);
                    direction = rnd.Next(4);
                    color = Color.FromArgb(rnd.Next(254), rnd.Next(255), rnd.Next(255));
                }
                public void step(Bitmap bmp)
                {
                    bool b = bmp.GetPixel(x, y).R != 255; // 黒？ R=255を白とする
                    direction = (direction + (b ? 1 : 3)) % 4; // 回転
                    bmp.SetPixel(x, y, b ? Color.White : color); // 色反転
                    // 前進
                    switch (direction)
                    {
                    case 0: y--; break;
                    case 1: x++; break;
                    case 2: y++; break;
                    case 3: x--; break;
                    }
                    if (x &lt; 0) x += FIELD_WIDTH;
                    if (x &gt;= FIELD_WIDTH) x -= FIELD_WIDTH;
                    if (y &lt; 0) y += FIELD_HEIGHT;
                    if (y &gt;= FIELD_HEIGHT) y -= FIELD_HEIGHT;
                }
            }
            class FormMain : Form
            {
                Bitmap bmp = new Bitmap(FIELD_WIDTH, FIELD_HEIGHT);
                List&lt;Thread&gt; ants = new List&lt;Thread&gt;();
                public FormMain()
                {
                    lock (bmp)
                    {
                        for (int y = 0; y &lt; FIELD_HEIGHT; y++)
                            for (int x = 0; x &lt; FIELD_WIDTH; x++)
                                bmp.SetPixel(x, y, Color.White);
                    }
                    this.Size = new Size(FIELD_WIDTH * 3 + 100, FIELD_HEIGHT * 3 + 100);
                    this.CenterToScreen();
                    this.DoubleBuffered = true;
                }
                void update()
                {
                    Ant ant = new Ant();
                    while (true)
                    {
                        lock (bmp)
                        {
                            ant.step(bmp);
                        }
                        this.Invalidate();
                        Thread.Sleep(1);
                    }
                }
                protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
                {
                    foreach(var t in ants) t.Abort();
                }
                protected override void OnPaint(PaintEventArgs e)
                {
                    //base.OnPaint(e);
                    Graphics g = e.Graphics;
                    g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;
                    lock (bmp)
                    {
                        g.DrawImage(bmp, 30, 30, FIELD_WIDTH * 3, FIELD_HEIGHT * 3);
                    }
                    g.DrawString(string.Format("ants:{0}", ants.Count), this.Font, Brushes.Black, 40, FIELD_HEIGHT * 3);
                }
                protected override void OnClick(EventArgs e)
                {
                    var thread = new Thread(new ThreadStart(update));
                    thread.Start();
                    ants.Add(thread);
                }
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9378'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9378
  :user_name: turugina
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/760/
  :language: Perl
  :time: 2009/07/16 03:15 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Perl/Tk でごりごり書いてみました。\n\t"
  :code: "use strict;\nuse warnings;\n\nuse Tk;\nuse Tk::MsgBox;\nuse utf8;\n\nmy
    $w = shift || 100;\nmy $h = shift || $w;\n\nmy $pxsize  = 4;\nmy $init_pattern_subs
    = create_pattern_subs();\nmy $pattern = shift;\nmy $pattarn_sub = $pattern &amp;&amp;
    exists $init_pattern_subs-&gt;{$pattern}\n? $init_pattern_subs-&gt;{$pattern}
    \n: sub { 0 };\n\nmy $mw = Tk::MainWindow-&gt;new(-title =&gt; 'ラングトンの蟻');\nmy
    $control_frame = $mw-&gt;Frame;\n$control_frame-&gt;pack(\n  -side =&gt; 'bottom',\n
    \ -anchor =&gt; 's',\n  -fill =&gt; 'x',\n);\nmy $drawing_frame = $mw-&gt;Frame;\n$drawing_frame-&gt;pack(\n
    \ -side =&gt; 'top',\n  -anchor =&gt; 'n',\n  -fill =&gt; 'both',\n);\nmy $canvas
    = $drawing_frame-&gt;Canvas(\n  -width =&gt; $w * $pxsize, -height =&gt; $h *
    $pxsize,\n  -background =&gt; 'white',\n);\nmy @field;\nfor my $x ( 0 .. $w-1
    ) {\n  for my $y ( 0 .. $h-1 ) {\n    $field[$x][$y] = $canvas-&gt;createRectangle(\n
    \     (map{$_ * $pxsize} $x,$y,$x+1,$y+1),\n      -fill =&gt; 'white'\n    );\n
    \ }\n}\n\n$canvas-&gt;pack(-fill =&gt; 'both');\nmy $start_button = $control_frame-&gt;Button(\n
    \ -text =&gt; 'START',\n  -command =&gt; \\&amp;start_proc,\n  -state =&gt; 'normal',\n);\n$start_button-&gt;pack(-anchor
    =&gt; 'w', -side =&gt; 'left');\nmy $stop_button = $control_frame-&gt;Button(\n
    \ -text =&gt; 'STOP',\n  -command =&gt; \\&amp;stop_proc,\n  -state =&gt; 'disabled',\n);\n$stop_button-&gt;pack(-anchor
    =&gt; 'w', -side =&gt; 'left', -padx =&gt; 20);\nmy $stat = step_label(0,0,0);\nmy
    $stat_label = $control_frame-&gt;Label(\n  -textvariable =&gt; \\$stat\n);\n$stat_label-&gt;pack(-anchor
    =&gt; 'w', -side =&gt; 'left', -padx =&gt; 30);\n\nTk-&gt;MainLoop;\n\nsub create_pattern_subs\n{\n
    \ +{\n    ichimatsu =&gt; sub { (($_[0]/2) ^ ($_[1]/2)) &amp; 0x1; },\n    lines
    =&gt; sub { ($_[0]/12) &amp; ($_[1]/2) &amp; 0x1; },\n    random =&gt; sub { !int
    rand 3 },\n  };\n}\n\nsub step_label\n{\n  sprintf '%#8d steps (%#3d, %#3d)',
    @_;\n}\n\n{\n  my ($count,$x,$y,$d,$timer);\n\n  sub start_proc\n  {\n    $stop_button-&gt;configure(-state
    =&gt; 'normal');\n    $start_button-&gt;configure(-state =&gt; 'disabled');\n\n
    \   $count = 0;\n    $x = int(rand($w/2) + $w/4);\n    $y = int(rand($h/2) + $h/4);\n
    \   $d = int(rand(4));\n    for my $x_ ( 0 .. $w-1 ) {\n      for my $y_ ( 0 ..
    $h-1 ) {\n        $canvas-&gt;itemconfigure($field[$x_][$y_],\n          -fill
    =&gt; $pattarn_sub-&gt;($x_,$y_) ? 'black' : 'white');\n      }\n    }\n\n    $timer
    = $mw-&gt;repeat(10, \\&amp;next_step);\n  }\n\n  sub stop_proc\n  {\n    $stop_button-&gt;configure(-state
    =&gt; 'disabled');\n    $start_button-&gt;configure(-state =&gt; 'normal');\n\n
    \   $mw-&gt;afterCancel($timer);\n  }\n\n  sub next_step\n  {\n    my $bit = $canvas-&gt;itemcget($field[$x][$y],
    '-fill') ne 'white';\n    $canvas-&gt;itemconfigure($field[$x][$y], -fill =&gt;
    ($bit ? 'white' : 'black'));\n\n    $d = ($bit ? ++$d : --$d) % 4;\n    if    (
    $d == 0 ) { --$x; }\n    elsif ( $d == 1 ) { ++$y; }\n    elsif ( $d == 2 ) {
    ++$x; }\n    elsif ( $d == 3 ) { --$y; }\n\n    if ( $x &lt; 0 || $x &gt;= $w
    || $y &lt; 0 || $y &gt;= $h ) {\n      stop_proc;\n      my $d = $mw-&gt;MsgBox(-title
    =&gt; 'END', -message =&gt; 'しゅーりょー', -type =&gt; 'ok');\n      $d-&gt;Show;\n
    \     return;\n    }\n\n    $stat = step_label( ++$count, $x, $y);\n  }\n\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9379'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9379
  :user_name: Songmu
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/763/
  :language: 
  :time: 2009/07/16 03:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>おお。Perl/Tkをあまり使ったことがなかったので、Perlでの投稿を期待して待ってました。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9380'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9380
  :user_name: xsd
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/154/
  :language: ActionScript
  :time: 2009/07/16 12:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ActionScriptで作成してみました。\n30Frame/secでは遅かったので、1Frameに10Step進ませています。</p>\n<p>ブラウザ上で確認できるようにwonderflにもおいておきます。</p>\n<p><a
    class=\"reference\" href=\"/web/20100712030836/http://wonderfl.net/code/519de9f580e291a6309e2e8df3d5e8319a647433\">http://wonderfl.net/code/519de9f580e291a6309e2e8df3d5e8319a647433</a></p>\n\n\t"
  :code: "package {\n    // Yet another implimentation of Langton's ant\n    // This
    is made for \"どう書く？org\", http://ja.doukaku.org/276/\n    // This code is written
    by xsd.\n    import flash.display.Sprite;\n    import flash.display.BitmapData;\n
    \   import flash.display.Bitmap;\n    import flash.geom.Rectangle;\n    import
    flash.events.Event;\n    import flash.text.TextField;\n    import flash.text.TextFormat;\n\n
    \   [SWF(width=\"465\", height=\"465\", backgroundColor=\"0xFFFFFF\", frameRate=\"30\")]\n
    \   public class LangtonsAnt extends Sprite {\n    private const SCREEN_WIDTH:int
    = 465;\n    private const SCREEN_HEIGHT:int = 465;\n    private const CELL_SIZE:int
    = 4;\n    private const STEP:int = 10;\n\n    private var bm:BitmapData;\n    private
    var bmp:Bitmap;\n    private var tf:TextField;\n    private var xAnt:int = 200;\n
    \   private var yAnt:int = 200;\n    private var vx:int = 1;\n    private var
    vy:int = 0;\n    private var count:int = 0;\n        \n    public function LangtonsAnt():void
    {\n            bm = new BitmapData(SCREEN_WIDTH, SCREEN_HEIGHT, false, 0xFFFFFF);\n
    \           bmp = new Bitmap(bm);\n            this.addChild(bmp);\n\n            tf
    = new TextField();\n            tf.defaultTextFormat = new TextFormat(\"_Serif\",
    24, 0, true);\n            tf.x = 0; tf.y = SCREEN_HEIGHT - 32; tf.width = SCREEN_HEIGHT;
    tf.height = 32;\n            tf.selectable = false;\n            this.addChild(tf);\n
    \           this.addEventListener(Event.ENTER_FRAME, update);\n        }\n        \n
    \       public function update(event:Event):void {\n            bm.lock();\n            var
    t:int, i:int;\n    \n            for (i = 0; i &lt; STEP; i++) {\n                xAnt
    += vx * CELL_SIZE;\n                yAnt += vy * CELL_SIZE;\n                var
    a:int = bm.getPixel(xAnt, yAnt);\n                if (a == 0) {\n                    bm.fillRect(new
    Rectangle(xAnt, yAnt, CELL_SIZE, CELL_SIZE), 0xFFFFFF);\n                    t
    = vx; vx = vy; vy = -t;\n                } else {\n                    bm.fillRect(new
    Rectangle(xAnt, yAnt, CELL_SIZE, CELL_SIZE), 0x000000);\n            t = vy; vy
    = vx; vx = -t;\n                }\n                bm.unlock();\n                if
    (xAnt &lt;= CELL_SIZE || xAnt &gt;= SCREEN_WIDTH - CELL_SIZE ||\n                    yAnt
    &lt;= CELL_SIZE || yAnt &gt;= SCREEN_HEIGHT - CELL_SIZE) {\n                    this.removeEventListener(Event.ENTER_FRAME,
    update);\n                    break;\n                }\n                count++;\n
    \               tf.text = \"Step: \"+count;\n            }\n        }\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9381'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9381
  :user_name: konn
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/100/
  :language: Ruby
  :time: 2009/07/16 18:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Ruby でシンプルに書いてみました。</p>\n<p>入力された数字の分だけどんどん世代を進めます。qが入力されたら終わりです。</p>\n\n\t"
  :code: |
    #
    #  World.rb
    #  iLangAnt
    #
    #  Created by 石井 大海 on 09/07/17.
    #  Copyright (c) 2009 __MyCompanyName__. All rights reserved.
    #

    class Ant
      attr_reader :world, :x, :y, :generation

      def pos()
        return [x,y]
      end

      def initialize(world=World.new, pos_x=40, pos_y=60)
        @world = world
        @x = pos_x
        @y = pos_y
        @direction = [0, -1]
        @generation = 0
      end

      def position()
        @world.at(@x, @y)
      end

      def step()
        @x += @direction[0]
        @y += @direction[1]
        return nil unless position()
        position.toggle()
        if @world.black?(@x,@y)
          @direction = [-@direction[1], @direction[0]]
        else
          @direction = [@direction[1], -@direction[0]]
        end
        @generation += 1
      end

    end

    class World
      attr_reader :height, :width

      class &lt;&lt;self
        def define_block_delegate(mtd)
          define_method(mtd) {|x,y|
            at(x,y).__send__(mtd)
          }
        end
      end

      def initialize(height=100, width=100, wrap=true)
        @world = Array.new(height){ Array.new(width){ Block.new } }
        @height, @width = height, width
        @wrap = wrap
      end

      def at(x, y)
        unless (0...@height).include?(y) &amp;&amp; (0...@width).include?(x)
          if @wrap
            x, y = x % width, y % height
          else
            return nil
          end
        end
        @world[y][x]
      end

      define_block_delegate :white?
      define_block_delegate :black?
      define_block_delegate :color

      def inspect()
        @world.map{|r| r.map(&amp;:inspect).join("")}.join("\n")
      end

    end

    class Block
      attr_reader :state
      alias color state

      WHITE = true
      BLACK = false

      def initialize(state=WHITE)
        @state = state
      end

      def toggle
        @state = !@state
      end

      def set_white
        @state = WHITE
      end

      def set_black
        @state = BLACK
      end

      def black?
        @state
      end

      def white?
        !@state
      end

      def inspect()
        case @state
        when WHITE
          " □ "
        when BLACK
          " ■ "
        end
      end

    end

    if $0 == __FILE__
      w, h ,= ARGV
      w ||= h ||= 20
      wd = World.new(w, h)
      ant = Ant.new(wd, w*6/10, h*4/10)
      while (print"&gt; ";gets)
        break if $_ =~ /^q/i
        count = 1 unless (count = $_.to_i) &gt; 0
        count.times {
          ant.step
          p ant.generation
          p wd
        }
      end
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9382'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9382
  :user_name: silverwire
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/646/
  :language: JavaScript
  :time: 2009/07/17 13:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">自分のマシンは CPUが Pentium 4 (2.66GHz)、メモリが 512MBとリ\r\nソースが貧弱なためか、うまく動作してくれませんでした。\r\n\r\nなので、
    #9331を参考に table要素を利用したものへと書き直して\r\nみました。\r\n\r\n念のため、以下のブラウザーで動作を確認してあります。\r\n\r\n
    \ Firefox 2.0.0.6\r\n  Internet Explorer 6.0.29\r\n  Google Chrome 1.0.154.48\r\n
    \ Opera 9.23\r\n  Safari 3.1.2\r\n\r\nFirefox, Google Chrome, Safariは CPUをほとんど食わないのです\r\nが、
    Internet Explorerと Operaはともに CPU使用率が高く、動作\r\nも遅かったです。(実装の違いですかね? )</pre>\n\t"
  :code: "&lt;html&gt;\n&lt;head&gt;\n    &lt;style type=\"text/css\"&gt;\n        .C_0
    { background-color : #ffffff; height : 3px; width : 3px; }\n        .C_1 { background-color
    : #000000; height : 3px; width : 3px; }\n    &lt;/style&gt;\n    &lt;script type=\"text/javascript\"&gt;\n
    \       Function.prototype.repeat = \n        function (t, o) {\n            var
    _ = this;\n            return setInterval(function () { _.apply(o); }, t);\n        };\n\n
    \       var $ = function (i) { return document.getElementById(i); };\n\n        var
    USER_AGENT = navigator.userAgent.toLowerCase();\n        var CLASS_NAME = (USER_AGENT.indexOf('msie')
    &gt; -1) ? 'className' : 'class';\n\n        var Colony = \n        function (w,
    h) {\n            this.w = w;\n            this.h = h;\n            this.generate
    = \n            function () {\n                var i, j;\n\n                document.write('&lt;table
    border=\"0\" cellpadding=\"0\" cellspacing=\"0\"&gt;');\n                for (j
    = 0; j &lt; this.h; j++) {\n                    document.write('&lt;tr&gt;');\n
    \                   for (i = 0; i &lt; this.w; i++) document.write('&lt;td id=\"'
    + i + '_' + j + '\" class=\"C_0\"&gt;&lt;/td&gt;');\n                    document.write('&lt;/tr&gt;');\n
    \               }\n                document.write('&lt;/table&gt;');\n            };\n
    \       };\n\n        var Ant = \n        function (x, y, w, h) {\n            this.x
    \ = x;\n            this.y  = y;\n            this.dx = -1;\n            this.dy
    = 0;\n            this.w  = w;\n            this.h  = h;\n            this.id
    = 0;\n            this.move = \n            function () {\n                var
    C = $(this.x + '_' + this.y);\n                var c;\n                var t;\n\n
    \               if (this.x &lt; 0 || this.x &gt;= this.w || this.y &lt; 0 || this.y
    &gt;= this.h) {\n                    alert('DEAD END ...');\n                    clearTimeout(this.id);\n
    \                   return;\n                }\n\n                if (c = ((C.getAttribute(CLASS_NAME)).split('_')[1]
    ^ 1)) { // 反転\n                    t = this.dx;\n                    this.dx =
    this.dy;\n                    this.dy = -t;\n                } else {\n                    t
    = this.dx;\n                    this.dx = -this.dy;\n                    this.dy
    = t;\n                }\n\n                C.setAttribute(CLASS_NAME, 'C_' + c);\n\n
    \               this.x += this.dx;\n                this.y += this.dy;\n\n                if
    (!this.id) this.id = this.move.repeat(10, this);\n            };\n        };\n
    \   &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script type=\"text/javascript\"&gt;\n
    \       var W = 100, H = 100;\n        new Colony(W, H).generate();\n        new
    Ant(50, 50, W, H).move();\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9383'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9383
  :user_name: 匿名
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2009/07/17 13:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "def ant(world_size, x_pos = world_size / 2, y_pos = world_size / 2)\n  world
    = Array.new\n  generation = 0\n  direc = {}; direc[:x] = 0; direc[:y] = 1\n  world_size.times{world
    &lt;&lt;  [true] * world_size}\n  while true\n    system \"clear\"\n    p generation
    += 1\n    world[x_pos][y_pos] = !world[x_pos][y_pos]\n    world.each{|i|\n      i.each{|k|
    printf(\"%s \",k ? :□ : :■)}\n      p ''\n    }\n    sleep 0.1\n\n    if world[x_pos][y_pos]
    then\n      direc[:x], direc[:y] = direc[:y], -direc[:x]\n    else\n      direc[:x],
    direc[:y] = -direc[:y], direc[:x]\n    end\n    \n    x_pos = (x_pos + direc[:x])
    % world_size\n    y_pos = (y_pos + direc[:y]) % world_size\n    \n  end\nend\n\nworld_size
    = 20\nant(world_size)\n"
  :tags:
  - ruby1.9.0
  :references:
    :url: 
    :title: 
- :id: '9387'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9387
  :user_name: mattsan
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/833/
  :language: C
  :time: 2009/07/18 01:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>OpenGL/GLUTで。\r</p>\n<p>ウィンドウの表示と描画がコードの半分以上orz。\r</p>\n<p>作成はMac
    OS Xでしています。他の環境の場合には調整してください。\r</p>\n<p>\r</p>\n<p>コンパイルは、\r</p>\n<p>g++ -ansi
    -Wall -framework OpenGL -framework GLUT -framework Foundation -o doukaku276 doukaku276.cpp\r</p>\n<p>\r</p>\n<p>\r</p>\n<p>終了条件はないので、ESCキーかQキーで終了させてください。</p>\n</div>\n\t"
  :code: |
    #include &lt;bitset&gt;
    #include &lt;GLUT/glut.h&gt;

    class Field
    {
    public:
        virtual ~Field() {}

        virtual bool operator () (int x, int y) const = 0;
        virtual void set(int x, int y) = 0;
        virtual void unset(int x, int y) = 0;
    };

    template&lt;int Width, int Height&gt;
    class ConcreteField : public Field
    {
    public:
        ConcreteField() : bits_() {}

        bool operator () (int x, int y) const { return bits_[y * Width + x]; }
        void set(int x, int y) { bits_[y * Width + x] = true; }
        void unset(int x, int y) { bits_[y * Width + x] = false; }
    private:
        std::bitset&lt;Width * Height&gt; bits_;
    };

    class Direction
    {
    public:
        static const int North = 0;
        static const int East  = 1;
        static const int South = 2;
        static const int West  = 3;

        Direction(int dir) : dir_(dir) {}

        void set(int dir) { dir_ = dir; }
        int get() const { return dir_; }

        void turnRight()
        {
            dir_ += 1;
            dir_ %= 4;
        }

        void turnLeft()
        {
            dir_ += 3;
            dir_ %= 4;
        }

    private:
        int dir_;
    };

    class Ant
    {
    public:
        Ant(int x, int y, Direction direction) : x_(x), y_(y), direction_(direction) {}

        void move(Field&amp; field)
        {
            if(field(x_, y_))
            {
                field.unset(x_, y_);
                direction_.turnRight();
                moveForward();
            }
            else
            {
                field.set(x_, y_);
                direction_.turnLeft();
                moveForward();
            }
        }

        void moveForward()
        {
            switch(direction_.get())
            {
            case Direction::North: --y_; break;
            case Direction::East:  ++x_; break;
            case Direction::South: ++y_; break;
            case Direction::West:  --x_; break;
            default:                     break;
            }
        }

    private:
        int       x_;
        int       y_;
        Direction direction_;
    };

    static const int Interval = 0;
    static const int Width    = 320;
    static const int Height   = 240;

    static ConcreteField&lt;Width, Height&gt; field;
    static Ant                          ant(Width / 2, Height / 2, Direction::North);

    void display()
    {
        glClear(GL_COLOR_BUFFER_BIT);

        static const GLdouble black[] = { 0.0, 0.0, 0.0 };
        glColor3dv(black);

        glBegin(GL_POINTS);
        for(int y = 0; y &lt; Height; ++y)
        {
            for(int x = 0; x &lt; Width; ++x)
            {
                if(field(x, y))
                {
                    glVertex2f(x, y);
                }
            }
        }
        glEnd();

        glutSwapBuffers();
    }

    void resize(int w, int h)
    {
        glViewport(0, 0, w, h);
        glLoadIdentity();
        glOrtho(-0.5, w - 0.5, h - 0.5, -0.5, -1.0, 1.0);
    }

    void key(unsigned char key, int x, int y)
    {
        switch(key)
        {
        case 'q':
        case 'Q':
        case '\033':
            std::exit(0);
            break;

        default:
            break;
        }
    }

    void timer(int n)
    {
        ant.move(field);
        display();
        glutTimerFunc(Interval, timer, 0);
    }

    void initWindow(int argc, char* argv[])
    {
        glutInitWindowPosition(100, 100);
        glutInitWindowSize(Width, Height);
        glutInit(&amp;argc, argv);
        glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);

        glutCreateWindow("doukaku#276");

        glClearColor(1.0, 1.0, 1.0, 1.0);
    }

    void initEvent()
    {
        glutDisplayFunc(display);
        glutReshapeFunc(resize);
        glutKeyboardFunc(key);
        glutTimerFunc(Interval, timer, 0);
    }

    int main(int argc, char* argv[])
    {
        initWindow(argc, argv);
        initEvent();

        glutMainLoop();

        return 0;
    }
  :tags:
  - GLUT
  - OpenGL
  :references:
    :url: 
    :title: 
- :id: '9388'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9388
  :user_name: nattou_curry
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/913/
  :language: Other
  :time: 2009/07/18 03:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>Excel VBAにて、ごくシンプルに。\r</p>\n<p>\r</p>\n<p>Excelを以下のように調整すると、実行結果が見やすくなります。\r</p>\n<ul>\n<li>\n行の高さと列の幅を調整して、全てのセルを正方形にする。\r\n</li>\n<li>表示倍率を小さくして、なるべく多くのセルが画面内に収まるようにする\r</li>\n</ul>\n</div>\n\t"
  :code: "Option Explicit\n\n'// [定数] 蟻の方向\nConst DIR_UP = 0        '上向き\nConst DIR_RIGHT
    = 1     '右向き\nConst DIR_DOWN = 2      '下向き\nConst DIR_LEFT = 3      '左向き\n\n'//
    [定数] 色\nConst COLOR_WHITE = &amp;HFFFFFF    '白\nConst COLOR_BLACK = &amp;H0         '黒\n\n'//
    ラングトンの蟻\nSub Langtons_ant()\n    Dim r_Ant As Long       '// 蟻の位置(行番号)\n    Dim
    c_Ant As Long       '// 蟻の位置(行番号)\n    Dim dir_Ant As Integer  '// 蟻の方向\n    \n
    \   '////////////////////////////////////////////////////////////////////\n    '
    初期処理\n    '////////////////////////////////////////////////////////////////////\n
    \   \n    '// 蟻の位置を決める。\n    r_Ant = 50\n    c_Ant = 50\n    '// 蟻の方向を決める。\n    dir_Ant
    = DIR_UP    '上向き\n    \n    '////////////////////////////////////////////////////////////////////\n
    \   ' 主処理\n    '////////////////////////////////////////////////////////////////////\n
    \   \n    '// 蟻がシート内にいる間、以下を繰り返す。\n    Do While 0 &lt; c_Ant And c_Ant &lt;= Columns.Count
    _\n            And 0 &lt; r_Ant And r_Ant &lt;= Rows.Count\n    \n        '//
    蟻がいるマスの色による場合分け。\n        If Cells(r_Ant, c_Ant).Interior.Color = COLOR_BLACK
    Then\n            '// マスの色が黒:\n            \n            '// 蟻を90°右に方向転換する。\n
    \           dir_Ant = (dir_Ant + 1) Mod 4\n            \n            '// マスの色を白に変える。\n
    \           Cells(r_Ant, c_Ant).Interior.Color = COLOR_WHITE\n        Else\n            '//
    マスの色が白:\n            \n            '// 蟻を90°左に方向転換する。\n            dir_Ant = (dir_Ant
    + 3) Mod 4\n            \n            '// マスの色を黒に変える。\n            Cells(r_Ant,
    c_Ant).Interior.Color = COLOR_BLACK\n        End If\n        \n        '// 蟻を一歩進める。\n
    \       Select Case dir_Ant\n            Case DIR_UP\n                '// 蟻が上向き:\n
    \               r_Ant = r_Ant - 1\n            Case DIR_RIGHT\n                '//
    蟻が右向き:\n                c_Ant = c_Ant + 1\n            Case DIR_DOWN\n                '//
    蟻が下向き:\n                r_Ant = r_Ant + 1\n            Case DIR_LEFT\n                '//
    蟻が左向き:\n                c_Ant = c_Ant - 1\n        End Select\n    Loop\nEnd Sub\n"
  :tags:
  - VBA
  :references:
    :url: 
    :title: 
- :id: '9389'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9389
  :user_name: nattou_curry
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/913/
  :language: Other
  :time: 2009/07/18 03:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>Excel VBAにて、複数の蟻が動くようにしました。(#9388の変更)\r</p>\n<p>\r</p>\n<p>Excelを以下のように調整すると、実行結果が見やすくなります。\r</p>\n<ul>\n<li>\n行の高さと列の幅を調整して、全てのセルを正方形にする。\r\n</li>\n<li>表示倍率を小さくして、なるべく多くのセルが画面内に収まるようにする。\r</li>\n</ul>\n</div>\n\t"
  :code: "Option Explicit\n\n'// [定数] 蟻の方向\nConst DIR_UP = 0        '上向き\nConst DIR_RIGHT
    = 1     '右向き\nConst DIR_DOWN = 2      '下向き\nConst DIR_LEFT = 3      '左向き\n\n'//
    [定数] 色\nConst COLOR_WHITE = &amp;HFFFFFF    '白\nConst COLOR_BLACK = &amp;H0         '黒\n\n'//
    [構造体] 蟻\nType typ_Ant\n    r As Long       '// 蟻の位置(行番号)\n    c As Long       '//
    蟻の位置(列番号)\n    dir As Long     '// 蟻の方向\n    died As Boolean '// 死亡フラグ\nEnd Type\n\n'//
    ラングトンの蟻(複数版)\nSub Langtons_ant_s()\n\n    Dim ants() As typ_Ant   '蟻\n    Dim
    i As Integer        'インデックス\n    Dim AllDied As Boolean  '全ての蟻が死亡したか？\n    \n
    \   '////////////////////////////////////////////////////////////////////\n    '
    初期処理\n    '////////////////////////////////////////////////////////////////////\n
    \   \n    '// 蟻の数を決める。\n    ReDim ants(5)\n    \n    '// 蟻1匹目\n    ants(0).r =
    70\n    ants(0).c = 100\n    ants(0).dir = DIR_UP\n    \n    '// 蟻2匹目\n    ants(1).r
    = 100\n    ants(1).c = 100\n    ants(1).dir = DIR_UP\n    \n    '// 蟻3匹目\n    ants(2).r
    = 30\n    ants(2).c = 120\n    ants(2).dir = DIR_RIGHT\n    \n    '// 蟻4匹目\n    ants(3).r
    = 40\n    ants(3).c = 90\n    ants(3).dir = DIR_DOWN\n    \n    '// 蟻5匹目\n    ants(4).r
    = 40\n    ants(4).c = 10\n    ants(4).dir = DIR_LEFT\n    \n    '// 蟻6匹目\n    ants(5).r
    = 70\n    ants(5).c = 100\n    ants(5).dir = DIR_UP\n    \n    '////////////////////////////////////////////////////////////////////\n
    \   ' 主処理\n    '////////////////////////////////////////////////////////////////////\n
    \   \n    '// いずれかの蟻が生きている間、以下を繰り返す。\n    Do While True\n        AllDied = True\n
    \       For i = 0 To UBound(ants)\n            If Not ants(i).died Then\n                AllDied
    = False\n                Exit For\n            End If\n        Next\n        If
    AllDied Then\n            '// 全ての蟻が死亡している。\n            \n            '// 処理を中断する。\n
    \           Exit Do\n        End If\n        \n        '// 生きているすべての蟻について、以下を繰り返す。\n
    \       For i = 0 To UBound(ants)\n            If Not ants(i).died Then\n                \n
    \               '// 蟻がいるマスの色による場合分け。\n                If Cells(ants(i).r, ants(i).c).Interior.Color
    = COLOR_BLACK Then\n                    '// マスの色が黒:\n                    \n                    '//
    蟻を90°右に方向転換する。\n                    ants(i).dir = (ants(i).dir + 1) Mod 4\n                    \n
    \                   '// マスの色を白に変える。\n                    Cells(ants(i).r, ants(i).c).Interior.Color
    = COLOR_WHITE\n                Else\n                    '// マスの色が白:\n                    \n
    \                   '// 蟻を90°左に方向転換する。\n                    ants(i).dir = (ants(i).dir
    + 3) Mod 4\n                    \n                    '// マスの色を黒に変える。\n                    Cells(ants(i).r,
    ants(i).c).Interior.Color = COLOR_BLACK\n                End If\n                \n
    \               '// 蟻を一歩進める。\n                Select Case ants(i).dir\n                    Case
    DIR_UP\n                        '// 蟻が上向き:\n                        ants(i).r
    = ants(i).r - 1\n                    Case DIR_RIGHT\n                        '//
    蟻が右向き:\n                        ants(i).c = ants(i).c + 1\n                    Case
    DIR_DOWN\n                        '// 蟻が下向き:\n                        ants(i).r
    = ants(i).r + 1\n                    Case DIR_LEFT\n                        '//
    蟻が左向き:\n                        ants(i).c = ants(i).c - 1\n                End
    Select\n                \n                '// 蟻がシート内にいることを確認する。\n                If
    Not (0 &lt; ants(i).c And ants(i).c &lt;= Columns.Count _\n                        And
    0 &lt; ants(i).r And ants(i).r &lt;= Rows.Count) Then\n                    '//
    シート内にいない:\n        \n                    '// 蟻の死亡フラグをオンにする。\n                    ants(i).died
    = True\n                End If\n            \n            End If\n        Next\n
    \   Loop\nEnd Sub\n"
  :tags:
  - VBA
  :references:
    :url: 
    :title: 
- :id: '9390'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9390
  :user_name: ワサビ
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1045/
  :language: OCaml
  :time: 2009/07/18 06:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  F# 1.9.6.16 で作成しました。\r<br>初期状態の背景色を白黒選択可能にしました。\r<br>アリの初期状態の向きはランダムにしています。\n\t"
  :code: "open System\nopen System.Windows.Forms\nopen System.Drawing\n\nlet size
    = 300\nlet (white, black) = (-1, 1)\nlet dirTable = [|(1, 0); (0, 1); (-1, 0);
    (0, -1)|]\nlet dirTextTable = [|\"右\"; \"下\"; \"左\"; \"上\"|]\n\ntype Langton'sAntForm()
    as this =\n    inherit Form()\n    [&lt;DefaultValue&gt;]\n    val mutable ant
    : int -&gt; int[,] -&gt; Async&lt;unit&gt;\n    let bitmap = new Bitmap(size,
    size)\n    let picture = new PictureBox(Image = bitmap, Size = new Size(size,
    size), Location = new Point(0, 30))\n    let button = new Button(Size = new Size(50,
    30), Location = new Point(0, 0), Text = \"Start\")\n    let checkbox = new CheckBox(Size
    = new Size(70, 30), Location = new Point(60, 0), Text = \"黒背景\")\n    let labelDir
    = new Label(Size = new Size(80, 30), Location = new Point(140, 0), TextAlign =
    ContentAlignment.MiddleLeft)\n    let labelStep = new Label(Size = new Size(60,
    30), Location = new Point(230, 0), TextAlign = ContentAlignment.MiddleLeft)\n
    \   do this.Controls.AddRange([|(picture :&gt; Control); (button :&gt; Control);
    (checkbox :&gt; Control); (labelDir :&gt; Control); (labelStep :&gt; Control)|])\n
    \   do this.Text &lt;- \"ラングトンのアリ\"\n    do this.ClientSize &lt;- new Size(size,
    size + 30)\n    do this.FormBorderStyle &lt;- FormBorderStyle.Fixed3D\n    do
    this.MaximizeBox &lt;- false\n    do button.Click.Add(fun _ -&gt;\n        let
    dir = (new Random()).Next(4)\n        labelDir.Text &lt;- \"初期方向：\" ^ dirTextTable.[dir]\n
    \       let (place, color) = if checkbox.Checked then (black, Color.Black) else
    (white, Color.White)\n        [for x in 0..(size - 1) -&gt; [for y in 0..(size
    - 1) -&gt; (x, y)]] |&gt; List.concat\n        |&gt; List.iter(fun (x, y) -&gt;
    bitmap.SetPixel(x, y, color))\n        Array2D.create size size place |&gt; this.Ant
    dir |&gt; Async.Start\n        button.Enabled &lt;- false)\n    \n    member this.Ant
    with get() = this.ant and set(value) = this.ant &lt;- value\n    member this.Print
    (x, y) place step =\n        try\n            if this.InvokeRequired then\n                this.Invoke(new
    MethodInvoker(fun () -&gt;\n                    bitmap.SetPixel(x, y, if place
    = white then Color.White else Color.Black)\n                    labelStep.Text
    &lt;- string step\n                    this.Refresh()))\n                |&gt;
    ignore\n        with\n        | :? ObjectDisposedException -&gt; ()\n\nlet rec
    loop step (x, y) dir (field : int[,]) (form : Langton'sAntForm) =\n    let rotate
    dir place = (dir + place + 4) % 4\n    let turnover = ( * ) -1\n    let move (x,
    y) dir =\n        let (dx, dy) = dirTable.[dir] in (x + dx, y + dy)\n    let (|InField|OutOfField|)
    (x, y) =\n        if 0 &lt;= x &amp;&amp; x &lt; size &amp;&amp; 0 &lt;= y &amp;&amp;
    y &lt; size then InField else OutOfField\n\n    match (x, y) with\n    | OutOfField
    -&gt; ()\n    | InField -&gt;\n        let newDir = rotate dir field.[x, y]\n
    \       field.[x, y] &lt;- turnover field.[x, y]\n        form.Print (x, y) field.[x,
    y] step\n        loop (step + 1) (move (x, y) newDir) newDir field form\n\n[&lt;STAThread()&gt;]\ndo\n
    \   use form = new Langton'sAntForm()\n    form.Ant &lt;- fun dir field -&gt;
    async { loop 1 (size / 2, size / 2) dir field form }\n    Application.EnableVisualStyles()\n
    \   Application.Run(form) |&gt; ignore\n"
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '9392'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9392
  :user_name: airhead
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1026/
  :language: JavaScript
  :time: 2009/07/18 15:09 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  アリの動作をどう書くかという話じゃなく、余談にはなりますが、参考ページのブログエントリに書かれていたビットマップ表現と効率について。\r<br><br>DOMのあるノード直下に非常に多数のノードを作る（兄弟ノードが多すぎる）・それらのノードにアクセスするというのは、速度低下の原因になりがちです。どのくらいの数からどこに影響が出るかは実装によるでしょうが、ノード総数が少々多くなろうとも入れ子・小分けにすることで改善できる場合があります。\r<br><br>添付コードのように変更を加えた場合、Pen4 2.53GHzにおいて時間を計測すると次のようになりました（単位:ms ― 遅いCPUだから差が顕著になっているのであって、今時のCPUではこれほどの改善は見込めないかもしれませんが）。\r<br><br>Firefox 3.5.1:\r<br>キャンバス作成（ノード作成）が34,551から1,021へと大幅に改善、アリの行進（ノードアクセス）でも330,770から216,934に改善\r<br>Opera 10b1:\r<br>キャンバス作成は328から344にと若干遅くなるが、もともとあまり時間が掛かっていない。アリの行進の方は1,188,625から415,312に改善\r<br><br>一方で、テーブル要素にしてしまう方法も試してみましたが、手元の環境ではdiv要素で小分けとほとんど変わりませんでした。セルの色表現を、要素のクラス書き換え・クラスごとにCSSで色指定する方法も試してみたが、こちらでもほとんど変化なし。\r<br>"
  :code: "&lt;style type=\"text/css\"&gt;\n#canvas{\n       border: 1px solid #999;\n
    \      width: 300px;\n       height: 300px;\n}\n/* 子divへのCSS指定を、孫divへの指定にするだけ
    */\n#canvas div div{\n       width: 3px;\n       height: 3px;\n       float: left;\n}\n&lt;/style&gt;\n\n\n\n//
    スクリプト部の変更点はwindow.onloadのコールバックのみ\n\nwindow.onload = function(){\n// キャンバス作成部
    セルを表すdivを入れ子に\n    var canvas = document.getElementById('canvas');\n    var k
    = 0;\n    for(var i=0; i&lt; WORLD_SIZE; i++){\n        var row = document.createElement('div');\n
    \       canvas.appendChild(row);\n        for(var j=0; j&lt; WORLD_SIZE; j++){\n
    \           var cell = document.createElement('div');\n            row.appendChild(cell);\n
    \           earth[k] = new Cell(cell);\n            k++;\n        }\n    }\n//
    以下変更なし\n    lang_ant = new Ant();//蟻の誕生\n    lang_ant.world = earth;//地球に降り立つ\n
    \   lang_ant.ageDisplay = document.getElementById('step');\n    \n    document.getElementById('run').disabled
    = false;\n}\n"
  :tags:
  - dom
  :references:
    :url: 
    :title: 
- :id: '9394'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9394
  :user_name: konn
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/100/
  :language: Haskell
  :time: 2009/07/19 11:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Haskellで実装。要：UTF8-String</p>\n<p>$ runhaskell langton.hs 100 100
    20</p>\n<p>とかすると、100x100マスの世界の模様を20ステップごとに表示してくれます。最後の数字を省略すると律儀に一世代ごとに印字します。</p>\n<p>無限リストばんざい！</p>\n\n\t"
  :code: |
    import qualified System.IO.UTF8 as U
    import System.Environment (getArgs, getProgName)
    import Control.Monad.State
    import qualified Data.Map as M
    import Data.List (sortBy, groupBy)

    type Point = (Int, Int)
    type Direction = (Int, Int)
    data Ant = Ant {pos::Point, direction::Direction} deriving Show
    data Color = White | Black

    data AntsState = AS { world::(M.Map Point Color), ants::[Ant], wrap :: Bool, height::Int, width::Int, generation::Int }

    instance Show Color where
      show Black = "■"
      show White = "□"

    cmp f ((_,a),_) ((_,b),_) = f a b

    instance Show AntsState where
      show AS{world=wd, generation=g} = "gen: " ++ show g ++ "\n" ++ (unlines $ map (concatMap(show.snd)) $ groupBy (cmp (==)) $ (sortBy (cmp compare) $ M.toList wd))

    main = do args &lt;- getArgs
              pname &lt;- getProgName
              case args of
                (x:y:s:_) -&gt; mapM_ (U.putStrLn . show . head) $ iterate (drop (read s)) $ evolutions (read x) (read y)
                (x:y:_)   -&gt; mapM_ (U.putStrLn . show) $ evolutions (read x) (read y)
                _         -&gt; putStrLn ("usage: " ++ pname ++ " height width [step]")

    makeAnt x y = Ant {pos=(x, y), direction=(0,-1)}

    makeWorld height width ants wrap = AS {
      world = M.fromList [((x,y), White) | x &lt;- [0..width-1], y &lt;- [0..height-1]],
      ants = ants,
      height = height,
      width = width,
      generation = 0,
      wrap = wrap
    }

    proceed :: State AntsState AntsState
    proceed = do  st@AS{ants=as,generation=g} &lt;- get
                  a' &lt;- mapM procAnts as
                  st &lt;- get
                  let s = st{ants = a',generation=g+1}
                  put s
                  return s

    procAnts ant@Ant{pos=p@(x,y), direction=(dx,dy)} = do
      w@AS{world=wd, wrap=wr, width=wdt, height=h} &lt;- get
      let pt = ((x+dx) `mod` wdt, (y+dy) ` mod` h)
          st = maybe Black id $ M.lookup pt wd
          (dr, s') = case st of
                      Black -&gt; ((dy, -dx), White)
                      _     -&gt; ((-dy, dx), Black)
      put w{world= M.insert pt s' wd}
      return ant{pos = pt, direction = dr}

    evolutions width height = iterate (execState proceed) (makeWorld width height [makeAnt (width*3`div`5) (height*2`div`5)] True)
  :tags:
  - utf8-string
  :references:
    :url: 
    :title: 
- :id: '9398'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9398
  :user_name: ' U D '
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1085/
  :language: 
  :time: 2009/07/20 05:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>画面のサイズや画面端での扱いについて特に規定されていないようなので、何も考えずにサックリと書いてみた。枠まで到達しても死にません。</p>\n<p>方向転換に関する論理計算がパッと見で分かりにくいだけで、他は分かりやすいのではないかと。</p>\n\n\t"
  :code: |
    ！東=0
    ！南=1
    ！西=2
    ！北=3

    線スタイルは`透明`
    必要な 間、蟻を進めて0.01秒待つ

    ■ブロック
    　・{整数}W{=5}
    　・{整数}H{=5}
    　・色取得(X,Yの)～
    　　X*W,Y*Wを点取得
    　・プロット(X,YにCOLを)～
    　　塗り色はCOL
    　　X*W,Y*Hから(X+1)*W,(Y+1)*Hへ四角

    ■蟻　+ブロック
    　・{整数}向き{=2}
    　・{整数}X{=40}
    　・{整数}Y{=40}
    　・進む～
    　　COLとは整数=X,Yの色取得
    　　向き=(向き-2*(COL==白色)+5)%4
    　　X,Yに(COLの反転色)をプロット
    　　X=X-(向き==西)+(向き==東)
    　　Y=Y-(向き==南)+(向き==北)

    ●反転色(COLの)
    　白色-COLを戻す
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9399'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9399
  :user_name: ' U D '
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1085/
  :language: 
  :time: 2009/07/20 05:20 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <p>連投失礼。Wikipediaに載っていた拡張版のラングトンの蟻（色反転でなく、複数色循環）も実装してみた。まだ誰もやっていなかったかな？拡張の解釈は多分合っていると思ふ。。。</p>\n<p>あたかも要塞のように常に左右に対称に広がっていく様子は割と面白い。（都市発展系のシミュレーションゲームのよう）</p>\n<p>#
    発展にかなり時間がかかるので、ついでに500ステップ毎に描画を反映させるようにしました。</p>\n\n\t"
  :code: |
    ！ブロック幅　=3
    ！ブロック高さ=3
    ！世界幅　=150
    ！世界高さ=120

    ！東=0
    ！南=1
    ！西=2
    ！北=3

    ！色数　=4
    ！基準色=黒色
    ！STEPBY=500

    ルールは『RLLR』
    ルールの色配列は「{基準色},{赤色},{青色},{緑色}」を`,`で区切ったもの

    母艦について
    　クライアントW=ブロックのW*世界幅
    　クライアントH=ブロックのH*世界高
    　スタイルは`枠固定`
    　基準色で画面クリア

    STEPとは整数

    線スタイルは`透明`
    必要な 間
    　蟻を進める。
    　もしSTEP%STEPBYが0ならば
    　　0.01秒待つ
    　　母艦は「step: {STEP}」
    　STEPに1を直接足す

    ■ルール
    　・{配列}ルール配列
    　・テキスト　←ルール設定　デフォルト
    　・ルール設定(V)～
    　　Vを文字列分解して反復
    　　　ルール配列[回数-1]=2*(対象==`R`)-1　# Rなら1、それ以外は-1
    　・{非公開}色配列

    ■ブロック
    　・{非公開}W{=3}
    　・{非公開}H{=3}
    　・色取得(X,Yの)～
    　　X*W,Y*Wを点取得
    　・プロット(X,YにCOLを)～
    　　塗り色はCOL
    　　X*W,Y*Hから(X+1)*W,(Y+1)*Hへ四角

    ■蟻　+ブロック
    　・{整数}向き{=0}
    　・{整数}X{=75}
    　・{整数}Y{=50}
    　・進む～
    　　COLとは整数=X,Yの色取得
    　　COLで向きを方向転換する
    　　COLを色循環する
    　　X,YにCOLをプロット
    　　Xに(向き==東)-(向き==西)を世界幅でMOD加算
    　　Yに(向き==南)-(向き==北)を世界高でMOD加算

    ●方向転換する({整数}COLで{参照渡し}DIRを)
    　Iとは整数=ルールの色配列でCOLを配列検索
    　もしIが(-1)ならばI=0
    　DIRに(ルールのルール配列[I])を4でMOD加算する

    ●色循環する({参照渡し}COLを)
    　COLORSとは配列=ルールの色配列
    　Iとは整数=COLORSでCOLを配列検索
    　COL=COLORS[(I+1)%色数]

    # Z/CZ上でAにBを直接足す
    ●MOD加算({参照渡し}Aに{整数}Bを{整数}Cで)
    　A=(A+B+C)%C
  :tags: []
  :references:
    :url: /web/20100712030836/http://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%82%B0%E3%83%88%E3%83%B3%E3%81%AE%E3%82%A2%E3%83%AA
    :title: ラングトンのアリ
- :id: '9400'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9400
  :user_name: silverwire
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/646/
  :language: Batchfile
  :time: 2009/07/21 03:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">バッチで。\r\n\r\n  e.g.\r\n    C:\\&gt;#276.bat
    10\r\n    \r\n               |\r\n          **   |\r\n         *  *  |\r\n        *
    \   * |\r\n        *    * |\r\n         ****  |\r\n               |\r\n               |\r\n
    \              |\r\n               |\r\n    X = 7, Y = 5</pre>\n\t"
  :code: "@echo off\nsetlocal enabledelayedexpansion\n  set s=\n  set t=\n  set x=0\n
    \ set y=0\n  set dx=-1\n  set dy=0\n  \n  if \"%~1\" == \"\" (echo usage: %~n0
    SIZE &gt;&amp;2 &amp; exit /b 1)\n  \n  set /a x=%~1/2,y=%~1/2\n  \n  for /l %%j
    in (1,1,%~1) do (\n    for /l %%i in (1,1,%~1) do set c[%%i][%%j]=0\n  )\n  \n
    \ :_\n    if !x! lss 1 goto BREAK\n    if !x! gtr %~1 goto BREAK\n    if !y! lss
    1 goto BREAK\n    if !y! gtr %~1 goto BREAK\n    \n    if !c[%x%][%y%]! equ 0
    (\n      set c[%x%][%y%]=1\n      set t=%dx%\n      set dx=%dy%\n      set /a
    dy=-!t!\n    ) else (\n      set c[%x%][%y%]=0\n      set t=%dx%\n      set /a
    dx=-!dy!\n      set dy=!t!\n    )\n    set /a x+=%dx%,y+=%dy%\n    \n    cls\n
    \   for /l %%j in (1,1,%~1) do (\n      set s=\n      for /l %%i in (1,1,%~1)
    do (\n        if !c[%%i][%%j]! equ 0 (\n          set s=!s! \n        ) else (\n
    \         set s=!s!*\n        )\n      )\n      echo ^ !s!^|\n    )\n    echo
    X = %x%, Y = %y%\n    \n    ping -n 2 127.0.0.1 &gt; NUL\n  goto _\n  :BREAK\nendlocal
    &amp; echo DEAD END ...\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9401'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9401
  :user_name: ぴょん
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/490/
  :language: Python
  :time: 2009/07/21 12:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    #!/usr/bin/python
    # -*- coding: utf-8 -*-
    # http://ja.doukaku.org/276/

    import random
    import sys

    EAST = 0
    NORTH = 90
    WEST = 180
    SOUTH = 270

    BLACK = (0, 0, 0)
    RED = (1, 0, 0)
    GREEN = (0, 1, 0)
    BLUE = (0, 0, 1)


    class Grid(object):

        def __init__(self, width=40, height=20):
            self._width = width
            self._height = height
            self._color = {}

        def width(self):
            return self._width

        def height(self):
            return self._height

        def color(self, position, color=None):
            if color is not None:
                self._color[tuple(position)] = color

            return self._color.get(tuple(position), BLACK)

        def view(self):
            for y in range(0, self.height()):
                for x in range(0, self.width()):
                    sys.stdout.write({
                        BLACK: ' ',
                        RED: '*',
                        GREEN: '+',
                        BLUE: '@',
                        }[self.color((x, y))])
                sys.stdout.write('\n')


    class Ant(object):

        def __init__(
            self,
            grid,
            color=RED,
            position=[10, 10],
            direction=EAST,
            ):

            self._grid = grid
            self._position = position
            self._direction = direction
            self._color = color

        def position(self, position=None):
            if position is not None:
                self._position = list(position)

            return self._position

        def color(self, color=None):
            if color is not None:
                self._color = color

            return self._color

        def left(self):
            self._direction = (self._direction + 90) % 360

        def right(self):
            self._direction = (self._direction - 90) % 360

        def forward(self):
            if self._direction == NORTH:
                self._position[1] -= 1
            elif self._direction == SOUTH:
                self._position[1] += 1
            elif self._direction == EAST:
                self._position[0] -= 1
            elif self._direction == WEST:
                self._position[0] += 1

            self._position[0] %= self._grid.width()
            self._position[1] %= self._grid.height()

        def step(self):
            if self._color == self._grid.color(self._position):
                self._grid.color(self._position, BLACK)
                self.left()
            else:
                self._grid.color(self._position, self._color)
                self.right()

            self.forward()


    if __name__ == '__main__':

        width = int(sys.argv[1])
        height = int(sys.argv[2])
        num = int(sys.argv[3])
        iteration = int(sys.argv[4])

        grid = Grid(width=width, height=height)
        ants = []
        for i in range(0, num):
            c = (RED, GREEN, BLUE)[i % 3]
            x = int(random.random() * width)
            y = int(random.random() * height)
            ants.append(Ant(grid, color=c, position=[x, y]))

        for i in range(0, iteration):
            for ant in ants:
                ant.step()
            if i % (iteration / 10) == 0:
                sys.stdout.write('step: %d\n' % i)
                grid.view()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9402'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9402
  :user_name: mattsan
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/833/
  :language: Haskell
  :time: 2009/07/21 07:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Haskellに翻訳。\r<br>C++からの「翻訳」なのでHaskellらしくないかもしれません。\n\t"
  :code: |
    import Graphics.UI.GLUT
    import Control.Exception
    import System.Exit
    import Data.IORef

    interval     = 0
    windowWidth  = 320::GLsizei
    windowHeight = 240::GLsizei

    data Direction = North | East | South | West deriving Enum
    data Ant = Ant Position Direction

    turnRight :: Direction -&gt; Direction
    turnRight d = toEnum (((fromEnum d) + 1) `mod` 4)

    turnLeft :: Direction -&gt; Direction
    turnLeft d = toEnum (((fromEnum d) + 3) `mod` 4)

    initialEnv :: (Ant, [Position])
    initialEnv = (Ant (Position (windowWidth `div` 2) (windowHeight `div` 2)) East, [])

    convd :: (Integral a) =&gt; a -&gt; GLdouble
    convd = fromInteger.toInteger

    forward (Position x y) North = Position x (y - 1)
    forward (Position x y) East  = Position (x + 1) y
    forward (Position x y) South = Position x (y + 1)
    forward (Position x y) West  = Position (x - 1) y

    draw env = do
      (_, ps) &lt;- readIORef env
      clearColor $= Color4 1.0 1.0 1.0 1.0
      clear [ColorBuffer]
      color $ Color3 (0.0::Double) 0.0 0.0
      renderPrimitive Points $ mapM_ (¥ (Position x y) -&gt; vertex $ Vertex2 x y) ps
      swapBuffers

    update (Ant pos dir, ps) =
      if elem pos ps
        then (Ant (forward pos (turnRight dir)) (turnRight dir), [p | p &lt;- ps, p /= pos])
        else (Ant (forward pos (turnLeft dir)) (turnLeft dir), pos:ps)

    -- event handlers

    display env = do
      draw env

    reshape (Size w h) = do
      viewport $= (Position 0 0, Size w h)
      loadIdentity
      ortho (-0.5) ((convd w) - 0.5) ((convd h) - 0.5) (-0.5) (-1.0) (1.0)

    keyboardMouse key keystate modifiers position = do
      case key of
        Char 'q' -&gt; throwIO $ ExitException ExitSuccess
        _        -&gt; return ()

    timer env = do
      modifyIORef env $ update
      draw env
      addTimerCallback interval $ timer env

    main = do
      env &lt;- newIORef initialEnv
      getArgsAndInitialize
      initialDisplayMode    $= [RGBAMode, DoubleBuffered]
      initialWindowPosition $= Position 100 100
      initialWindowSize     $= Size windowWidth windowHeight
      createWindow "doukaku#276"
      displayCallback       $= display env
      reshapeCallback       $= Just reshape
      keyboardMouseCallback $= Just keyboardMouse
      addTimerCallback interval $ timer env
      mainLoop
  :tags:
  - GLUT
  - OpenGL
  :references:
    :url: 
    :title: 
- :id: '9403'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9403
  :user_name: ぴょん
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/490/
  :language: Python
  :time: 2009/07/21 21:13 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Python + Tkinter</p>\n\n\t"
  :code: |
    #!/usr/bin/python
    # -*- coding: utf-8 -*-
    # http://ja.doukaku.org/276/

    import random
    import sys
    import Tkinter as Tk

    DOT_SIZE = 5


    class Ant(object):

        def __init__(self, grid, x, y, direction, color):
            self._grid = grid
            self.x = x
            self.y = y
            self.direction = direction
            self.color = color

        def left(self):
            self.direction = (self.direction + 90) % 360

        def right(self):
            self.direction = (self.direction - 90) % 360

        def forward(self):
            diff = {  # 0:EAST, 90:NORTH 180:SOUTH 270:WEST
                0: (1, 0),
                90: (0, -1),
                180: (-1, 0),
                270: (0, 1),
                }[self.direction]
            self.x = (self.x + diff[0]) % self._grid.width
            self.y = (self.y + diff[1]) % self._grid.height

        def is_my_color(self):
            return self.color == self._grid.get_color(self.x, self.y)

        def black(self):
            self._grid.delete_color(self.x, self.y)

        def my_color(self):
            self._grid.update_color(self.x, self.y, self.color)

        def step(self):
            if self.is_my_color():
                self.black()
                self.left()
            else:
                self.my_color()
                self.right()

            self.forward()


    class Grid(Tk.Canvas):

        def __init__(self, parent, width=40, height=20):
            self.width = width
            self.height = height
            self._color = {}

            xw = DOT_SIZE * self.width
            xh = DOT_SIZE * self.height
            Tk.Canvas.__init__(self, parent, background='black', width=xw,
                               height=xh)

        def color(self, x, y):
            return self._color.get((x, y), {'id': None, 'color': 'black'})

        def get_color(self, x, y):
            return self.color(x, y)['color']

        def delete_color(self, x, y):
            old = self.color(x, y)
            if old['id'] is not None:
                self.delete(old['id'])
                del self._color[(x, y)]

        def update_color(self, x, y, color):
            old = self.color(x, y)
            if old['id'] is None:
                xx0 = x * DOT_SIZE
                xy0 = y * DOT_SIZE
                xx1 = xx0 + DOT_SIZE
                xy1 = xy0 + DOT_SIZE
                id = self.create_rectangle(xx0, xy0, xx1, xy1, fill=color,
                                           outline=color)
                self._color[(x, y)] = {'id': id, 'color': color}
            else:
                self.itemconfigure(old['id'], fill=color, outline=color)


    class Frame(Tk.Frame):

        def __init__(self, width, heigth, num_ant, master=None):
            Tk.Frame.__init__(self, master)
            self.master.title('Rangton Ant')

            self._grid = Grid(self, width=width, height=height)
            self._grid.pack()

            def _rand_int(n):
                return int(random.random() * n)

            def _make_ant(i):
                c = ('red', 'yellow', 'green', 'cyan', 'blue', 'cyan',
                     'magenta', 'white')[i % 7]
                d = (0, 90, 180, 270)[_rand_int(4)]
                x = _rand_int(width)
                y = _rand_int(height)
                return Ant(self._grid, x, y, d, c)

            self._ants = map(_make_ant, range(num_ant))

            self.move()

        def move(self):
            for ant in self._ants:
                ant.step()
            self.after(1, self.move)


    if __name__ == '__main__':

        width = int(sys.argv[1])
        height = int(sys.argv[2])
        num_ant = int(sys.argv[3])

        f = Frame(width, height, num_ant)
        f.pack()
        f.mainloop()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9404'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9404
  :user_name: tkturbo
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1056/
  :language: JavaScript
  :time: 2009/07/22 01:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>出題者によるデモが初期読み込み時に重かったので、改編してみました。</p>\n<p>おまけにアリ自体も最大5匹まで増量可能だったり。</p>\n<p>ちなみにOperaだとCSSのエラーで動かないっぽいのが難点ですorz</p>\n\n\t"
  :code: |
    &lt;html&gt;
      &lt;head&gt;
        &lt;meta http-equiv="content-type" content="text/html;charset=shift_jis"&gt;
        &lt;title&gt;Langton's Ant&lt;/title&gt;
        &lt;script type="text/javascript"&gt;&lt;!-- //
    langton={};

    langton.Direction=function(x,y){ this.x=(x)?x:0; this.y=(y)?y:0; };

    langton.Direction.prototype={
      x : 0,
      y : 0,
      equals : function(test){
                 return (this.x==test.x)&amp;&amp;(this.y==test.y);
               },
      change : function(dif){
                 var val=langton.Direction.next(this,dif);
                 this.x=val.x;
                 this.y=val.y;
                 return this;
               }
     };

    langton.Direction.NORTH=new langton.Direction(0,-1);
    langton.Direction.SOUTH=new langton.Direction(0,1);
    langton.Direction.EAST=new langton.Direction(1,0);
    langton.Direction.WEST=new langton.Direction(-1,0);

    langton.Direction.CYCLE=[
      langton.Direction.NORTH,
      langton.Direction.EAST ,
      langton.Direction.SOUTH,
      langton.Direction.WEST
    ];

    langton.Direction.FORWORD=0;
    langton.Direction.RIGHT=1;
    langton.Direction.BACKWORD=2;
    langton.Direction.LEFT=3;

    langton.Direction.next=function(current,change){
      var i = 0;
      for( ; i &lt; langton.Direction.CYCLE.length; i++){
        if(current.equals(langton.Direction.CYCLE[i])){ break; }
      }
      i+=change;
      i%=langton.Direction.CYCLE.length;
      return langton.Direction.CYCLE[i];
    };

    langton.Ant=function(){};

    langton.Ant.prototype={
      x : -1,
      y : -1,
      direction : null,
      color : null,
      go : function(lr){
             this.direction=this.direction.change(lr);
             this.x+=this.direction.x;
             this.y+=this.direction.y;
             if(this.x==langton.Canvas.rowsize){ this.x=0; }
             if(this.x&lt;0){ this.x=langton.Canvas.rowsize-1; }
             if(this.y==langton.Canvas.rowsize){ this.y=0; }
             if(this.y&lt;0){ this.y=langton.Canvas.rowsize-1; }
             return this;
           },
      eat : function(cell,isblack){
              var color = (isblack)?this.color:langton.Canvas.BLACK;
              cell.style.backgroundColor=color;
            },
      action : function(cells){
                 var index = this.y*langton.Canvas.rowsize + this.x;
                 if(!cells[index]){
                   cells[index]=langton.Canvas.prepareCell();
                   cells[index].style.position="absolute";
                   cells[index].style.top=(this.x*3)+"px";
                   cells[index].style.left=(this.y*3)+"px";
                 }
                 var isblack=(cells[index].style.backgroundColor==langton.Canvas.BLACK);
                 this.eat(cells[index],isblack);
                 var choice = (isblack) ? langton.Direction.RIGHT
                                        : langton.Direction.LEFT;
                 this.go(choice);
                 return this;
               }
    };

    langton.Canvas={};

    langton.Canvas.body=null;
    langton.Canvas.counter=null;

    langton.Canvas.rowsize=100;
    langton.Canvas.cells=[];

    langton.Canvas.clear=function(){
      if(langton.Canvas.counter){
        langton.Canvas.counter.value=0;
        langton.Canvas.counter=null;
      }
      if(langton.Canvas.body){
        langton.Canvas.body.innerHTML="";
        langton.Canvas.body=null;
      }
      langton.Canvas.ants=[];
      langton.Canvas.cells=[];
    };

    langton.Canvas.ants=[];

    langton.Canvas.BLACK="black";
    langton.Canvas.WHITE="white";
    langton.Canvas.BLUE="blue";
    langton.Canvas.RED="red";
    langton.Canvas.YELLOW="yellow";
    langton.Canvas.GREEN="green";

    langton.Canvas.COLORS=[
      langton.Canvas.WHITE,
      langton.Canvas.BLUE,
      langton.Canvas.RED,
      langton.Canvas.YELLOW,
      langton.Canvas.GREEN
    ];

    langton.Canvas.prepareCell=function(){
      var div = document.createElement("div");
      langton.Canvas.body.appendChild(div);
      div.style.width="3px";
      div.style.height="3px";
      div.style.backgroundColor=langton.Canvas.BLACK;
      return div;
    };

    langton.Canvas.addAnt=function(){
      if(langton.Canvas.ants.length &lt; langton.Canvas.COLORS.length){
        var ant =new langton.Ant();
        ant.x=Math.floor(Math.random()*langton.Canvas.rowsize);
        ant.y=Math.floor(Math.random()*langton.Canvas.rowsize);
        ant.color=langton.Canvas.COLORS[langton.Canvas.ants.length];
        var dirid = Math.floor(Math.random()*langton.Direction.CYCLE.length);
        var dir = langton.Direction.CYCLE[dirid];
        ant.direction=new langton.Direction(dir.x,dir.y);
        langton.Canvas.ants.push(ant);
      };
    };

    langton.Action=function(){
      if(!langton.Canvas.body){
        langton.Canvas.body=document.getElementById("canvas");
      }
      if(langton.Canvas.ants.length==0){
        langton.Canvas.addAnt();
      }
      for(var i = 0; i &lt; langton.Canvas.ants.length; i++){
        langton.Canvas.ants[i].action(langton.Canvas.cells);
      }
      if(!langton.Canvas.counter){
        langton.Canvas.counter=document.getElementById("counter");
      }
      var value = parseInt(langton.Canvas.counter.value,10)+1;
      langton.Canvas.counter.value=value;
    };

    /* -------------------------------------------------------------------------------- */
    langton.timer=0;
    langton.isTimerOn=false;

    langton.startTimer=function(){
      langton.isTimerOn=true;
      document.getElementById("run").disabled=true;
      document.getElementById("clear").disabled=true;
      langton.timer = setInterval(langton.executeTimer, 1);
    };

    langton.stopTimer=function(){
      langton.isTimerOn=false;
    };

    langton.executeTimer=function(){
      if(langton.isTimerOn) langton.Action();
      else{
        clearInterval(langton.timer);
        document.getElementById("run").disabled=false;
        document.getElementById("clear").disabled=false;
        return 0;
      }
    };

    function test(){
      langton.Action();
    }

        // --&gt;&lt;/script&gt;
        &lt;style type="text/css"&gt;
    #canvas{
           border: 1px solid #999;
           width: 300px;
           height: 300px;
           background-color: black;
    }
        &lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;p&gt;
          &lt;input type="button"
                 value="run"
                 onclick="langton.startTimer();"
                 id="run" /&gt;
          &lt;input type="button"
                 value="add"
                 onclick="langton.Canvas.addAnt();" /&gt;
          &lt;input type="button"
                 value="stop"
                 onclick="langton.stopTimer();" /&gt;
          &lt;input type="button"
                 value="clear"
                 onclick="langton.Canvas.clear()"
                 id="clear" /&gt;
          &lt;input type="text" id="counter" disabled value=0 /&gt;
        &lt;/p&gt;
        &lt;div id="canvas" style="position:relative"&gt;&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  :tags: []
  :references:
    :url: /web/20100712030836/http://blog.livedoor.jp/tkturbo/archives/51555375.html
    :title: サンプル
- :id: '9419'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9419
  :user_name: 匿名
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/4/
  :language: PostScript
  :time: 2009/07/26 11:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p><a class=\"reference\" href=\"/web/20100712030836/http://d.hatena.ne.jp/yshl/20090726\">http://d.hatena.ne.jp/yshl/20090726</a>
    から転載です</p>\n\n\t"
  :code: "%!PS\ngsave\n    0 dict begin\n        /fieldsize 100 def\n        /white
    [1 1 1] def\n        /field [ fieldsize{ [fieldsize{ white }repeat] }repeat ]
    def\n        /check-mark{\n            % ant -- bool\n            begin\n                field
    position-x get position-y get\n                color eq\n            end\n        }def\n
    \       /draw-mark{\n            % ant --\n            begin\n                field
    position-x get position-y color put\n            end\n        }def\n        /erase-mark{\n
    \           % ant --\n            begin\n                field position-x get
    position-y white put\n            end\n        }def\n\n        /generate-ant{\n
    \           % init-x init-y direction-x direction-y color -- dict\n            5
    dict begin\n                /color exch def\n                /direction-y exch
    def\n                /direction-x exch def\n                /position-y exch def\n
    \               /position-x exch def\n                currentdict\n            end\n
    \       }def\n        /move{\n            % ant --\n            begin\n                /position-x
    position-x direction-x add def\n                /position-y position-y direction-y
    add def\n            end\n        }def\n        /turn-left{\n            % ant
    --\n            begin\n               direction-y neg\n               direction-x\n
    \              /direction-y exch def\n               /direction-x exch def\n           end\n
    \       }def\n        /turn-right{\n            % ant --\n            begin\n
    \               direction-y\n                direction-x neg\n                /direction-y
    exch def\n                /direction-x exch def\n            end\n        }def\n
    \       \n        /draw-field{\n            2 2 scale\n            0 1 fieldsize
    1 sub{\n                % x\n                0 1 fieldsize 1 sub{\n                %
    x y\n                    field 2 index get 1 index get\n                    aload
    pop setrgbcolor\n                    2 copy 1 1 rectfill\n                    pop\n
    \               }for\n                pop\n            }for\n            showpage\n
    \       }def\n\n        /ant1\n            fieldsize 2 idiv dup 0 1 [0 0 0] generate-ant\n
    \       def\n        0 1 20000{\n            ant1\n            dup check-mark{\n
    \               dup erase-mark\n                dup turn-right\n                move\n
    \           }{\n                dup draw-mark\n                dup turn-left\n
    \               move\n            }ifelse\n            ant1 begin\n                position-x
    dup 0 lt exch fieldsize ge or\n                position-y dup 0 lt exch fieldsize
    ge or\n                or\n            end\n            {\n                exit\n
    \           }if\n            % 20歩毎に表示\n            20 mod 0 eq{\n                draw-field\n
    \           }if\n        }for\n    end\ngrestore\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9424'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9424
  :user_name: ivoryworks
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/647/
  :language: 
  :time: 2009/07/27 14:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">秀丸マクロで。\r\nセルを全角で表現しているので、かなり幅が広くなってしまいます。\r\n</pre>\n\t"
  :code: |
    #w = 100;
    #dct = 0;
    $sp = "　";
    $line = "";

    #i = 0;
    while (#i &lt; #w) {
        $line = $line+$sp;
        #i = #i + 1;
    }
    $line = $line+"\n";

    #i = 0;
    while (#i &lt; #w) {
        insert $line;
        #i = #i + 1;
    }
    movetolineno #w,#w/2;

    #i = 0;
    while (1) {
        $ant = gettext(x, y, x+2, y);
        if ($ant == $sp) {
            overwrite "○";
            #dct = (#dct+1)%4;
        } else {
            overwrite $sp;
            #dct = (((#dct+1)%4)+2)%4;
        }
        left;
        if (#dct == 0) {
            up;
        } else if (#dct == 1) {
            right;
        } else if (#dct == 2) {
            down;
        } else if (#dct == 3) {
            left;
        }
        if ((x &gt; #w*2-1)||(x == 0)||(y == 0)||(y &gt; #w-1)) {
            endmacro;
        }
    }
    endmacro;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9436'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9436
  :user_name: pa
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/943/
  :language: Other
  :time: 2009/07/31 21:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Tkで描画。\r\ncanvasを配置し、そこにドットを描く。\r\n使うモジュールはTk,
    Tkclient。\r\n\r\nメモ\r\n・TKの使い方\r\n・初期値つきの二次元配列の定義\r\n・ドットの代わりにlineを使用している。メモリを沢山消費しているかも</pre>\n\t"
  :code: "implement d276;\n# doukaku?276 Langton\n\ninclude \"sys.m\";\n    sys:Sys;\ninclude
    \"draw.m\";\n    draw: Draw;\ninclude \"tk.m\";\n    tk: Tk;\ninclude \"tkclient.m\";\n
    \   tkclient: Tkclient;\n\nd276: module {\n    init: fn(ctxt: ref Draw-&gt;Context,
    argv: list of string);\n};\n\ninit(ctxt: ref Draw-&gt;Context, argv: list of string)\n{\n
    \   sys = load Sys Sys-&gt;PATH;\n    sys-&gt;pctl(sys-&gt;NEWPGRP, nil);\n    draw
    = load Draw Draw-&gt;PATH;\n    tk = load Tk Tk-&gt;PATH;\n    tkclient = load
    Tkclient Tkclient-&gt;PATH;\n\n    # canvas size\n    height := 128;\n    width
    := 128;\n\n    pixel := array [width] of { * =&gt; array [height] of { * =&gt;
    0}}; # 2dimensional array\n    curx := width/2;\n    cury := height/2;\n    dir
    := 0; # N: 0 E: 1 S: 2 W: 3\n\n    tkclient-&gt;init();\n\n    if(ctxt == nil)\n
    \       ctxt = tkclient-&gt;makedrawcontext();\n\n    (win, wmctl) := tkclient-&gt;toplevel(ctxt,
    nil, \"d276\", 0);\n\n    # create canvas\n    tk-&gt;cmd(win, sys-&gt;sprint(\"canvas
    .b -width %d -height %d -background white\",width , height));\n    tk-&gt;cmd(win,
    \"pack .b\");\n    tk-&gt;cmd(win, \"update\");\n    \n    tkclient-&gt;onscreen(win,
    nil);\n    tkclient-&gt;startinput(win, \"kbd\"::\"ptr\"::nil);\n\n    for(;;){\n
    \       # toggle pixel and turn\n        color :=pixel[curx][cury];\n        cstr
    : string;\n        if(color){\n            cstr = \"white\";\n            color
    = 0;\n            dir += 1;\n            if(dir &gt; 3) dir = 0;\n        }else{\n
    \           cstr = \"black\";\n            color = 1;\n            dir -= 1;\n
    \           if(dir &lt; 0) dir = 3;\n        }\n        pixel[curx][cury] = color;\n\n
    \       # Plot (using line)\n        tk-&gt;cmd(win, sys-&gt;sprint(\".b create
    line %d %d %d %d -fill %s\", curx,cury, curx,cury,cstr));\n        tk-&gt;cmd(win,
    \"update\");\n\n        # update direction\n        case dir{\n            0 =&gt;\n
    \               cury--;\n            1 =&gt;\n                curx++;\n            2
    =&gt;\n                cury++;\n            3 =&gt;\n                curx--;\n
    \       }\n\n        # if it reaches edge, it stop\n        if((curx &lt; 0) ||
    (curx &gt;= width) || (cury &lt; 0) || (cury &gt;= height)){\n            break;\n
    \       }\n\n    }\n\n    # Window event loop?\n    for(;;) alt{\n        s :=
    &lt;-win.ctxt.kbd =&gt;\n            tk-&gt;keyboard(win, s);\n        s := &lt;-win.ctxt.ptr
    =&gt;\n            tk-&gt;pointer(win, *s);\n        s := &lt;-win.ctxt.ctl or\n
    \       s = &lt;-win.wreq or\n        s = &lt;-wmctl =&gt;\n            if(s ==
    \"exit\")\n                return;\n    }\n}\n"
  :tags:
  - Limbo
  :references:
    :url: /web/20100712030836/http://www.vitanuova.com/inferno/papers/descent.html
    :title: 'A Descent into Limbo '
- :id: '9438'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9438
  :user_name: noriscape
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1089/
  :language: Matlab
  :time: 2009/08/02 02:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  GNU Octave 3.0.1で動作確認\r<br>アリの行動履歴を3次元表示します。\n\t"
  :code: |
    world = zeros(100,100);
    dirs = [[0,-1];[1,0];[0,1];[-1,0]];
    posX = [60]; % X座標履歴
    posY = [40]; % Y座標履歴
    dir = 0;
    while posX(1) &gt; 0 &amp; posX(1) &lt;= 100 &amp; posY(1) &gt; 0 &amp; posY(1) &lt;= 100;
      if world(posX(1),posY(1)) == 1
        dir = mod(dir+1,4); % 右折
      else
        dir = mod(dir-1,4); % 左折
      end;
      world(posX(1),posY(1)) = abs(world(posX(1),posY(1))-1); % 白黒反転
      posX = [[posX(1)+dirs(dir+1,1)],posX]; % X方向の移動
      posY = [[posY(1)+dirs(dir+1,2)],posY]; % Y方向の移動
    end;
    plot3(posX,posY,length(posX):-1:1); % 軌跡表示 (Z軸:時間)
  :tags:
  - Octave
  :references:
    :url: 
    :title: 
- :id: '9457'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9457
  :user_name: uehaj
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/959/
  :language: Groovy
  :time: 2009/08/08 08:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>面白いですね。</p>\n\n\t"
  :code: |
    // 盤面の幅
    WIDTH=100
    HEIGHT=100

    // 盤面の値
    WHITE=0
    BLACK=1

    // 上下左右移動する際のリニア増減分
    UP_DIFF=-WIDTH
    RIGHT_DIFF=+1
    DOWN_DIFF=+WIDTH
    LEFT_DIFF=-1

    // 上下左右移動に対応するリニア増減分を保存してある配列
    direcVec=[UP_DIFF,RIGHT_DIFF,DOWN_DIFF,LEFT_DIFF]

    // 上下左右の方向を表す定数値
    UP=0
    RIGHT=1
    DOWN=2
    LEFT=3

    def move(x, y, dir) {
      def pos = x + y*WIDTH
      pos += direcVec[dir]
      if (! (pos in (0 ..&lt; WIDTH*HEIGHT))) {
        throw new Exception("over")
      }
      x = pos % WIDTH
      y = pos.intdiv(WIDTH)
      return [x, y]
    }

    def reverse(x, y) {
      def pos = x + y*WIDTH
      bd[pos] = -(bd[pos]-1)
    }

    def color(x, y) {
      def pos = x + y*WIDTH
      bd[pos]
    }

    def turnRight(dir) {
      (dir+1) % 4
    }

    def turnLeft(dir) {
      (dir-1) % 4
    }

    def displayBoard() {
      for (int y=0; y&lt;HEIGHT; y++) {
        for (int x=0; x&lt;WIDTH; x++) {
          print bd[x + y*WIDTH] == WHITE ? ' ' : '*'
        }
        println ""
      }
    }

    def doit() {
      def dir = RIGHT
      while (true) {
        def oldX=x
        def oldY=y
        if (color(x,y) == WHITE) { // 白なら右回転
          dir = turnRight(dir)
        }
        else { // 白ではないなら左回転
          dir = turnLeft(dir)
        }
        (x,y) = move(x,y,dir)
        reverse(oldX, oldY)
      }
    }

    // 盤面
    bd = new int[WIDTH*HEIGHT]

    // 画面の中央に配置
    x = WIDTH.intdiv(2)
    y = HEIGHT.intdiv(2)

    try {
      doit()
    }
    catch (Exception e) {
      displayBoard()
    }
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '9512'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9512
  :user_name: Wiles
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1094/
  :language: C
  :time: 2009/08/25 00:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">コマンドライン上で描写するので、フィールドが狭いですがギリギリ列の生成は確認できました。列が生成されるまで時間がかかったので100回の移動ごとに描写していますが、この辺は適宜変更してください。</pre>\n\t"
  :code: "#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define XMAX 75                                //フィールドの横幅\n#define
    YMAX 75                                //フィールドの縦幅\n#define CNTSPACE 100                        //描写間隔\n\nchar
    field[XMAX][YMAX];\n\nenum Direction {up, right, down, left};\n\nint main(void)\n{\n
    \   enum Direction dir;\n    int x, y, i, j, cnt = 0;\n    \n    for(i = 0; i
    &lt; XMAX; i++)                //0が白、1が黒なので全て白に初期化\n    {\n        for(j = 0;
    j &lt; YMAX; j++)\n        {\n            field[i][j] = 0;\n        }\n    }\n\n
    \   x = XMAX / 2;                            //フィールド中央からスタート\n    y = YMAX / 2;\n
    \   dir = up;                                //進行方向は上からスタート\n    \n    while((x
    &gt;= 0) &amp;&amp; (y &gt;= 0) &amp;&amp; (x &lt; XMAX) &amp;&amp; (y &lt; YMAX))\n
    \   {\n        cnt++;\n        if(field[x][y])\n        {\n            field[x][y]
    = 0;\n            if(dir == left)    dir = up;\n            else    dir++;\n        }\n
    \       else\n        {\n            field[x][y] = 1;\n            if(dir == up)
    \   dir = left;\n            else    dir--;\n        }\n        switch(dir)\n
    \       {\n            case up:    y++;        break;\n            case down:
    \   y--;        break;\n            case right:    x++;        break;\n            case
    left:    x--;        break;\n        }\n        if(cnt == CNTSPACE)\n        {\n
    \           system(\"cls\");\n            for(i = 0; i &lt; XMAX; i++)\n            {\n
    \               for(j = 0; j &lt; YMAX; j++)\n                {\n                    field[i][j]
    ? putchar('@') : putchar('_');\n                }\n                putchar('\\n');\n
    \           }\n            cnt = 0;\n        }\n    }\n    \n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9639'
  :parent_id: '276'
  :url: http://ja.doukaku.org/comment/9639
  :user_name: tsubo
  :user_url: /web/20100712030836/http://ja.doukaku.org/user/1106/
  :language: Scala
  :time: 2009/10/21 11:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Scalaで。春っぽい雰囲気にしてみました！？（季節を無視して）。ScalaどころかSwingアプリとしても拙い作りかもしれません。。。\npaintComponent内で結構ぐるぐる回してもいけるもんなんですね。もしかしたら、マシンパワーによっては表示が追いつかないのかもしれません。</p>\n\n\t"
  :code: |
    import scala.collection.mutable.ListBuffer
    import scala.concurrent.ops._
    import scala.swing._
    import scala.util._
    import java.awt.{Graphics, Dimension}

    trait AntWorld {
        protected val w:Int
        protected val h:Int
        protected def reflect
         var ants:List[Ant] = Nil
        lazy val table:List[Array[Int]] = List.tabulate(w, {_=&gt;Array.make(h,0)})
        private val r = new Random()
        def ant(c:Int) = new Ant(r.nextInt(w)/2+w/4, r.nextInt(h)/2+h/4, c)
        def antStart() = {
            spawn {
                while(true) {
                    ants.foreach {_.move}
                    reflect
                    Thread.sleep(1)
                }
            }
        }
        class Ant(var x:Int, var y:Int, c:Int) {
            private val rads = List((0,-1), (1,0), (0,1), (-1,0))
            private val (initX, initY) = (x, y)
            private var radi = 0
            def init = { x = initX; y = initY; radi = 0 }
            def move = {
                val v = table(x)(y)
                table(x)(y) = (if (v != 0) 0 else c)
                radi = (radi + (if (v != 0) 1 else 3) ) % 4
                x = (x + rads(radi)._1 + w) % w
                y = (y + rads(radi)._2 + h) % h
            }
        }
    }

    object LangtonAnt extends SimpleGUIApplication {
        import java.awt.Color
        val aSize = 5
        def top = new MainFrame {
            title = "Langton's Ant"
            val panel = new Panel() with AntWorld {
                def reflect = repaint
                val (w, h) = (100, 100)
                peer.setPreferredSize(new Dimension(w * aSize, h * aSize))
                override def paintComponent(g:Graphics) = {
                    super.paintComponent(g)
                    for (x &lt;- 0 until w; y &lt;- 0 until h) {
                        table(x)(y) match {
                            case 0 =&gt; g.setColor(Color.WHITE)
                            case c =&gt; g.setColor(new Color(c))
                        }
                        g.fillRect(x * aSize, y * aSize, aSize, aSize)
                    }
                }
                def clear = {
                    table.foreach { a =&gt; for (i &lt;- 0 until a.length) a(i) = 0 }
                }
                def reset = {
                    ants =
                        ant(Color.GREEN.getRGB) ::
                        ant(Color.PINK.getRGB) ::
                        ant(Color.BLUE.getRGB) ::
                        ant(Color.RED.getRGB) ::
                        ant(Color.CYAN.getRGB) ::
                        Nil
                    clear
                }
                def replay = {
                    this.synchronized {
                        ants.foreach( _.init )
                        clear
                    }
                }
                reset
            }
            contents = new BoxPanel(Orientation.Vertical ) {
                contents += new BoxPanel(Orientation.Horizontal ) {
                    contents += new Button(Action("Clear"){ panel.clear })
                    contents += new Button(Action("Replay"){ panel.replay })
                    contents += new Button(Action("Reset"){ panel.reset })
                }
                contents += panel
            }
            panel.antStart
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
