---
:id: '65'
:title: 格子点の列挙
:comments:
- :id: '3421'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3421
  :user_name: かも
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/67/
  :language: 
  :time: 2007/10/05 09:31 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\r\n\t  二次元平面上の格子点(X,Y座標がともに整数の点)を、原点から近い順に列挙してください。\r\n<p>\r\n同じ距離の点はどういう順番でも構いませんが、可能であればX軸に一番近い第一象限の点から原点を中心として反時計回りの順に列挙してください。\r\n列挙の方法は、1行に一つの点の、X,Y座標を出力することとします。\r\n</p>\n<p>\r\nサンプル出力\r\n</p>\n<pre>\r\n0,
    0\r\n1, 0\r\n0, 1\r\n-1, 0\r\n0, -1\r\n1, 1\r\n-1, 1\r\n1, -1\r\n-1, -1\r\n2,
    0\r\n</pre>\r\n<p>\r\n最低でも1000件まで列挙できることを確認してください。\r\nまた「反時計回り」の条件も満たしている場合は、1000番目の頂点が何かも併せて答えてください。\r\n</p>\n<p>\r\nこのお題はかもさんの投稿を元にしています。ご協力ありがとうございました。\r\n\t</p>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3607'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3607
  :user_name: ぴょん
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/490/
  :language: Perl
  :time: 2007/10/30 19:16 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\r\n\t  <pre class=\"compact\">Perl がなかったので。力技。</pre>\r\n\t"
  :code: |
    use strict;

    my $PI = atan2(1, 1) * 4;
    my $MAXR = int(sqrt(1000 / $PI) + sqrt(2) + 0.5);
    my @res = ();

    for (my $i = 0; $i &lt;= $MAXR; $i++) {
        for (my $j = 0; $j &lt;= $MAXR; $j++) {
            my $r = sqrt($i * $i + $j * $j);
            push(@res, [$i, $j, $r, atan2($j, $i)]);
            ($i != 0) &amp;&amp; push(@res, [-$i, $j, $r, atan2($j, -$i)]);
            ($j != 0) &amp;&amp; push(@res, [$i, -$j, $r, atan2(-$j, $i) + 2 * $PI]);
            ($i * $j != 0) &amp;&amp; push(@res, [-$i, -$j, $r, atan2(-$j, -$i) + 2 * $PI]);
        }
    }

    foreach my $p (sort {($a-&gt;[2] &lt;=&gt; $b-&gt;[2]) || ($a-&gt;[3] &lt;=&gt; $b-&gt;[3])} @res) {
        printf("%3d, %3d\n", splice(@{$p}, 0, 2));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3254'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3254
  :user_name: rubikitch
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/105/
  :language: Ruby
  :time: 2007/10/05 10:13 GMT
  :vote_count: '6'
  :vote_score: '-6'
  :body: "\n\t  <pre class=\"compact\">1000番目は[1250,-1250]かな？\r\n\r\n[[0, 0], [1,
    0], [0, 1], [-1, 0], [0, -1], [1, 1], [-1, 1], [-1, -1], ...]\r\n</pre>\n\t"
  :code: |
    def lattice(limit)
      ary = [[0,0]]
      i = 1
      n = 1
      while i &lt; limit
        ary &lt;&lt; [n,0] &lt;&lt; [0,n] &lt;&lt; [-n,0] &lt;&lt; [0,-n]
        ary &lt;&lt; [n,n] &lt;&lt; [-n,n] &lt;&lt; [-n,-n] &lt;&lt; [n,-n]
        i+=8
        n+=1
      end
      ary
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3255'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3255
  :user_name: にしお
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/10/05 10:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">ええと。\r\n[1, 2]が[2, 2]より近い格子点だと言うことを忘れていませんか？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3256'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3256
  :user_name: ocean
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/10/05 10:52 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">1000番目は(-8, 16)？Tkinterで視覚的に表示\r\nするコードもつけました。debug()という関数を\r\n実行してください。</pre>\n\t"
  :code: |
    import itertools

    def distance2(a):
        x, y = a
        return x * x + y * y

    def rotate_90(x, y):
        return -y, x

    def grid_points():
        yield (0, 0)
        def grid_points_in_first_quadrant():
            table = [] # index: y, value: x ( y &gt;= 0 and x &gt;= 1 )
            while 1:
                def candidates():
                    for y, x in enumerate(table):
                        yield x + 1, y
                    yield 1, len(table)
                x, y = min(candidates(), key=distance2)
                yield x, y
                if y &lt; len(table):
                    table[y] = x
                else:
                    assert y == len(table)
                    table.append(x)
        for _, it in itertools.groupby(grid_points_in_first_quadrant(), key=distance2):
            points = list(it)
            for _ in xrange(4):
                for x, y in points:
                    yield x, y
                for i in xrange(len(points)):
                    points[i] = rotate_90(*points[i])

    def debug(): # show points visually
        import Tkinter as Tk
        import math

        root = Tk.Tk()
        canvas = Tk.Canvas(root, width=400, height=400)
        canvas.pack(fill=Tk.BOTH, expand=True)

        def draw_point(x, y):
            y = -y
            n = 10
            m = 5
            offset = 200
            canvas.create_oval(x * n - m + offset, y * n - m + offset, x * n + m + offset, y * n + m + offset, fill="red")

        it = grid_points()
        def command():
            x, y = it.next()
            draw_point(x, y)
            print (x, y), math.hypot(x, y)

        button = Tk.Button(text="Next", command=command)
        button.pack(fill=Tk.X)

        root.mainloop()

    def main():
        for x, y in itertools.islice(grid_points(), 1000):
            print "%d, %d" % (x, y)
    #   debug()

    if __name__ == '__main__':
        main()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3257'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3257
  :user_name: tsekine
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/124/
  :language: Bash
  :time: 2007/10/05 12:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  1000番目は (-8, 16) だと思います。\r\n\r\n配列 x, y のダミーはかなり変ですが、もう直す気がしないのでそのままにしておきます。\n\t"
  :code: |
    #!/bin/bash

    set -ue

    FMT="%d, %d\n"

    print_lattice () {
      # distance^2
      local -i d
      # cache of square of integers
      local -ia scache=(0)
      # #scache
      local -i n_scache="${#scache[@]}"

      local -i i j
      local -ia x
      local -ia y

      for ((d = 0;; d++)); do
        # set dummy data(due to "set -u")
        x=(-1)
        y=(-1)

        if [ $d -gt ${scache[n_scache-1]} ]; then
          scache[n_scache++]=$(( n_scache * n_scache ))
        fi

        for ((i = n_scache-1; i &gt;= 0; i--)); do
          for ((j = 0; j &lt; n_scache; j++)); do
            if let "scache[i]+scache[j]-d"; then
              continue
            fi

            x=("${x[@]}" $i)
            y=("${y[@]}" $j)
          done
        done

        if [ ${#x[@]} -gt 1 ]; then
          # origin
          if ! let "x[1] + y[1]"; then
            printf "$FMT" 0 0
          fi
          # quadrant 1
          for ((i = 1; i &lt; ${#x[@]}; i++)); do
            if [ ${x[i]} -ne 0 ]; then
              printf "$FMT" ${x[i]} ${y[i]}
            fi
          done
          # quadrant 2
          for ((i = ${#x[@]} -1 ; i &gt; 0; i--)); do
            if [ ${y[i]} -ne 0 ]; then
              printf "$FMT" -${x[i]} ${y[i]}
            fi
          done
          # quadrant 3
          for ((i = 1; i &lt; ${#x[@]}; i++)); do
            if [ ${x[i]} -ne 0 ]; then
              printf "$FMT" -${x[i]} -${y[i]}
            fi
          done
          # quadrant 4
          for ((i = ${#x[@]} -1 ; i &gt; 0; i--)); do
            if [ ${y[i]} -ne 0 ]; then
              printf "$FMT" ${x[i]} -${y[i]}
            fi
          done
        fi
      done
    }

    print_lattice
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3258'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3258
  :user_name: koguro
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/438/
  :language: Scheme
  :time: 2007/10/05 12:34 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <pre class=\"compact\">無駄が多いですが、普通に解いてみました。\r\nところで、反時計回りだとサンプルの出力は以下のようになるべきでは?
    \ \r\n\r\n0, 0\r\n1, 0\r\n0, 1\r\n-1, 0\r\n0, -1\r\n1, 1\r\n-1, 1\r\n-1, -1\r\n1,
    -1\r\n2, 0\r\n※(1, -1)と(-1, -1)が逆のはず。\r\n\r\nちなみに1,000番目は -8, 16 です。</pre>\n\t"
  :code: |
    (use srfi-1)
    (use srfi-42)
    (use math.const)

    (define (make-point-list n)
      (let ((a (ceiling-&gt;exact (/ (sqrt (* 2 n)) 2))))
        (list-ec (: x (- a) (+ a 1)) (: y (- a) (+ a 1))
                 (make-rectangular x y))))

    (define (sort-point-list lst)
      (define (%angle z)
        (let1 t (angle z)
          (if (&lt; t 0)
              (+ (* 2 pi) t)
              t)))
      (sort lst (lambda (z1 z2)
                  (let ((r1 (magnitude z1))
                        (r2 (magnitude z2)))
                    (if (= r1 r2)
                        (&lt; (%angle z1) (%angle z2))
                        (&lt; r1 r2))))))

    (define (lattice-point-list n)
      (for-each (lambda (z)
                  (format #t "~d, ~d~%"
                          (inexact-&gt;exact (real-part z))
                          (inexact-&gt;exact (imag-part z))))
                (take (sort-point-list (make-point-list n)) n)))

    ;; (lattice-point-list 1000)を実行すると答えが出ます
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3260'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3260
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/10/05 14:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">xとyのループ範囲の計算方法を#3258から拝借しました(n2の値)。\r\nただし、なぜこうなるのかは理解できていません。\r\n</pre>\n\t"
  :code: |
    from math import sqrt

    def f0(x, y):
      return (0 if x &gt;= 0 else 1) if y &gt;= 0 else (2 if x &lt; 0 else 3)

    def f(a, b):
      return -1 if a[0] &lt; b[0] else 1 if a[0] &gt; b[0] else cmp(a[1], b[1]) if a[1] != b[1] else (-1 if a[2] &gt; b[2] else 1) if a[1] &lt;= 1 else (-1 if a[2] &lt; b[2] else 1)

    n = 1000
    n2 = int(sqrt(n * 2) / 2)

    l = [(sqrt(x**2 + y**2), f0(x, y), x, y) for x in range(-n2, n2+1) for y in range(-n2, n2+1)]

    for t in sorted(l, cmp=f)[:n]:
      print t[2], t[3]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3261'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3261
  :user_name: koguro
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/438/
  :language: 
  :time: 2007/10/05 14:20 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  簡単に説明すると、xとyが[-sqrt(n)/2, sqrt(n)/2]の範囲の正方形を考えた場合、その中の格子点の数はn個以上あります。\r<br><br>なので、この正方形の外接円内に含まれる格子点の数もn個以上あるはずです。よってこの円内に含まれる格子点を列挙して、ソートして最初のn個を表示すれば問題は解けます。\r<br><br>ただ、円内に含まれる格子点の列挙は面倒なので、この円に外接する正方形を考え、そこに含まれる格子点を列挙することで問題を解いています(ただし無駄が多くなる)。その正方形は x, yが[-sqrt(2n)/2, sqrt(2n)/2]となるので、#3258のような計算式となります。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3262'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3262
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/10/05 14:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">効率はよくないけど、ナイーブな実装\r\n1000番目(1-origin) は(-8,16)\r\n</pre>\n\t"
  :code: |
    grids :: [(Integer,Integer)]
    grids = concat [ f (x,y) | z &lt;- [0..], y &lt;- [0..z], x &lt;- [y..z], x^2+y^2==z ]
      where
        f (0,0)             = [(0,0)]
        f (x,0)             = [(x,0),(0,x),(-x,0),(0,-x)]
        f (x,y) | x == y    = [(x,y),(-x,y),(-x,-y),(x,-y)]
                | otherwise = [(x,y),(y,x),(-y,x),(-x,y),(-x,-y),(-y,-x),(y,-x),(x,-y)]

    {-
    *Main&gt; mapM_ print $ take 1000 $ grids
    (0,0)
    (1,0)
    (0,1)
    (-1,0)
    (0,-1)
    (1,1)
    (-1,1)
    (-1,-1)
    (1,-1)
    (2,0)
    ... 中略 ...
    (16,8)
    (8,16)
    (-8,16)               -- 1000番目(1-origin)
    *Main&gt;
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3263'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3263
  :user_name: sumim
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/10/05 14:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Squeak Smalltalk で。\r<br><br>1. 円形のブラシを描く機能（#dotOfSize:）があるので、これで描いた円形のドット数を数え（primCountBits）て、同心円内に列挙すべき格子点をすべて含む最少の矩形格子を探し、その x （もしくは y）の最大値（max）を求めます。\r<br><br>2. -max から max まで整数で、重複を許す二項の順列組み合わせを生成（asDigitsToPower: 2 do: [...]）し、それぞれの項目を x、y に持つ、ポイントオブジェクト（x@y）としてコレクション（points）に収めます。\r<br><br>3. pointsを、各要素の原点からの距離（r）、距離が同じなら x 軸となす角度（theta）の小さい順に並べ変えます。\r<br><br>4. 前から n 個をとり（first: n）、各ポイントの x、y を出力。終了後、ファイルを開いて表示（edit）し、最後の出力を結果として返して（^last）います。\n\t"
  :code: "| n count max out points last |\nn := 1000.\ncount := [:m | (Form dotOfSize:
    (m + 1 * 2)) primCountBits - (m + 1 * 4) + 1].\nmax := (1 to: Float infinity)
    detect: [:r | (count value: r) &gt;= n].\nout := FileStream forceNewFileNamed:
    'doukaku65.out.txt'.\npoints := OrderedCollection new: max * max.\n(max negated
    to: max) asDigitsToPower: 2 do: [:xy | points add: xy first @ xy second].\npoints
    := points asArray sort: [:a :b | a r &lt; b r or: [a r = b r and: [a theta &lt;
    b theta]]].\npoints := points first: n. \npoints do: [:pt | out nextPutAll: (last
    := '{1}, {2}' format: {pt x. pt y}); cr].\nout edit.\n^last   \"=&gt; '-8, 16'
    \"\n"
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '3264'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3264
  :user_name: kozima
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/10/05 15:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">格子点のリストを適当に生成しておいて、\r\n原点からの距離でソートすることで近い順に並べてます。\r\n反時計回りにはなってません。</pre>\n\t"
  :code: |
    (defun distance (point)
      (let ((x (first point)) (y (second point)))
        (+ (* x x) (* y y))))

    (defun list-lattice-points (n)
        (loop with a = (ceiling (sqrt (/ n 2)))
          for i from (- a) to a
          nconc (loop for j from (- a) to a collect (list i j)) into points
          finally (format t "~V{~{~D, ~D~}~%~}"
                          n (sort points #'&lt;= :key #'distance))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3265'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3265
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/10/05 15:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">前出のコードでは\r\n\r\n[ (x,y) | z &lt;- [0..], y
    &lt;- [0..z], x &lt;- [y..z], x^2 + y^2 == z ]\r\n\r\nで仰角０°から４５°の間で原点から近いほうから，かつ，仰角の小さい方か\r\nら格子点がならびます．上のコードでは
    y の上限 z になっていますが，これ\r\nは√(z/2)を超えない自然数であればよいはずで，手抜きした分，余分な値を\r\nチェックすることになってしまっています．\r\n\r\nこの部分を改良して，さらに
    monadic スタイルで書いたコードにしてみました．\r\n</pre>\n\t"
  :code: |
    import Control.Monad
    grids :: [(Integer,Integer)]
    grids = do { z &lt;- [0..]
               ; let z' = floor (sqrt (fromInteger z / 2))
               ; y &lt;- [0..z']
               ; x &lt;- [y..z]
               ; guard (x^2 + y^2 == z)
               ; f (x,y)
               }
      where
        f (0,0)             = [(0,0)]
        f (x,0)             = [(x,0),(0,x),(-x,0),(0,-x)]
        f (x,y) | x == y    = [(x,y),(-x,y),(-x,-y),(x,-y)]
                | otherwise = [(x,y),(y,x),(-y,x),(-x,y),(-x,-y),(-y,-x),(y,-x),(x,-y)]
  :tags:
  - Control.Monad
  :references:
    :url: 
    :title: 
- :id: '3266'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3266
  :user_name: kozima
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/10/05 15:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">距離の二乗を返してるから distance って関数名はちょっと嘘ですね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3267'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3267
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/10/05 16:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">詳細な説明ありがとうございます。\r\n\r\n私も先の投稿後、自分なりに考えてみました。\r\n\r\n最初は1000個のペアがあればいいのだから、\r\n　n
    = 1000\r\n　n2 = sqrt(n) / 2\r\nでいいかと考えましたが、この場合の最大値であるsqrt(2 * n2 ** 2)より小さくなる\r\n(x,
    0)あるいは(0, y)の組み合わせが存在するので\r\n　n2 = sqrt(2 * (sqrt(n) / 2) ** 2)\r\nとすべきで、変形すれば\r\n　n2
    = sqrt(n / 2)\r\nとなって、同じ結論になりました。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3268'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3268
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/10/05 16:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">x の上限も√z でいいはずだ。\r\nさらに効率アップ(って、最初からこう書くべきだった)\r\n</pre>\n\t"
  :code: "import Control.Monad\ngrids :: [(Integer,Integer)]\ngrids = do { z &lt;-
    [0..]\n           ; let z'  = floor (sqrt (fromInteger z / 2))\n           ; let
    z'' = floor (sqrt (fromInteger z)) \n           ; y &lt;- [0..z']\n           ;
    x &lt;- [y..z'']\n           ; guard (x^2 + y^2 == z)\n           ; f (x,y)\n
    \          }\n  where\n    f (0,0)             = [(0,0)]\n    f (x,0)             =
    [(x,0),(0,x),(-x,0),(0,-x)]\n    f (x,y) | x == y    = [(x,y),(-x,y),(-x,-y),(x,-y)]\n
    \           | otherwise = [(x,y),(y,x),(-y,x),(-x,y),(-x,-y),(-y,-x),(y,-x),(x,-y)]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3269'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3269
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/10/05 16:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">ユークリッド距離でなくても、距離の公理を満たせば distance と呼んでもいいんじゃないかしらん。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3271'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3271
  :user_name: yohei
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/415/
  :language: C
  :time: 2007/10/05 16:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">円周をたどって。1000個目は -8, 16。</pre>\n\t"
  :code: "#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid
    lattice(int num) {\n\tvector&lt;pair&lt;int, int&gt;&gt; v;\n\tvector&lt;pair&lt;int,
    int&gt;&gt;::iterator ite;\n\tint n = 1, r = 0, x_start = 0;\n\t\n\tif (num &lt;=
    0) return;\n\tcout &lt;&lt; \"0, 0\" &lt;&lt; endl;\n\n\twhile (n &lt; num) {\n\t\tif
    (r == x_start * x_start) ++x_start;\n\t\tint x = x_start;\n\t\tint y = 0;\n\t\tint
    next_r = x * x;\n\t\twhile (x &gt; 0) {\n\t\t\tint d = x * x + y * y;\n\t\t\tif
    (d &lt;= r) {\n\t\t\t\t++x; ++y;\n\t\t\t} else {\n\t\t\t\tif (d &lt; next_r) {\n\t\t\t\t\tv.clear();\n\t\t\t\t\tv.push_back(pair&lt;int,
    int&gt;(x, y));\n\t\t\t\t\tnext_r = d;\n\t\t\t\t} else if (d == next_r) {\n\t\t\t\t\tv.push_back(pair&lt;int,
    int&gt;(x, y));\n\t\t\t\t}\n\t\t\t\t--x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (ite =
    v.begin(); ite != v.end() &amp;&amp; n &lt; num; ++ite, ++n)\n\t\t\tcout &lt;&lt;
    ite-&gt;first &lt;&lt; \", \" &lt;&lt; ite-&gt;second &lt;&lt; endl;\n\t\tfor
    (ite = v.begin(); ite != v.end() &amp;&amp; n &lt; num; ++ite, ++n)\n\t\t\tcout
    &lt;&lt; -ite-&gt;second &lt;&lt; \", \" &lt;&lt; ite-&gt;first &lt;&lt; endl;\n\t\tfor
    (ite = v.begin(); ite != v.end() &amp;&amp; n &lt; num; ++ite, ++n)\n\t\t\tcout
    &lt;&lt; -ite-&gt;first &lt;&lt; \", \" &lt;&lt; -ite-&gt;second &lt;&lt; endl;\n\t\tfor
    (ite = v.begin(); ite != v.end() &amp;&amp; n &lt; num; ++ite, ++n)\n\t\t\tcout
    &lt;&lt; ite-&gt;second &lt;&lt; \", \" &lt;&lt; -ite-&gt;first &lt;&lt; endl;\n\n\t\tv.clear();\n\t\tr
    = next_r;\n\t}\n}\n\nint main(void) {\n\tlattice(1000);\n\treturn 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3272'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3272
  :user_name: satooM
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/424/
  :language: Haskell
  :time: 2007/10/05 16:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">0&lt;=x&lt;=yの格子点をn^2&lt;x^2+y^2&lt;=(n+1)^2の有限領域に切って、\r\nそこをソートしていきます。\r\nspan2は有限領域を切り出すために定義しました。\r\n(いい名前が思いつかなかった)\r\n\r\nいささか汚いのが不満ですが、投稿してしまいます。</pre>\n\t"
  :code: |
    import Data.List (nub, groupBy, sortBy)

    span2 :: (a -&gt; Bool) -&gt; ([a] -&gt; Bool) -&gt; [[a]] -&gt; ([[a]],[[a]])
    span2 p1 p2 zss = (xss, yss'++zss')
      where
        (yss,zss') = span p2 zss
        (xss,yss') = unzip $ map (span p1) yss

    ans = iter 0 triangle
      where
        triangle = [[(x,y,x*x+y*y) | x &lt;- [y..]] | y &lt;- [0..]]

        iter n zss = xs ++ iter (n+1) zss'
          where
            (yss,zss') = span2 p1 p2 zss
            p1 (_,_,d)       = d &lt;= n*n
            p2 ((_,y,_):xss) = y &lt;= ceiling (fromInteger n / sqrt 2)
            xs = concat
               $ map mirror
               $ groupBy (\(_,_,d1) (_,_,d2) -&gt; d1 == d2)
               $ sortBy (\(_,_,d1) (_,_,d2) -&gt; compare d1 d2)
               $ concat yss
            -- sortByが安定であることを仮定

        mirror = nub
               . starling (++) (reverse.r3)
               . starling (++) (reverse.r2)
               . starling (++) (reverse.r1)
               . map (\(x,y,_)-&gt;(x,y))
          where
            r1 = map (\(x,y) -&gt; (y,x))
            r2 = map (\(x,y) -&gt; (-x,y))
            r3 = map (\(x,y) -&gt; (x,-y))
            starling f g x = f x (g x)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3273'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3273
  :user_name: satooM
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/424/
  :language: 
  :time: 2007/10/05 17:24 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">fを作用させる以前に同距離にある点に関して、出力順がお題を満たしていない気がします。\r\n((5,0)と(4,3)
    など)</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3274'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3274
  :user_name: rucker
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/130/
  :language: PHP
  :time: 2007/10/05 18:09 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">(n,0) ～ (n,n)\r\nを配列に追加したら距離でソートして\r\n距離が n
    以下の部分を取り出して全周に展開して表示\r\n…を繰り返すことで n&lt;0x8000 あたりまで表示出来るはず。\r\nコードはとりあえず1000番目を越えたら止まる設定ですが…。\r\n1000番目は(-8,16)でした。\r\n\r\n最初配列の先頭から要素を取り出すのに
    array_shift を使ったら\r\n配列の残りのキーが0からの連番に上書きされてしまう事に気がつかなくて\r\n困ったことに。\r\n逆順にソートして
    array_pop なら良かったのか…。\r\n</pre>\n\t"
  :code: "&lt;?php\n$c=0;\nprintf(\"%4d: %4d,%4d\\n\",++$c,0,0);\n$a=array();\nfor($i=1;
    /*$i&lt;0x8000*/ $c&lt;=1000;++$i)\n{\tfor($j=0;$j&lt;=$i;++$j)\n\t\t$a[$i*$i+$j*$j][$i]=$j;\n\tksort($a);\n\tfor($d=$i*$i;key($a)&lt;=$d;)\n\t{\t$b=current($a);\n\t\tunset($a[key($a)]);\n\t\tforeach($b
    as $x =&gt; $y)\n\t\t{\tif($y &amp;&amp; $x!=$y)\n\t\t\t\t$b[$y]=$x;\n\t\t}\n\t\tkrsort($b);\n\t\tfor($j=0;$j&lt;4;++$j)\n\t\t{\tforeach($b
    as $x =&gt; $y)\n\t\t\t{\tif($j&amp;1) { $t=$x; $x=$y; $y=$t; }\n\t\t\t\tif(($j+1)&amp;2)
    $x=-$x;\n\t\t\t\tif($j&amp;2) $y=-$y;\n\t\t\t\tprintf(\"%4d: %4d,%4d\\n\",++$c,$x,$y);\n\t\t\t}\n\t\t}\n\t}\n}\n?&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3275'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3275
  :user_name: shg
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/383/
  :language: Matlab
  :time: 2007/10/05 19:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>求める個数を引数として与えると、格子点を行列を返す。最後の三行のコメントを外すと求めた格子点をグラフ上に表示する。\n</p>\n\n\n\n\t"
  :code: |
    function r = latticepointsaroundorigin(num)
    % r = latticepointssorted(n) retruns a list of lattice points,
    % in the order of  distance from the origin and polar angle.
    % Uncomment the last three lines to show the locations of the points.
    % (ja.doukaku.org Q65)
    rg = ceil(sqrt(num)/2);
    [x y] = meshgrid(-rg:rg);
    pts = [x(:) y(:) x(:).^2+y(:).^2 atan2(-y(:),-x(:))];
    r = sortrows(pts, [3,4]);
    r = r(1:num,1:2);
    % figure
    % axis([-rg rg -rg rg])
    % text(r(:,1),r(:,2),num2cell(1:num))
  :tags:
  - MATLAB7.5
  :references:
    :url: 
    :title: 
- :id: '3276'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3276
  :user_name: shg
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/383/
  :language: Matlab
  :time: 2007/10/05 20:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>範囲の計算が変なまま出してしまったので再投稿。\n</p>\n<p>同じく最後三行のコメントを外すと求めた格子点図示する。等距離の場合の順序をx軸を起点とした偏角の順にソートするという条件も満たしている。1000個目は
    [-8, 16]。\n</p>\n\n\n\n\t"
  :code: |
    function r = latticepointsaroundorigin(num)
    % r = latticepointssorted(n) retruns a list of lattice points,
    % in the order of  distance from the origin and polar angle.
    % Uncomment the last three lines to show the locations of the points.
    % (ja.doukaku.org Q65)
    rg = ceil(sqrt(num/pi));
    [x y] = meshgrid(-rg:rg);
    pts = [x(:) y(:) sqrt(x(:).^2+y(:).^2) atan2(-y(:),-x(:))];
    r = sortrows(pts, [3,4]);
    r = r(1:num,1:2);
    % figure
    % axis([-rg rg -rg rg])
    % text(r(:,1),r(:,2),num2cell(1:num))
  :tags:
  - MATLAB7.5
  :references:
    :url: 
    :title: 
- :id: '3277'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3277
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/10/06 01:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ああ。ご指摘のとおりです。\r\n結局仰角でsortすることにしてしまいました。\r\n</pre>\n\t"
  :code: "import Data.List\nimport Data.Complex\n\nbinapp o f x y = f x `o` f y\ncmpapp
    :: Ord b =&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; Ordering\ncmpapp = binapp compare\n\ngrid
    :: Integer -&gt; [(Integer,Integer)]\ngrid z = let z'  = floor $ sqrt (fromInteger
    z / 2)\n             z'' = floor $ sqrt (fromInteger z)\n         in  sortBy g
    $ concat [ f (x,y) | y &lt;- [0..z'], x &lt;- [y..z''], x^2+ y^2 == z ]\n  where
    \n    f (0,0)             = [(0,0)] \n    f (x,0)             = [(x,0),(0,x),(-x,0),(0,-x)]\n
    \   f (x,y) | x == y    = [(x,y),(-x,y),(-x,-y),(x,-y)]\n            | otherwise
    = [(x,y),(y,x),(-y,x),(-x,y),(-x,-y),(-y,-x),(y,-x),(x,-y)]\n    g = cmpapp (h
    . phase . uncurry (:+) . e)\n    h x = x + if x &lt; 0 then 2*pi else 0\n    e
    = uncurry (binapp (,) fromInteger)\n\ngrids :: [(Integer,Integer)]\ngrids = concatMap
    grid [0..]\n\n{-\n*Main&gt; mapM_ print $ take 1000 $ grids\n(0,0)\n(1,0)\n(0,1)\n(-1,0)\n(0,-1)\n(1,1)\n(-1,1)\n(-1,-1)\n(1,-1)\n(2,0)\n...
    中略 ...\n(16,8)\n(8,16)\n(-8,16)                      -- 1000番目(1-origin)\n*Main&gt;\n-}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3278'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3278
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/10/06 03:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ソート用比較関数を見直し。\r\n\r\n1000番目の座標は他の人と同じく(-8,
    16)になりました。\r\n</pre>\n\t"
  :code: |
    from math import sqrt

    def f((x0, y0, z0), (x1, y1, z1)):
      if z0 &lt; z1: return -1
      if z0 &gt; z1: return 1
      if y0 &gt;= 0:
        if y1 &lt; 0 or x0 &gt; x1: return -1
      else:
        if y1 &lt; 0 and x0 &lt; x1: return -1
      return 1

    n = 1000
    n2 = int(sqrt(n / 2))

    l = [(x, y, sqrt(x**2 + y**2)) for x in range(-n2, n2+1) for y in range(-n2, n2+1)]

    for x, y, z in sorted(l, cmp=f)[:n]:
      print x, y
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3279'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3279
  :user_name: kozima
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/10/06 06:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">それはそうなんですが、二乗すると三角不等式が成り立っていないという。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3280'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3280
  :user_name: nobsun
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/10/06 06:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">そうでした、(1/2)^2+(1/2)^2 &lt; 1^2 ですもんね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3282'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3282
  :user_name: kenaxt
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/456/
  :language: Ruby
  :time: 2007/10/06 11:58 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">距離、反時計回り（0-360°）の順にソートするために、setOrder(x,y)中で、角度/360を小数部にセットしています。</pre>\n\t"
  :code: |
    include Math

    def gridPoint(limit)
      r = []
      n = sqrt(2*limit).to_i / 2 #--- search square size
      (-n..n).each {|x|
        (-n..n).each {|y|
          r &lt;&lt; [x, y]
        }}
      r.sort_by {|x, y|setOrder(x, y)}
    end

    def setOrder(x,y)
      deg = atan2(y, x) * 180 / PI
      deg += 360 if deg &lt; 0   #--- degree correct
      x**2 + y**2 + deg / 360 #--- distance + degree/360
    end

    limit = 1000
    k = gridPoint(limit)
    (0..limit).each {|i|
      p k[i]
    }
  :tags:
  - Ruby1.8.5
  :references:
    :url: 
    :title: 
- :id: '3283'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3283
  :user_name: kozima
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/10/06 13:55 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">探索範囲を狭めました。\r\nついでに反時計回りになるようにしました。\r\n\r\n評価の方法ですが、\r\n円内の格子点に正方形を対応させると円の被覆ができるので、\r\nこれを使って格子点の数を円の面積で見積もるというのが大まかな方針です。\r\n\r\n細かい計算は以下。\r\n軸の周りで一対一対応にならなくてややこしいことになってます。\r\n\r\nC:
    原点を中心とする半径 r の閉円板\r\nf: 単位正方形に対し、その頂点のうち最も原点に近いものを対応させる写像\r\n\r\nC に属する格子点の数を
    K とすると、\r\nf による像が C に入っているような単位正方形の数は\r\n 原点に写るものが 4 個\r\n 原点以外で軸上に写るものが 8r 個\r\n
    それ以外の点に写るものが K-4r-1 個\r\n合わせて K+4r+3 個となります。\r\nこれらの単位正方形の和集合を S とします。\r\n\r\nC
    は S の部分集合なので、S の面積は C の面積以上になります。\r\nS は K+4r+3 個の単位正方形からなるので、その面積は K+4r+3 です。\r\nまた
    C の面積は pi*r^2 なので\r\npi*r^2 &lt;= K + 4r + 3\r\nが得られます。K が格子点の数だったので、格子点は少なくとも\r\npi*r^2
    - 4r -3 個以上あることがわかります。\r\n\r\nというわけで、格子点の数が n 以上となる半径 r を見つけるには\r\npi*r^2 - 4r
    - 3 &gt;= n\r\nを解けばよく、その結果\r\nr &gt;= (sqrt(4 + (3 + n) * pi) + 2) / pi\r\nとなります。</pre>\n\t"
  :code: |
    (defun point&lt; (p1 p2)
      (destructuring-bind ((x1 y1) (x2 y2)) `(,p1 ,p2)
         (let ((a1 (+ (* x1 x1) (* y1 y1)))
               (a2 (+ (* x2 x2) (* y2 y2))))
           (or (&lt; a1 a2)
               (and (= a1 a2)
                    (if (&gt;= y1 0)
                        (or (&gt; 0 y2) (&gt; x1 x2))
                      (and (&gt; 0 y2) (&lt; x1 x2))))))))

    (defun list-lattice-points (n)
      (loop with a = (ceiling (/ (+ (sqrt (+ 4 (* (+ 3 n) pi))) 2) pi))
        for i from (- a) to a
        nconc (loop with b = (floor (sqrt (- (* a a) (* i i))))
                for j from (- b) to b collect (list i j)) into points
        finally (format t "~V{~{~D, ~D~}~%~}"
                        n (sort points #'point&lt;))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3284'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3284
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/10/07 03:04 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  なんか旨い方法はないかと思っていたのですが、結局、普通の方法になってしまいました。その代わり反時計回りの条件を満たしています。\r<br><br>1000個目は\r<br>-8, 16\r<br>です。\r<br><br>ちなみに、最初の10個（反時計回り）は\r<br>0, 0\r<br>1, 0\r<br>0, 1\r<br>-1, 0\r<br>0, -1\r<br>1, 1\r<br>-1, 1\r<br>-1, -1\r<br>1, -1\r<br>2, 0\r<br>になります。\n\t"
  :code: |
    import java.util.*;

    public class Sample {
        public static void main(String[] args) {
            ArrayList&lt;Point&gt; lattice = new ArrayList&lt;Point&gt;();
            for (int x = -20; x &lt;= 20; x++) {
                for (int y = -20; y &lt;= 20; y++) {
                    lattice.add(new Point(x, y));
                }
            }
            Collections.sort(lattice);
            int count = 0;
            for (Point p : lattice) {
                System.out.printf("%d, %d%n", p.x, p.y);
                if (++count &gt;= 1000)
                    break;
            }
        }
    }

    class Point implements Comparable&lt;Point&gt; {
        int x, y;
        int abs2;
        double theta;
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
            abs2 = x * x + y * y;
            theta = Math.atan2(y, x);
            if (theta &lt; 0) theta += 2*Math.PI;
        }
        public int compareTo(Point p) {
            if (this.abs2 != p.abs2) {
                return this.abs2 - p.abs2;
            } else {
                return Double.compare(this.theta, p.theta);
            }
        }
        public String toString() {
            return "(" + x + ", " + y + "):" + abs2;
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3286'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3286
  :user_name: fkmn
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/190/
  :language: SQL
  :time: 2007/10/07 09:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">MySQL 限定。\r\n最初に整数の組み合わせを作ってしまってから、\r\nそれをソートしています。\r\n\r\n1000番目は
    (-8, 16) と出ました。\r\n</pre>\n\t"
  :code: "DROP TABLE IF EXISTS digits;\nCREATE TABLE digits(n INTEGER PRIMARY KEY);\nINSERT
    INTO digits VALUES(0), (1), (2), (3), (4), (5), (6), (7), (8), (9);\n\nDROP TABLE
    IF EXISTS integers;\nCREATE TABLE integers\nSELECT n \nFROM ( SELECT a.n + (b.n
    * 10) AS n FROM digits a, digits b\n        UNION\n       SELECT - (a.n + (b.n
    * 10)) AS n FROM digits a, digits b) a;\n\nSET @r = 0;\nSELECT x, y\n  FROM (
    SELECT a.n AS x\n              , b.n AS y\n              , a.n * a.n + b.n * b.n
    AS magnitude\n              , atan(b.n, a.n) + CASE WHEN atan(b.n, a.n) &lt; 0\n
    \                                     THEN 2 * pi()\n                                      ELSE
    0 END AS angle\n              , (@r := @r + 1) AS row   \n           FROM integers
    a, integers b\n       ORDER BY magnitude, angle) c\n WHERE row &lt;= 1000;\n"
  :tags:
  - MySQL
  :references:
    :url: 
    :title: 
- :id: '3287'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3287
  :user_name: gemma
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/461/
  :language: 
  :time: 2007/10/07 21:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">r≦√(n/2), 0°≦Θ≦45°の格子点を計算して、それを平面に8回、正方形のピザのように貼りつけると、見積もるべき格子点のリストができる。\r\nそれを原点からの距離で安定ソートする。\r\n安定ソートで8回貼りつけたときの順番が保たれるので、仰角での順序付けを前もってやったことになる。\r\n1000番めは同じく
    (-8 . 16)</pre>\n\t"
  :code: ''
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3288'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3288
  :user_name: gemma
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/461/
  :language: Scheme
  :time: 2007/10/07 21:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "(use srfi-1)\n\n(define (test n)\n  (take (stable-sort (append-map (lambda
    (x)\n                                   (append-map (lambda (y)\n                                                 (cond
    \n                                                  ((and (zero? x) (zero? y))\n
    \                                                  (list (cons x y)))\n                                                  ((zero?
    x)\n                                                   (list (cons x y)\n                                                         (cons
    y x)\n                                                         (cons (- y) x)\n
    \                                                        (cons x (- y))))\n                                                  ((zero?
    y)\n                                                   (list (cons x y)\n                                                         (cons
    y x)\n                                                         (cons (- x) y)\n
    \                                                        (cons y (- x))))\n                                                  ((eq?
    x y)\n                                                   (list (cons x y)\n                                                         (cons
    (- y) x)\n                                                         (cons (- x)
    (- y))\n                                                         (cons y (- x))))\n
    \                                                 (else \n                                                   (list
    (cons x y)\n                                                         (cons y x)\n
    \                                                        (cons (- y) x)\n                                                         (cons
    (- x) y)\n                                                         (cons (- x)
    (- y))\n                                                         (cons (- y) (-
    x))\n                                                         (cons y (- x))\n
    \                                                        (cons x (- y))))))\n
    \                                              (iota (+ x 1))))\n                                 (iota
    (+ 1 (inexact-&gt;exact (ceiling (* (sqrt 2) (quotient (inexact-&gt;exact (ceiling
    (sqrt n))) 2)))))))\n                     (lambda (p0 p1)\n                       (&lt;
    (+ (expt (car p0) 2) (expt (cdr p0) 2))\n                          (+ (expt (car
    p1) 2) (expt (cdr p1) 2))))) n))\n\n(for-each print (test 1000))\n"
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3289'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3289
  :user_name: kozima
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/10/07 23:51 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">#3273 でも出てますが、これだと (4 . 3) が (5 . 0) より先になりません？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3290'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3290
  :user_name: kenaxt
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/456/
  :language: Ruby
  :time: 2007/10/08 04:10 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">あえて三角関数atan2を使わずに、n象限の点に評価値n.xxx(xxx=0〜1未満)を設定。</pre>\n\t"
  :code: |
    include Math

    def gridPoint(limit, r = [])
      n = sqrt(2 * limit).to_i / 2 #--- search square size
      (-n..n).each {|x|
        (-n..n).each {|y|
          r &lt;&lt; [x, y]
        }}
      r.sort_by {|x, y|setOrder(x, y)}
    end

    def setOrder(x, y, r = 1)
      while (x &lt;= 0 || y &lt; 0) &amp;&amp; ([x, y] != [0, 0])
        x, y = y, -x
        r += 1
      end
      (r += y / (x + y + 1.0)) / 4 + (x**2 + y**2)
    end

    limit = 1000
    p gridPoint(limit)[limit - 1] # -&gt; [-8, 16]
  :tags:
  - Ruby1.8.5
  :references:
    :url: 
    :title: 
- :id: '3291'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3291
  :user_name: gemma
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/461/
  :language: Scheme
  :time: 2007/10/08 05:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ご指摘のとおりです。\r\n反時計回りに何枚目のピザカットかを保存するようにしました。\r\nこれならatan使ったほうがいいでしょう。\r\nピザカット戦略はろくなことがないと、うちの祖母も言ってました。</pre>\n\t"
  :code: "(use srfi-1)\n\n(define (test n)\n  (define R (+ 1 (inexact-&gt;exact (ceiling
    (* (sqrt 2) (quotient (inexact-&gt;exact (ceiling (sqrt n))) 2))))))\n  (take
    (stable-sort (append-map (lambda (y)\n                                   (append-map
    (lambda (x)\n                                                 (cond \n                                                  ((and
    (zero? x) (zero? y))\n                                                   (list
    (list x y 0)))\n                                                  ((zero? x)\n
    \                                                  (list (list x y 0)\n                                                         (list
    y x 2)\n                                                         (list (- y) x
    4)\n                                                         (list x (- y) 6)))\n
    \                                                 ((zero? y)\n                                                   (list
    (list x y 0)\n                                                         (list y
    x 2)\n                                                         (list (- x) y 4)\n
    \                                                        (list y (- x) 6)))\n
    \                                                 ((eq? x y)\n                                                   (list
    (list x y 1)\n                                                         (list (-
    y) x 3)\n                                                         (list (- x)
    (- y) 5)\n                                                         (list y (-
    x) 7)))\n                                                  (else \n                                                   (list
    (list x y 0)\n                                                         (list y
    x 1)\n                                                         (list (- y) x 2)\n
    \                                                        (list (- x) y 3)\n                                                         (list
    (- x) (- y) 4)\n                                                         (list
    (- y) (- x) 5)\n                                                         (list
    y (- x) 6)\n                                                         (list x (-
    y) 7)))))\n                                               (iota (- R y) y)))\n
    \                                (iota R))\n                     (lambda (p0 p1)\n\t\t
    \      (let ((r0 (+ (expt (car p0) 2) (expt (cadr p0) 2)))\n\t\t\t     (r1 (+
    (expt (car p1) 2) (expt (cadr p1) 2))))\n\t\t\t (if (= r0 r1)\n\t\t\t     (&lt;
    (caddr p0) (caddr p1))\n\t\t\t     (&lt; r0 r1))))) n))\n\n(for-each (lambda (x)\n\t
    \   (print (take x 2)))\n\t  (test 1000))\n"
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3292'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3292
  :user_name: naranja
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/448/
  :language: D
  :time: 2007/10/08 08:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ソートを自前で実装したので長くなってます。</pre>\n\t"
  :code: |
    import std.stdio;
    import std.math;

    void main(){
        uint n = 1000;
        uint r = cast(uint)ceil(sqrt(n / 2.0));
        int[][] gridPoints = [[0, 0]];

        for(uint y; y &lt;= r; y++){
            for(uint x = 1; (x * x + y * y) &lt;= r * r; x++){
                gridPoints ~= [[x, y], [-y, x], [-x, -y], [y, -x]];
            }
        }

        gridPoints.qsort();

        foreach(e; gridPoints){
            writefln(e);
        }

        writefln(n, ": ", gridPoints[n - 1]);
    }

    void qsort(int[][] array){
        if(array.length &lt; 2) return;

        void swap(uint i, uint j){
            int[] tmp = array[i].dup;
            array[i] = array[j].dup;
            array[j] = tmp;
        }
        int cmp(int[] a, int[] b){
            if(squareDistance(a) == squareDistance(b)){
                real arctanDiff = arctan(a) - arctan(b);
                if(arctanDiff &gt; 0) return 1;
                else if(arctanDiff &lt; 0) return -1;
            }
            else{
                return squareDistance(a) - squareDistance(b);
            }
            return 0;
        }

        uint left = 0;
        uint right = array.length - 1;
        while(true){
            while(cmp(array[left], array[0]) &lt; 0) left++;
            while(cmp(array[0], array[right]) &lt; 0) right--;
            if(right &lt;= left) break;
            swap(left++, right--);
        }
        qsort(array[0..left]);
        qsort(array[(right + 1)..length]);
    }

    int squareDistance(int[] grid){
        return grid[0] * grid[0] + grid[1] * grid[1];
    }

    real arctan(int[] grid){
        real arctan = atan2(grid[1], grid[0]);
        if(arctan &lt; 0) arctan += PI * 2;
        return arctan;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3293'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3293
  :user_name: gemma
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/461/
  :language: Scheme
  :time: 2007/10/08 09:00 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">0≦x,y≦√(n/2)\r\nの範囲に限って列挙してから、xy軸ごとの対称性を利用する。</pre>\n\t"
  :code: |
    (use srfi-1)

    (define (test n)
      (define R (inexact-&gt;exact (ceiling (* (sqrt 2)
                                            (quotient
                                             (inexact-&gt;exact (ceiling (sqrt n)))
                                             2)))))
      (define h (make-hash-table 'eq?))
      (for-each (lambda (y)
                  (for-each (lambda (x)
                              (hash-table-push! h (+ (expt x 2) (expt y 2)) (cons x y)))
                            (iota R 1)))
                (iota (+ R 1) R -1))
      (for-each (lambda (key)
                  (hash-table-update! h key (lambda (x)
                                              (append
                                               x
                                               (map (lambda (p)
                                                      (cons (- (cdr p)) (car p)))
                                                    x)
                                               (map (lambda (p)
                                                      (cons (- (car p)) (- (cdr p))))
                                                    x)
                                               (map (lambda (p)
                                                      (cons (cdr p) (- (car p))))
                                                    x)))))
                (hash-table-keys h))
     (take (acons 0 0 (append-map cdr (sort (hash-table-map h cons)
                                            (lambda (p0 p1)
                                              (&lt; (car p0) (car p1))))))
           n))

    (for-each print (test 1000))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3296'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3296
  :user_name: matyr
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/10/08 18:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t   原点からの距離(の二乗)と角度でソート。\r<br> これだけだと二番煎じなので，出力をドリトルのソース(実行するとカメが格子点を辿る)にしてみました。\n\t"
  :code: |
    function doukaku65(n){
      with(Math) for(var p = [], i = 0, m = sqrt(n/2)|0, y, x = -m; x &lt;= m; x++) for(y = -m; y &lt;= m; y++)
        (p[i++] = [x, y]).keys = [x*x + y*y, atan(y/x) + PI * (x &lt; 0 ? 1 : y &lt; 0 ? 2 : 0)];
      return p.sort(function(a, b){ return a.keys[0] - b.keys[0] || a.keys[1] - b.keys[1] }).splice(0, n);
    }
    var i = 1000;
    (this.print || this.WSH &amp;&amp; function($){ WSH.echo($) } || this.document &amp;&amp; document.write)
      ('//&lt;pre&gt;\n'+
       '亀＝タートル！作る 1 線の太さ。'+
       '点＝配列！\n'+ doukaku65(i).join('\n').replace(/,/g, ' ') +'\n作る。'+
       'タイマー！作る '+ 1/i +' 間隔 '+ i + ' 回数'+
       '「｜回｜亀！((点！(回＊２－１)見る)＊10)((点！(回＊２)見る)＊10)位置」実行。'+
       '\n//&lt;/pre&gt;');
  :tags:
  - Dolittle
  :references:
    :url: /web/20100612150759/http://dolittle.eplang.jp/
    :title: 'プログラミング言語「ドリトル」 '
- :id: '3299'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3299
  :user_name: ところてん
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/166/
  :language: Python
  :time: 2007/10/08 23:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">やってることは他の人とほとんど同じだけど、\r\nとりあえず綺麗に書いたつもり。\r\nVBAで仕事した直後で、ループ範囲が混乱したｗ\r\nちなみに1000番目は(-8,
    16)でした</pre>\n\t"
  :code: "import math\n\ndef test(r):\n    data = []\n    for y in range(-r,r+1):\n
    \       for x in range(-r,r+1):\n            data.append([x**2 + y **2, x,y])\n\n
    \   def cmp(p1,p2):\n        def toInt(d):\n            if d&lt;0:\n                return
    -1\n            if d&gt;0:\n                return 1\n            return 0\n            \n
    \       if p1[0] != p2[0]:\n            return toInt(p1[0] - p2[0])\n        t1
    = math.atan2(p1[2], p1[1])\n        t2 = math.atan2(p2[2], p2[1])\n        if
    t1 &lt; 0:\n            t1 += math.pi*2\n        if t2 &lt; 0:\n            t2
    += math.pi*2\n        return toInt(t1 - t2)\n\n    data.sort(cmp)\n\n    if len(data)&gt;
    1000 :\n        print \"No.1000 is\" ,data[1000-1]\n    for pos in data:\n        print
    pos[1],pos[2]\n\ntest(100)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3302'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3302
  :user_name: katsu
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/117/
  :language: Scheme
  :time: 2007/10/09 18:01 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">1. bufにはソート済みの点が入っていて、\r\n  距離n以上の点はまだ追加される可能性があります。\r\n
    \ （距離n未満の点は追加される可能性がないので出力しても良い)\r\n\r\n2. bufが空になるか、n未満の距離の点が無くなったら、\r\n  bufに(-n,-n)...(-n,n)...(n,n)...(n,-n)...と辺上の点を追加します。\r\n
    \ これらの点で一番距離が近い物はnとなります。\r\n  bufは距離と角度でソートし、nは一つ増やします。\r\n\r\nという感じで。\r\n\r\n1000番目は(-8
    16)になります。</pre>\n\t"
  :code: |
    (use util.match)
    (use srfi-42)

    (define pi (atan 0 -1))

    (define point
      (let ((buf '((0 0 0 0)))
            (n 1))
        (define (dist x y)
          (sqrt (+ (* x x) (* y y))))
        (define (deg x y)
          (let1 d0 (atan y x) (if (negative? d0) (+ d0 (* pi 2)) d0)))
        (define cmp (match-lambda* (((dis1 deg1 . _) (dis2 deg2 . _))
                      (if (= dis1 dis2) (&lt; deg1 deg2) (&lt; dis1 dis2)))))
        (define (points)
          (append (append-ec (: i (- 1 n) n) `((,i ,n) (,i ,(- n))
                                               (,n ,i) (,(- n) ,i)))
                  `((,n ,n) (,(- n) ,n) (,n ,(- n)) (,(- n) ,(- n)))))
        (define (fetch-p)
          (set! buf (sort!
                      (append buf
                        (map (match-lambda ((x y)
                               (list (dist x y) (deg x y) x y)))
                             (points)))
                      cmp))
          (inc! n))
        (lambda ()
          (when (or (null? buf) (&lt; n (caar buf))) (fetch-p))
          (pop! buf))))

    (define (main args)
      (dotimes (i 1000)
        (print (cddr (point)))))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3305'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3305
  :user_name: matarillo
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/136/
  :language: C
  :time: 2007/10/10 12:22 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  <pre class=\"compact\">1000個目は(-8. 20)で合ってる？</pre>\n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    using System.Text;

    namespace ConsoleApplication1
    {
      class Program
      {
        static void Main(string[] args)
        {
          SortedList&lt;LatticePoint, LatticePoint&gt; list = new SortedList&lt;LatticePoint, LatticePoint&gt;();
          LatticePoint origin = new LatticePoint(0, 0);
          list.Add(origin, origin);
          int count = 0;
          while (count &lt; 1000)
          {
            LatticePoint point = list.Keys[0];
            list.RemoveAt(0);
            foreach (LatticePoint p in point.GetRotatedPoints())
            {
              Console.WriteLine("{0}: {1}", ++count, p);
            }
            foreach (LatticePoint p in point.GetNeighborhood())
            {
              if (!(list.ContainsKey(p)))
              {
                list.Add(p, p);
              }
            }
          }
          Console.ReadKey();
        }
      }
      struct LatticePoint : IEquatable&lt;LatticePoint&gt;, IComparable&lt;LatticePoint&gt;
      {
        public int X;
        public int Y;
        public LatticePoint(int x, int y)
        {
          this.X = x;
          this.Y = y;
        }
        public override string ToString()
        {
          return string.Format("{0}, {1}", X, Y);
        }
        public override bool Equals(object obj)
        {
          if (!(obj is LatticePoint))
          {
            return false;
          }
          return Equals((LatticePoint)obj);
        }
        public bool Equals(LatticePoint p)
        {
          return (p.X == X) &amp;&amp; (p.Y == Y);
        }
        public override int GetHashCode()
        {
          return X.GetHashCode() * 31 + Y.GetHashCode();
        }
        public static bool operator ==(LatticePoint p1, LatticePoint p2)
        {
          return p1.Equals(p2);
        }
        public static bool operator !=(LatticePoint p1, LatticePoint p2)
        {
          return !p1.Equals(p2);
        }
        public long SquaredSum
        {
          get
          {
            long x2 = (long)X * (long)X;
            long y2 = (long)Y * (long)Y;
            return x2 + y2;
          }
        }
        public int CompareTo(LatticePoint other)
        {
          return (int)(this.SquaredSum - other.SquaredSum);
        }
        public IEnumerable&lt;LatticePoint&gt; GetNeighborhood()
        {
          yield return new LatticePoint(X + 1, Y);
          if (X &gt; Y)
          {
            yield return new LatticePoint(X, Y + 1);
          }
        }
        public LatticePoint RotateSquare()
        {
          return new LatticePoint(-Y, X);
        }
        public IEnumerable&lt;LatticePoint&gt; GetRotatedPoints()
        {
          if ((X == 0) &amp;&amp; (Y == 0))
          {
            yield return this;
            yield break;
          }
          LatticePoint p = this;
          LatticePoint f = new LatticePoint(Y, X);
          LatticePoint r = this.RotateSquare();
          bool withFlip = ((p != f) &amp;&amp; (f != r));
          for (int i = 0; i &lt; 4; i++)
          {
            yield return p;
            p = p.RotateSquare();
            if (withFlip)
            {
              yield return f;
              f = f.RotateSquare();
            }
          }
        }
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3307'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3307
  :user_name: matarillo
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/136/
  :language: 
  :time: 2007/10/10 12:35 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">間違ってますね。CompareToの返す値が不正。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3309'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3309
  :user_name: yuin
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/10/11 07:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>短めに。\n</p>\n\n\n\n\t"
  :code: |
    import scala.util.Sorting.stableSort
    import java.lang.Math.{sqrt,PI,pow,atan2}

    def lat(limit:int) = {
      type Coord = Pair[int,int]
      var i = sqrt(2*(limit-1)).toInt / 2
      stableSort((List[Coord]() /: (-i to i)){(lst, x) =&gt;
        (lst /: (-i to i)){(lst2, y) =&gt; (x,y)::lst2}
        }, {p:Coord =&gt; p match {case (x,y) =&gt;
        pow(x,2) + pow(y,2) +
        ((d:double)=&gt;{if(d&lt;0){d+360}else{d}})(atan2(y,x)*180/PI)/360
      }}){v=&gt;v}
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3313'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3313
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2007/10/12 17:37 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">#3312 はログインせずに投稿していました。投稿し直し。\r\n---\r\n\r\nHaskell
    でラマヌジャン数を小さい順に列挙するときなどに\r\n使われる手法を用いています。\r\n</pre>\n\t"
  :code: |
    import List (groupBy)

    main = mapM_ print
      $ ((0,0):)
      $ concat
      $ map (rotate . map fst)
      $ groupBy (\(_,d1) (_,d2) -&gt; d1 == d2)
      $ msort [[((x,y),x^2+y^2)| x &lt;- [1..]] | y &lt;- [0..]]

    msort ((z:zs):zss) = z: fsort zs (msort zss)
    fsort zs@(z@(_,d1):zs') ws@(w@(_,d2):ws')
      | d1 &lt;= d2 = z: fsort zs' ws
      | d1 &gt;  d2 = w: fsort zs  ws'

    rotate zs = zs' ++ map (\(x,y) -&gt; (-x,-y)) zs' where
      zs' = zs ++ map (\(x,y) -&gt; (-y,x)) zs
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3314'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3314
  :user_name: satooM
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/424/
  :language: 
  :time: 2007/10/12 23:44 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">美しい…。感動しました。\r\n\r\n蛇足ですが、8行目を\r\n  $ tail
    $ msort [[((x,y),x^2+y^2)| x &lt;- [y..]] | y &lt;- [0..]]\r\n\r\nrotateを\r\nrotate
    zs = zs''' where\r\n  zs'   = zs   ++ reverse [(y,x) | (x,y) &lt;- zs, y /= 0,
    x /= y]\r\n  zs''  = zs'  ++ map (\\(x,y) -&gt; (-y,x)) zs'\r\n  zs''' = zs''
    ++ map (\\(x,y) -&gt; (-x,-y)) zs''\r\n\r\nとすると高速化が図れますね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3467'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3467
  :user_name: matarillo
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/136/
  :language: C
  :time: 2007/10/19 10:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">CompareTo()を修正したので、1000番目は(-8, 16)になりました。\r\n</pre>\n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    using System.Text;

    namespace ConsoleApplication1
    {
      class Program
      {
        static void Main(string[] args)
        {
          SortedList&lt;LatticePoint, LatticePoint&gt; list = new SortedList&lt;LatticePoint, LatticePoint&gt;();
          LatticePoint origin = new LatticePoint(0, 0);
          list.Add(origin, origin);
          int count = 0;
          while (count &lt; 1000)
          {
            LatticePoint point = list.Keys[0];
            list.RemoveAt(0);
            foreach (LatticePoint p in point.GetRotatedPoints())
            {
              Console.WriteLine("{0}: {1}", ++count, p);
            }
            foreach (LatticePoint p in point.GetNeighborhood())
            {
              if (!(list.ContainsKey(p)))
              {
                list.Add(p, p);
              }
            }
          }
          Console.ReadKey();
        }
      }
      struct LatticePoint : IEquatable&lt;LatticePoint&gt;, IComparable&lt;LatticePoint&gt;
      {
        public int X;
        public int Y;
        public LatticePoint(int x, int y)
        {
          this.X = x;
          this.Y = y;
        }
        public override string ToString()
        {
          return string.Format("{0}, {1}", X, Y);
        }
        public override bool Equals(object obj)
        {
          if (!(obj is LatticePoint))
          {
            return false;
          }
          return Equals((LatticePoint)obj);
        }
        public bool Equals(LatticePoint p)
        {
          return (p.X == X) &amp;&amp; (p.Y == Y);
        }
        public override int GetHashCode()
        {
          return X.GetHashCode() * 31 + Y.GetHashCode();
        }
        public static bool operator ==(LatticePoint p1, LatticePoint p2)
        {
          return p1.Equals(p2);
        }
        public static bool operator !=(LatticePoint p1, LatticePoint p2)
        {
          return !p1.Equals(p2);
        }
        public long SquaredSum
        {
          get
          {
            long x2 = (long)X * (long)X;
            long y2 = (long)Y * (long)Y;
            return x2 + y2;
          }
        }
        public int CompareTo(LatticePoint other)
        {
          long r2 = this.SquaredSum - other.SquaredSum;
          if (r2 != 0)
            return (int)r2;
          bool f1 = (other.Y &gt;= 0);
          bool f2 = !((this.Y &gt;= 0) ^ f1);
          return (f1 ? 1 : -1) * (f2 ? this.X - other.X : 1);
        }
        public IEnumerable&lt;LatticePoint&gt; GetNeighborhood()
        {
          yield return new LatticePoint(X + 1, Y);
          if (X &gt; Y)
          {
            yield return new LatticePoint(X, Y + 1);
          }
        }
        public LatticePoint RotateSquare()
        {
          return new LatticePoint(-Y, X);
        }
        public IEnumerable&lt;LatticePoint&gt; GetRotatedPoints()
        {
          if ((X == 0) &amp;&amp; (Y == 0))
          {
            yield return this;
            yield break;
          }
          LatticePoint p = this;
          LatticePoint f = new LatticePoint(Y, X);
          LatticePoint r = this.RotateSquare();
          bool withFlip = ((p != f) &amp;&amp; (f != r));
          for (int i = 0; i &lt; 4; i++)
          {
            yield return p;
            p = p.RotateSquare();
            if (withFlip)
            {
              yield return f;
              f = f.RotateSquare();
            }
          }
        }
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3540'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3540
  :user_name: odz
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/212/
  :language: Haskell
  :time: 2007/10/27 09:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">三角波を使って生成。\r\n1,000番目は 8, -14 でいいのかな。</pre>\n\t"
  :code: |
    triangle_wave :: Int -&gt; Int -&gt; Int
    triangle_wave i n = abs(i `mod` (n * 4) - n * 2) - n

    n_grids :: Int -&gt; [(Int, Int)]
    n_grids 0 = [(0, 0)]
    n_grids n = map (\x -&gt; (triangle_wave x n, triangle_wave (x - n) n)) [0..(n * 4 - 1)]

    grids :: [(Int, Int)]
    grids = concat $ map n_grids [0..]

    main :: IO ()
    main = mapM_ print $ take 1000 grids
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3541'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3541
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/10/27 09:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あれ、よく見ると問題の主旨にあっていない。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3589'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3589
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2007/10/30 06:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">多めに取っておく\r\n（1000個の格子点は半径18以内にある）\r\n\r\n        [,1]
    [,2]      [,3]\r\n   [1,]    0    0  0.000000\r\n   [2,]   -1    0  1.000000\r\n
    \  [3,]    0   -1  1.000000\r\n   [4,]    0    1  1.000000\r\n   [5,]    1    0
    \ 1.000000\r\n   [6,]   -1   -1  1.414214\r\n   [7,]   -1    1  1.414214\r\n   [8,]
    \   1   -1  1.414214\r\n   [9,]    1    1  1.414214\r\n  [10,]   -2    0  2.000000\r\n中略
    \r\n [995,]   11   14 17.804494\r\n [996,]   14  -11 17.804494\r\n [997,]   14
    \  11 17.804494\r\n [998,]  -16   -8 17.888544\r\n [999,]  -16    8 17.888544\r\n[1000,]
    \  -8  -16 17.888544\r\n</pre>\n\t"
  :code: |
    d &lt;- outer(-25:25, -25:25, function(i, j) sqrt(i^2+j^2))
    o &lt;- order(d)
    cbind(rep(-25:25, each=51)[o], rep(-25:25, 51)[o], d[o])[1:1000,]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3590'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3590
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: R
  :time: 2007/10/30 06:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">多めに取っておく\r\n（1000個の格子点は半径18以内にある）\r\n\r\n        [,1]
    [,2]      [,3]\r\n   [1,]    0    0  0.000000\r\n   [2,]   -1    0  1.000000\r\n
    \  [3,]    0   -1  1.000000\r\n   [4,]    0    1  1.000000\r\n   [5,]    1    0
    \ 1.000000\r\n   [6,]   -1   -1  1.414214\r\n   [7,]   -1    1  1.414214\r\n   [8,]
    \   1   -1  1.414214\r\n   [9,]    1    1  1.414214\r\n  [10,]   -2    0  2.000000\r\n中略
    \r\n [995,]   11   14 17.804494\r\n [996,]   14  -11 17.804494\r\n [997,]   14
    \  11 17.804494\r\n [998,]  -16   -8 17.888544\r\n [999,]  -16    8 17.888544\r\n[1000,]
    \  -8  -16 17.888544\r\n</pre>\n\t"
  :code: |
    d &lt;- outer(-25:25, -25:25, function(i, j) sqrt(i^2+j^2))
    o &lt;- order(d)
    cbind(rep(-25:25, each=51)[o], rep(-25:25, 51)[o], d[o])[1:1000,]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3607'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3607
  :user_name: ぴょん
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/490/
  :language: Perl
  :time: 2007/10/30 19:16 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Perl がなかったので。力技。</pre>\n\t"
  :code: |
    use strict;

    my $PI = atan2(1, 1) * 4;
    my $MAXR = int(sqrt(1000 / $PI) + sqrt(2) + 0.5);
    my @res = ();

    for (my $i = 0; $i &lt;= $MAXR; $i++) {
        for (my $j = 0; $j &lt;= $MAXR; $j++) {
            my $r = sqrt($i * $i + $j * $j);
            push(@res, [$i, $j, $r, atan2($j, $i)]);
            ($i != 0) &amp;&amp; push(@res, [-$i, $j, $r, atan2($j, -$i)]);
            ($j != 0) &amp;&amp; push(@res, [$i, -$j, $r, atan2(-$j, $i) + 2 * $PI]);
            ($i * $j != 0) &amp;&amp; push(@res, [-$i, -$j, $r, atan2(-$j, -$i) + 2 * $PI]);
        }
    }

    foreach my $p (sort {($a-&gt;[2] &lt;=&gt; $b-&gt;[2]) || ($a-&gt;[3] &lt;=&gt; $b-&gt;[3])} @res) {
        printf("%3d, %3d\n", splice(@{$p}, 0, 2));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3628'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3628
  :user_name: 匿名
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/4/
  :language: awk
  :time: 2007/10/31 13:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ソート部分は単純なものを採用。\r\n今はR，昔は awk を使っていたもので，R のプログラムと同様。でも，R
    は遙かに楽だなあ。</pre>\n\t"
  :code: |
    BEGIN {
        n = 0
        for (i = -18; i &lt;= 18; i++) {
            for (j = -18; j &lt;= 18; j++) {
                x[n] = i
                y[n] = j
                d[n++] = sqrt(i^2+j^2)
            }
        }
        for (i = 0; i &lt; n-1; i++) {
            mini = d[i]
            minp = i
            for (j = i+1; j &lt; n; j++) {
                if (d[j] &lt; mini) {
                    mini = d[j]
                    minp = j
                }
            }
            if (i != minp) {
                d[minp] = d[i]
                d[i] = mini
                t = x[i]
                x[i] = x[minp]
                x[minp] = t
                t = y[i]
                y[i] = y[minp]
                y[minp] = t
            }
        }
        printf "%4s %3s %3s %10s\n", "No.", "x", "y", "r"
        for (i = 0; i &lt; 1000; i++) {
            printf "%4i: %3i %3i %10.6f\n", i+1, x[i], y[i], d[i]
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3646'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3646
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2007/11/01 10:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">遅延評価を使わないバージョン。\r\n\r\n(1,0)--&gt;(1,1)--&gt;(1,2)--&gt;(1,3)--&gt;...\r\n
    \    +-&gt;(2,0)--&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;...\r\n             +-&gt;(3,0)-&gt;(3,1)-&gt;(3,2)-&gt;(3,3)-&gt;...\r\n
    \               ...\r\nという tree を走査する。\r\n\r\noceanさんの #3256 と多分本質部分は同じ。（Python
    勉強してないので自信なし）\r\n「議席数をドント方式で」の#1439（基はにしおさんの#1214）とも通じるところがある。\r\n</pre>\n\t"
  :code: |
    import Data.Graph.Inductive.Internal.Heap (empty, insert, splitMin)
    import List (unfoldr, groupBy)

    main = mapM_ print
      $ ((0,0):)
      $ concat
      $ map (rotate . map fst)
      $ groupBy (\(_,d1) (_,d2) -&gt; d1 == d2)
      $ unfoldr f
      $ insertPs [(1,0)] empty

    f heap = Just ((p,d), heap'') where
      ((d,_), p@(x,y), heap') = splitMin heap
      children = [(x,y+1)] ++ if (y &gt; 0) then [] else [(x+1,0)]
      heap'' = insertPs children heap'

    insertPs ps heap = foldr insert heap
      $ map (\(x,y) -&gt; ((x^2+y^2,y), (x,y))) ps

    rotate zs = let
      zs' = zs ++ map (\(x,y) -&gt; (-y,x)) zs
      zs'' = zs' ++ map (\(x,y) -&gt; (-x,-y)) zs'
      in zs''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3995'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/3995
  :user_name: Otter
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/497/
  :language: 
  :time: 2007/11/14 05:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">「反時計回り」の定義ですが、ある点の次に出てくる点はその点に最も近く、\r\nかつ今まで出現していない点の中で一番原点に近いものと解釈するべきですよね？\r\nだとしたら、\r\n(
    0, 0)\r\n( 1, 0)\r\n( 0, 1)\r\n(-1, 0)\r\n( 0,-1)\r\nの次にくる座標は\r\n( 1, 1)ではなく、（1,
    -1)のほうが正しいのでは？\r\n\r\nこの違いが１０００番目の座標に影響を及ぼすかはまだ理解していないのですが…\r\nまぁ、サンプルがそうなってはいないので、ここでの解釈は違う？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4025'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4025
  :user_name: Psychs
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/554/
  :language: Objective
  :time: 2007/11/14 14:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あらかじめ点の配列を作っておいてソートするという力業。</pre>\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n\n@interface MyPoint : NSObject\n{\n
    \ int x;\n  int y;\n  long distance;\n}\n\n+ (MyPoint*)pointWithX:(int)x y:(int)y;\n-
    (int)x;\n- (int)y;\n- (long)distance;\n- (NSComparisonResult)compareWithPoint:(MyPoint*)rhs;\n\n@end\n\n@implementation
    MyPoint\n\n- (int)x { return x; }\n- (int)y { return y; }\n- (long)distance {
    return distance; }\n\n- (void)setX:(int)px y:(int)py\n{\n  x = px;\n  y = py;\n
    \ distance = x*x + y*y;\n}\n\n+ (MyPoint*)pointWithX:(int)x y:(int)y\n{\n  MyPoint*
    obj = [[[MyPoint alloc] init] autorelease];\n  [obj setX:x y:y];\n  return obj;\n}\n\n-
    (NSComparisonResult)compareWithPoint:(MyPoint*)rhs\n{\n  long d = [rhs distance];\n
    \ if (distance &lt; d) return NSOrderedAscending;\n  if (distance &gt; d) return
    NSOrderedDescending;\n  \n  int rx = [rhs x];\n  int ry = [rhs y];\n  if (y &gt;=
    0) {\n    if (ry &gt;= 0) {\n      return x &lt; rx ? NSOrderedDescending : NSOrderedAscending;\n
    \   } else {\n      return NSOrderedAscending;\n    }\n  } else {\n    if (ry
    &gt;= 0) {\n      return NSOrderedDescending;\n    } else {\n      return x &lt;
    rx ? NSOrderedAscending : NSOrderedDescending;\n    }\n  }\n}\n\n@end\n\nint main(int
    argc, char** argv)\n{\n  NSAutoreleasePool* pool = [NSAutoreleasePool new];\n
    \ \n  NSMutableArray* input = [NSMutableArray array];\n  int r = 25;\n  int i,
    j;\n  for (i=-r; i&lt;=r; i++)\n    for (j=-r; j&lt;r; j++)\n      [input addObject:[MyPoint
    pointWithX:i y:j]];\n\n  NSArray* result = [input sortedArrayUsingSelector:@selector(compareWithPoint:)];\n
    \ \n  printf(\"count: %d\\n\", [result count]);\n  i = 0;\n  for (id p in result)
    {\n    printf(\"%3d, %3d\\n\", [p x], [p y]);\n    i++;\n  }\n  \n  [pool release];\n
    \ return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4028'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4028
  :user_name: Psychs
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/554/
  :language: Objective
  :time: 2007/11/14 15:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">デバッグ用のコードが残っていたので削除しました。</pre>\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n\n@interface MyPoint : NSObject\n{\n
    \ int x;\n  int y;\n  long distance;\n}\n\n+ (MyPoint*)pointWithX:(int)x y:(int)y;\n-
    (int)x;\n- (int)y;\n- (long)distance;\n- (NSComparisonResult)compareWithPoint:(MyPoint*)rhs;\n\n@end\n\n@implementation
    MyPoint\n\n- (int)x { return x; }\n- (int)y { return y; }\n- (long)distance {
    return distance; }\n\n- (void)setX:(int)px y:(int)py\n{\n  x = px;\n  y = py;\n
    \ distance = x*x + y*y;\n}\n\n+ (MyPoint*)pointWithX:(int)x y:(int)y\n{\n  MyPoint*
    obj = [[[MyPoint alloc] init] autorelease];\n  [obj setX:x y:y];\n  return obj;\n}\n\n-
    (NSComparisonResult)compareWithPoint:(MyPoint*)rhs\n{\n  long d = [rhs distance];\n
    \ if (distance &lt; d) return NSOrderedAscending;\n  if (distance &gt; d) return
    NSOrderedDescending;\n  \n  int rx = [rhs x];\n  int ry = [rhs y];\n  if (y &gt;=
    0) {\n    if (ry &gt;= 0) {\n      return x &lt; rx ? NSOrderedDescending : NSOrderedAscending;\n
    \   } else {\n      return NSOrderedAscending;\n    }\n  } else {\n    if (ry
    &gt;= 0) {\n      return NSOrderedDescending;\n    } else {\n      return x &lt;
    rx ? NSOrderedAscending : NSOrderedDescending;\n    }\n  }\n}\n\n@end\n\nint main(int
    argc, char** argv)\n{\n  NSAutoreleasePool* pool = [NSAutoreleasePool new];\n
    \ \n  NSMutableArray* input = [NSMutableArray array];\n  int r = 25;\n  int i,
    j;\n  for (i=-r; i&lt;=r; i++) {\n    for (j=-r; j&lt;r; j++) {\n      [input
    addObject:[MyPoint pointWithX:i y:j]];\n    }\n  }\n\n  NSArray* result = [input
    sortedArrayUsingSelector:@selector(compareWithPoint:)];\n  \n  printf(\"count:
    %d\\n\", [result count]);\n  for (id p in result) {\n    printf(\"%3d, %3d\\n\",
    [p x], [p y]);\n  }\n  \n  [pool release];\n  return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4035'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4035
  :user_name: yappy
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/533/
  :language: C
  :time: 2007/11/14 18:54 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  個数をコマンドラインパラメータにして、きりのいいところの点のみstderrにも出力するようにしました。\r<br><br>Windows XP + cygwin\r<br>800Mhz 512MB\r<br>100000個めまでで0.7sくらい\r<br>1000000個めまでで10sくらい\r<br>10000000個めまでで2m12sくらい\r<br><br>        1: (     0,      0)\r<br>       10: (     2,      0)\r<br>      100: (    -4,     -4)\r<br>     1000: (    -8,     16)\r<br>    10000: (   -34,     45)\r<br>   100000: (   132,   -120)\r<br>  1000000: (   497,   -267)\r<br> 10000000: (   474,  -1720)\r<br><br>正直なところ、間違ってないかすごく怖いので、だれか他の人もやってみてほしいです。\r<br>"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;math.h&gt;
    #define PI 3.14159265358979

    typedef struct{
        int x;
        int y;
        int len2;
        double theta;
    } POINT;

    POINT *points;
    POINT **pPoints;

    int compair(const void *_a, const void *_b){
        POINT *a = *(POINT **)_a;
        POINT *b = *(POINT **)_b;
        if(a-&gt;len2 != b-&gt;len2)
            return a-&gt;len2 - b-&gt;len2;
        else
            return a-&gt;theta &lt; b-&gt;theta ? -1 : 1;
    }

    int main(int argc, char *argv[]){
        int n, max, size, ind, i, j;
        if(argc &lt; 2)
            return 1;
        n = atoi(argv[1]);
        for(i=1; ; i++){
            if(i * i * 3 &gt; n)
                break;
        }
        max = i;
        size = (max*2+1) * (max*2+1);
        points = (POINT *)malloc(sizeof(POINT) * size);
        pPoints = (POINT **)malloc(sizeof(POINT *) * size);
        ind = 0;
        for(i=-max; i&lt;=max; i++){
            for(j=-max; j&lt;=max; j++){
                points[ind].x = i;
                points[ind].y = j;
                points[ind].len2 = i*i + j*j;
                points[ind].theta = (i==0 &amp;&amp; j==0) ? 0 : atan2(j, i);
                points[ind].theta += points[ind].theta &lt; 0 ? 2 * PI : 0;
                pPoints[ind] = &amp;points[ind];
                ind++;
            }
        }
        qsort(pPoints, size, sizeof(POINT *), &amp;compair);
        for(i=0; i&lt;n; i++){
            printf("%d, %d\n", pPoints[i]-&gt;x, pPoints[i]-&gt;y);
            switch(i+1){
            case 1:
            case 10:
            case 100:
            case 1000:
            case 10000:
            case 100000:
            case 1000000:
            case 10000000:
            case 100000000:
                fprintf(stderr, "%9d: (%6d, %6d)\n", i+1, pPoints[i]-&gt;x, pPoints[i]-&gt;y);
            }
        }
        free(pPoints);
        free(points);
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4694'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4694
  :user_name: れい
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/601/
  :language: VB
  :time: 2007/12/09 07:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">少しメモリ消費量とか速度を考えて。\r\n1000番目は(-8,16)、\r\n1000000番目は(497,-267)、\r\n100000000番目は(5554,-992)。\r\n計算時間は200秒くらい。\r\n\r\nもっと頭いい方法がありそうな。</pre>\n\t"
  :code: |
    Module Module1

        Sub Main()
            Dim e As IEnumerator(Of LatticePoint) = New LatticePointEnumerator()
            Dim i As Integer
            For i = 1 To 999
                e.MoveNext()
            Next
            e.MoveNext()
            Console.WriteLine(i.ToString() &amp; ":" &amp; e.Current.ToString())

            For i = 1001 To 999999
                e.MoveNext()
            Next
            e.MoveNext()
            Console.WriteLine(i.ToString() &amp; ":" &amp; e.Current.ToString())

            For i = 1000001 To 99999999
                e.MoveNext()
            Next
            e.MoveNext()
            Console.WriteLine(i.ToString() &amp; ":" &amp; e.Current.ToString())

            Console.ReadKey()
        End Sub

    End Module

    Public Class LatticePointEnumerator
        Implements IEnumerator(Of LatticePoint)

        Private _list As LinkedList(Of LatticePoint)
        Private _r As Integer
        Private _pointlist As List(Of LatticePoint)
        Private _enumerator As IEnumerator(Of LatticePoint)

        Public Sub New()
            _list = New LinkedList(Of LatticePoint)
            _pointlist = New List(Of LatticePoint)
            Reset()
        End Sub

        Public Sub Reset() Implements System.Collections.IEnumerator.Reset
            _list.Clear()
            _list.AddLast(New LatticePoint(0, 0))
            _list.AddLast(New LatticePoint(1, 0))
            _list.AddLast(New LatticePoint(1, 1))
            _list.AddLast(New LatticePoint(2, 0))
            _list.AddLast(New LatticePoint(2, 1))
            _list.AddLast(New LatticePoint(2, 2))
            _list.AddLast(New LatticePoint(3, 0))
            _list.AddLast(New LatticePoint(3, 1))
            _list.AddLast(New LatticePoint(3, 2))
            _list.AddLast(New LatticePoint(3, 3))
            _r = 4
            _pointlist.Clear()
            _enumerator = _pointlist.GetEnumerator()
        End Sub

        Public ReadOnly Property Current() As LatticePoint Implements System.Collections.Generic.IEnumerator(Of LatticePoint).Current
            Get
                Return _enumerator.Current
            End Get
        End Property

        Public ReadOnly Property Current1() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return DirectCast(_enumerator, IEnumerator).Current
            End Get
        End Property

        Public Function MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            If _enumerator.MoveNext() Then Return True

            If _list.First.Value._r2 &gt;= _r * _r Then
                Dim node As LinkedListNode(Of LatticePoint)
                Dim p As LatticePoint
                node = _list.First
                For y As Integer = 0 To _r
                    p = New LatticePoint(_r, y)
                    While node IsNot Nothing AndAlso p._r2 &gt; node.Value._r2
                        node = node.Next
                    End While
                    If node Is Nothing Then _list.AddLast(p) Else _list.AddBefore(node, p)
                Next
                _r += 1
            End If

            _pointlist.Clear()
            _pointlist.Add(_list.First.Value)
            _list.RemoveFirst()
            While _list.First.Value._r2 = _pointlist(0)._r2
                _pointlist.Add(_list.First.Value)
                _list.RemoveFirst()
            End While

            Dim j As Integer
            j = _pointlist.Count - 1
            If _pointlist(j).X = _pointlist(j).Y Then j -= 1
            For i As Integer = j To 0 Step -1
                _pointlist.Add(New LatticePoint(_pointlist(i).Y, _pointlist(i).X))
            Next
            j = _pointlist.Count - 1
            If _pointlist(j).X = 0 Then j -= 1
            For i As Integer = j To 0 Step -1
                _pointlist.Add(New LatticePoint(-_pointlist(i).X, _pointlist(i).Y))
            Next
            j = _pointlist.Count - 1
            If _pointlist(j).Y = 0 Then j -= 1
            For i As Integer = j To 1 Step -1
                _pointlist.Add(New LatticePoint(_pointlist(i).X, -_pointlist(i).Y))
            Next
            If _pointlist(0).Y &lt;&gt; 0 Then _pointlist.Add(New LatticePoint(_pointlist(0).X, -_pointlist(0).Y))

            _enumerator = _pointlist.GetEnumerator()
            _enumerator.MoveNext()

            Return True
        End Function

        Public Sub Dispose() Implements IDisposable.Dispose
        End Sub

    End Class

    Public Class LatticePoint
        Friend _x As Integer
        Friend _y As Integer
        Friend _r2 As Long

        Friend Sub New(ByVal x As Integer, ByVal y As Integer)
            _x = x
            _y = y
            _r2 = x * x + y * y
        End Sub

        Public ReadOnly Property X() As Integer
            Get
                Return _x
            End Get
        End Property

        Public ReadOnly Property Y() As Integer
            Get
                Return _y
            End Get
        End Property

        Public ReadOnly Property SquaredRadius() As Long
            Get
                Return _r2
            End Get
        End Property

        Public Overrides Function ToString() As String
            Return String.Format("({0}, {1}) [{2}]", _x.ToString(), _y.ToString(), _r2.ToString())
        End Function

    End Class
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4918'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4918
  :user_name: ocaml-nagoya
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/514/
  :language: Haskell
  :time: 2007/12/21 14:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>インスタンス宣言のとこが汚いですが。\n第一象限で近い順に格子点を求め、それらを90度ずつ回転させてコピーします。</p>\n\n\t"
  :code: |
    import Data.List
    newtype Pt = Pt (Int, Int) deriving (Eq, Show)
    instance Ord Pt where
        Pt (x1,y1) &lt;  Pt (x2,y2)
            | x1^2 + y1^2 ==  x2^2 + y2^2 &amp;&amp; y1==y2 = x1 &gt; x2
            | x1^2 + y1^2 ==  x2^2 + y2^2 = y2 &gt; y1
            | otherwise = x1^2 + y1^2 &lt;  x2^2 + y2^2
        Pt (x1,y1) &lt;= Pt (x2,y2) = x1^2 + y1^2 &lt;= x2^2 + y2^2
    mirror (Pt (x,y)) = [Pt (x,y), Pt (-y,x), Pt (-x,-y), Pt (y,-x)]
    minimums l = partition (==m) l
        where m = minimum l
    getMin plain = (concatMap mirror $ sort ms)
                   ++ getMin (concatMap f ms ++ cand)
        where f (Pt (1,y)) = [Pt (2,y), Pt (1,y+1)]
              f (Pt (x,y)) = [Pt (x+1,y)]
              (ms, cand) = minimums plain
    koushiten = Pt (0,0) : getMin [(Pt (1,0))]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4972'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/4972
  :user_name: pooq
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2007/12/25 22:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">格子点と対応させて複素数の行列をつくり、絶対値で\r\nソートしました。反時計回りの順には、なっていません。\r\n
    \  f 1000\r\n 0  0\r\n_1  0\r\n 0 _1\r\n 0  1\r\n 1  0\r\n  ...\r\n 14 _11\r\n
    14  11\r\n_16  _8\r\n_16   8\r\n _8 _16\r\n</pre>\n\t"
  :code: |
    f=.3 :'y{.,/+.,.(/:|),(i:a)j./i:a=.&gt;:-:&gt;.%:y'
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5272'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/5272
  :user_name: saws
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/642/
  :language: Ruby
  :time: 2008/01/12 05:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>充分な数サンプリングしていることを証明していないので, そこが問題点として残っていますが.</p>\n\n\t"
  :code: "require 'matrix'\ninclude Math\nN = 1000\nclass Vector\n  include Enumerable
    #for all?\n  def x; self[0]; end\n  def y; self[1]; end\n  def each; size.times{|i|
    yield self[i]} end\n  def rot(rad)\n    Vector[self[0]*cos(rad)-self[1]*sin(rad),
    self[1]*cos(rad)+self[0]*sin(rad)]\n  end\nend\ndef gen_rot_vectors(v)\n  Array.new(4){|i|
    v.rot(PI*i.quo(2)).map{|e| e.round}} \nend\nn = 0\nn += 1 while n**2*PI &lt; N
    #グリッドを十分な数生成するため\nArray.new(n){|x| Array.new(n){|y| Vector[x, y]}}.flatten. #
    第1象限内でベクトルを生成. \n  delete_if{|v| v.y == 0 unless v.x == 0}. # 重複を避けるため原点を除くy軸上の点を削除\n
    \ sort{|a,b| a.r == b.r ? a.x &lt;=&gt; b.x : a.r &lt;=&gt; b.r}.\n  map{|v| v.all?{|e|
    e == 0} ? v : gen_rot_vectors(v)}. #原点以外のとき回転ベクトルを生成\n  flatten.map{|v| v.to_a}[0..N-1].each{|e|
    p e}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5273'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/5273
  :user_name: 割と普通
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/581/
  :language: C
  :time: 2008/01/12 06:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>以下のソースコードの場合には、1000番目の点は（-10,16）でした。\n格子点生成時に、ｘとｙの範囲を「-17&lt;=x&lt;=17、-17&lt;=y&lt;=17」に変更すると(-8,16)になってしまいました。\nこの辺りを誰か検証してくださると面白そうですね。</p>\n\n\t"
  :code: |
    class MyPoint
    {
        public int x { get; set; }
        public int y{ get; set; }
        public int dist { get; set; }
        public double theta { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ArrayList list = new ArrayList();
            double theta = 0;
            for (int x = -16; x &lt;= 16; x++)
            {
                for (int y = -16; y &lt;= 16; y++)
                {
                    theta = Math.Atan2(y, x);
                    if (theta &lt; 0) theta += Math.PI * 2;
                    list.Add(new MyPoint { x = x, y = y, dist = x * x + y * y, theta = theta });
                }
            }

            var query = (from MyPoint point in list
                        orderby point.dist ascending, point.theta ascending
                        select point.x + "," + point.y).Take(1000);
            foreach(string str in query)
                Console.WriteLine(str);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5278'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/5278
  :user_name: saws
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/642/
  :language: 
  :time: 2008/01/12 11:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">すみません. 先程の投稿の修正です. \r\n充分なグリッド数のサンプリングには, サンプリング\r\nが最低必要なグリッド数Nを含む正方形に外接す\r\nる円を考え,
    それが内接している, 正方形グリッドを\r\n考えればいいので, \r\n16, 17行目は, \r\nn = (sqrt(2)*sqrt(N).ceil).ceil\r\nとするべきでした.
    \r\nceilメソッドを二度も使いたくない方には, \r\nn = ((2+sqrt(2))*sqrt(N)).truncate\r\nがお勧めです. </pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6524'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/6524
  :user_name: genzou
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/06/16 22:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>他の方と同様、\n1000番目は(-8, 16)でした。</p>\n<p>もう少し数学的にきれいに解く方法があるんでしょうけどね。</p>\n\n\t"
  :code: |
    def kakudo( x, y ) {
        def k = Math.acos(x/Math.sqrt(x**2 + y**2))
        if (y&lt;0)
            k = 2*Math.PI - k
        k
    }

    // 座標リスト作成
    def points = []
    def range = 20
    (-range..range).each{ x-&gt;
        (-range..range).each{ y-&gt;
            points &lt;&lt; [x:x, y:y]
        }
    }

    // 出力
    points.sort{ point -&gt;
        def result = 0
        if(point.x != 0 || point.y != 0)
            result = ((point.x**2 + point.y**2)*100 + kakudo(point.x, point.y)*10).toInteger()
        result
    }.each{ point -&gt;
        println point
    }
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '6530'
  :parent_id: '65'
  :url: http://ja.doukaku.org/comment/6530
  :user_name: Nemo
  :user_url: /web/20100612150759/http://ja.doukaku.org/user/685/
  :language: PostScript
  :time: 2008/06/17 09:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>力技で..\nBubble Sort したら遅かったので無理矢理 Quick Sort を実装。まだ荒削りですが。</p>\n\n\t"
  :code: "%!PS\n\n/CompareVal { % [R X Y Theta] [R2 X2 Y2 Theta2 ] CompareXY  integer\n
    \   2 copy 0 get exch 0 get sub\n    dup 0 eq\n    {\n        pop\n        3 get
    exch 3 get sub\n    } {\n        exch pop exch pop\n    } ifelse\n    neg\n} bind
    def\n\n/QSort { %  [Array] /CompareFunction  QSort  [Array']\n    cvx\n    1 index
    0 get\n    0 3 index length 1 sub\n    % [Array] Comp pivot l r\n    {\n        2
    copy ge { exit } if \n        {\n            2 copy ge { exit } if\n            4
    index 1 index get 3 index 5 index\n            exec 0 lt { exit } if\n            1
    sub\n        } loop\n        2 copy ne {\n            4 index 1 index get\n            5
    index exch 3 index exch put\n            exch 1 add exch\n        } if\n        {\n
    \           2 copy ge { exit } if\n            4 index 2 index get 3 index 5 index
    exec 0 gt { exit } if\n            exch 1 add exch\n        } loop\n        2
    copy ne {\n            4 index 2 index get\n            5 index exch 2 index exch
    put\n            1 sub\n        } if\n    } loop\n    4 index 2 index 4 index
    put \n    1 index 1 gt {\n        4 index 0 3 index getinterval\n        4 index
    QSort pop\n    } if\n    % [Array] Comp pivot l r\n    4 index length 1 index
    2 add gt {\n        4 index dup length 3 index sub 1 sub  3 index 1 add exch getinterval\n
    \       4 index\n        QSort pop\n    } if\n    pop pop pop pop\n} bind def\n\n\n/GenLattice
    { % N  GenLattice  [ [r^2 x1 y1 angle] ... ]\n    [ exch\n    2 div sqrt 1 add
    cvi\n    dup neg exch 1 exch\n    % [ -X0 1 X0 \n    3 copy {\n        % [ -X0
    1 X0 Y\n        4 copy pop {\n            % [ -X0 1 X0 Y X\n            2 copy
    [ 3 1 roll\n            % [ -X0 1 X0 Y X  [ Y X\n            2 copy dup mul exch
    dup mul add sqrt\n            3 1 roll\n            2 index 0 eq { 0 } { 2 copy
    atan } ifelse\n            ]\n            % [ -X0 1 X0 Y X  [ r^2 Y X theta ]\n
    \           6 1 roll pop\n            % [ [] -X0 1 X0 Y \n        } for\n        pop\n
    \   } for\n    pop pop pop ]\n} bind def\n\n/DisplayLatticePoints { % N  DisplayLatticePoints
    \ -\n    dup GenLattice /CompareVal QSort\n    0 1 4 -1 roll\n    {\n        1
    index exch get aload pop pop\n        10 string cvs print (, ) print =\n        pop\n
    \   } for\n    pop\n} bind def\n\n1000 DisplayLatticePoints\n"
  :tags: []
  :references:
    :url: 
    :title: 
