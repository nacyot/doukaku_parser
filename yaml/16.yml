---
:id: '16'
:title: アレイのuniq
:comments:
- :id: '3372'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3372
  :user_name: にしお
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/10 07:52 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  アレイ(複数の値が配列状になっているもの)xsが与えられたときに、同じ値が2回以上出現しないように、2回目以降の出現を取り除いたアレイを返すコードを書いてください。\r\n<p>\r\nRubyで表現すると下のようになります。\r\n</p>\n<pre>\r\nirb(main):001:0&gt;
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]\r\n=&gt; [3, 1, 4, 1, 5, 9,
    2, 6, 5, 3, 5, 8, 9, 7, 9]\r\nirb(main):002:0&gt; xs.uniq\r\n=&gt; [3, 1, 4, 5,
    9, 2, 6, 8, 7]\r\n</pre>\r\n<p>\r\n間違えないように：よくある「ハッシュを使う」「集合オブジェクトを使う」などの方法は順番が乱れてしまうので使えません。出現順序を守りつつ、2回目以降の出現だけを取り除いてください。\r\n</p>\n<p>\r\nこの投稿は匿名での挑戦状の投稿を元に作成しています。ご投稿ありがとうございます。\r\n\t</p>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '448'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/448
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2007/07/10 07:53 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  「Rubyからの挑戦状」ということで。\n\t"
  :code: |
    xs.uniq
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '450'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/450
  :user_name: id:amachang
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/62/
  :language: JavaScript
  :time: 2007/07/10 08:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">うーん。プリミティブ値だけの配列だったらこれでいける。\r\nでも、オブジェクトとかが入ってくると
    \r\ntoString() の結果によっては正しい結果にならないなあ。\r\n\r\nalert([1, 2, 3, 3, 2, 1].uniq());
    // [1, 2, 3]</pre>\n\t"
  :code: |
    Array.prototype.uniq = function () {
      for (var i = 0, r = [], s = {}; i &lt; this.length; i++) {
        if (!s[this[i]]) r.push(this[i]);
        s[this[i]] = true;
      }
      return r;
    };
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '452'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/452
  :user_name: kawauchi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/14/
  :language: Ruby
  :time: 2007/07/10 08:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    require 'pseudohash' # http://www.notwork.org/~gotoken/ruby/p/pseudohash/

    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]

    h = PseudoHash.new
    xs.each{|i|
      h[i, true] = nil
    }
    xs_out = h.map{|k, v| k}

    p xs_out
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '454'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/454
  :user_name: iakio
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/77/
  :language: Python
  :time: 2007/07/10 09:05 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  効率はともかく\n\t"
  :code: |
    &gt;&gt;&gt; [ xs[i] for i in xrange(0, len(xs)) if xs[i] not in xs[:i] ]
    [3, 1, 4, 5, 9, 2, 6, 8, 7]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '455'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/455
  :user_name: kawauchi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/14/
  :language: Ruby
  :time: 2007/07/10 09:13 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]

    h = {}
    xs_out = []
    xs.each {|i|
      xs_out &lt;&lt; i unless h.key?(i)
      h[i] = nil
    }

    p xs_out
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '456'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/456
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: OCaml
  :time: 2007/07/10 09:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"># uniq [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5; 8;
    9; 7; 9];;\r\n- : int list = [3; 1; 4; 5; 9; 2; 6; 8; 7]</pre>\n\t"
  :code: |
    let uniq xs =
      let rec uniq' acc = function
      | [] -&gt; acc
      | y::ys when (List.mem y acc) -&gt; uniq' acc ys
      | y::ys -&gt; uniq' (y::acc) ys
      in
      List.rev (uniq' [] xs)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '457'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/457
  :user_name: kacchi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/145/
  :language: Scheme
  :time: 2007/07/10 09:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">(vector-uniq xs)\r\n=&gt;#(3 1 4 5 9 2 6 8
    7)</pre>\n\t"
  :code: |
    (define xs #(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9))

    (define (vector-uniq vec)
      (let ((ls (vector-&gt;list vec)))
        (do ((ls ls (cdr ls))
             (acc '() (if (memv (car ls) acc) acc (cons (car ls) acc))))
            ((null? ls) (list-&gt;vector (reverse! acc))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '458'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/458
  :user_name: mimizu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/103/
  :language: Java
  :time: 2007/07/10 09:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Unique
    {\n\t\n\tpublic static Object[] toUniqueArray(Object[] array) {\n\t\tList unique
    = new ArrayList();\n\t\tfor (Object o : array) {\n\t\t\tif (!unique.contains(o))
    {\n\t\t\t\tunique.add(o);\n\t\t\t}\n\t\t}\n\t\treturn unique.toArray();\n\t}\n\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '459'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/459
  :user_name: sumim
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/10 09:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">Squeak Smalltalk の #addIfNotPresent: を使って。</pre>\n\t"
  :code: |
    | xs uniq |
    xs := #(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9).
    uniq := OrderedCollection new.
    xs do: [:each | uniq addIfNotPresent: each].
    ^uniq asArray

    "=&gt; #(3 1 4 5 9 2 6 8 7) "
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '460'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/460
  :user_name: ocean
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/07/10 09:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  普通に。\n\t"
  :code: |
    def iter_uniq(it):
        s = set()
        for x in it:
            if x not in s:
                yield x
                s.add(x)

    def uniq(a):
        return list(iter_uniq(a))

    print uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '462'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/462
  :user_name: katsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/117/
  :language: Scheme
  :time: 2007/07/10 10:01 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  「hashを使」います。\r\nvectorでもlistでもsequenceなら効きます。\n\t"
  :code: |
    (use gauche.sequence)
    (define (uniq a)
      (let1 h (make-hash-table 'equal?)
        (define (p x) (or (hash-table-exists? h x)
                          (begin (hash-table-put! h x #t) #f)))
        (remove-to (class-of a) p a)))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '463'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/463
  :user_name: id:amachang
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/62/
  :language: JavaScript
  :time: 2007/07/10 10:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Object Type にも対応した書き方。\r\n効率悪いとか言わない＞＜\r\n\r\nalert([1,
    2, {}, {}, 2, 1].uniq()); // [1, 2, {}, {}]\r\n\r\nvar a = {};\r\nalert([1, 2,
    a, a].uniq()); // [1, 2, {}]</pre>\n\t"
  :code: "Array.prototype.uniq = function () {\n  for (var i = 0, r = [], s = [];
    i &lt; this.length; i++) {\n    for (var j = 0; j &lt; s.length; j ++) \n      if
    (s[j] === this[i]) break;\n    if (j == s.length) {\n      r.push(this[i]);\n
    \     s.push(this[i]);\n    }\n  }\n  return r;\n};\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '464'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/464
  :user_name: Mistfeal
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/153/
  :language: PHP
  :time: 2007/07/10 10:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  そのものズバリ array_unique を利用。\r\n何のヒネリも有りませんね。\n\t"
  :code: |
    &lt;?php
    $xs = array(3,1,4,1,5,9,2,6,5,3,5,8,9,7,9);
    var_dump(array_unique($xs));
    ?&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '465'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/465
  :user_name: es
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/147/
  :language: Scheme
  :time: 2007/07/10 10:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  ＃457や＃462を思いつけるようになりたい。\n\t"
  :code: |
    (define (uniq lst)
      (fold
       (lambda (e l)
         (cond ((null? l) (cons e l))
               ((member e l) l)
               (else (append l (list e)))))
       '()
       lst))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '466'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/466
  :user_name: anekos
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/170/
  :language: Haskell
  :time: 2007/07/10 10:32 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  こんなのでいいのか。\r\n(import Data.List が必要)\n\t"
  :code: |
    nub xs
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '467'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/467
  :user_name: moro
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/182/
  :language: Ruby
  :time: 2007/07/10 10:48 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">隙があったのでinject</pre>\n\t"
  :code: |
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]
    xs.inject([]){|a, e| a.member?(e) ? a : a &lt;&lt; e }
  :tags:
  - inject
  :references:
    :url: 
    :title: 
- :id: '468'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/468
  :user_name: cats
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/172/
  :language: C
  :time: 2007/07/10 10:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    class Program
    {
      static void Main()
      {
        int[] xs ={ 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9 };
        foreach(int i in Uniq(xs))
          Console.WriteLine(i);
      }
      static List&lt;T&gt; Uniq&lt;T&gt;(T[] xs)
      {
        List&lt;T&gt; lst = new List&lt;T&gt;();
        Dictionary&lt;T, object&gt; dic = new Dictionary&lt;T, object&gt;();
        foreach (T t in xs) if (!dic.ContainsKey(t))
          { lst.Add(t); dic.Add(t, null); }
        return lst;
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '469'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/469
  :user_name: ココサブ
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/24/
  :language: C
  :time: 2007/07/10 10:59 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  元の配列をそのまま変更しています。\n\t"
  :code: |
    #include &lt;stdio.h&gt;

    int main()
    {
      int xs[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};
      int array_size;
      int i, j, k;
      int save;

      array_size = (sizeof(xs) / sizeof(xs[0]));
      for (i = 0; i &lt; array_size; i++) {
        save = xs[i];
        for (j = i+1; j &lt; array_size; j++) {
          if (save == xs[j]) {
            /* 配列を詰める作業 */
            for (k = j; k &lt; array_size-1; k++) {
              xs[k] = xs[k+1];
            }
            array_size--;
          }
        }
      }

      for (i = 0; i &lt; array_size; i++) {
        printf("%d ", xs[i]);
      }
      printf("\n");

      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '470'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/470
  :user_name: PoohKid
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/180/
  :language: C
  :time: 2007/07/10 11:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">重複を取り除いた配列ということで教科書通りにArrayList.Contains()です。\r\nVS2005なのでムダにジェネリックで。\r\nJavaとほぼ同じロジックなのはナイショだ。つーかC#出てた
    orz</pre>\n\t"
  :code: |
    using System;
    using System.Collections.Generic;
    using System.Text;

    namespace ArrayUniq
    {
        class Program
        {
            static void Main(string[] args)
            {
                object[] source = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9 };
                object[] results = Uniq(source);
                foreach (object value in results)
                {
                    System.Console.WriteLine(value);
                }
            }

            static object[] Uniq(object[] array)
            {
                List&lt;object&gt; uniqList = new List&lt;object&gt;();
                foreach (object value in array)
                {
                    if (! uniqList.Contains(value))
                    {
                        uniqList.Add(value);
                    }
                }
                return uniqList.ToArray();
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '471'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/471
  :user_name: nkmrtks
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/155/
  :language: Common
  :time: 2007/07/10 11:16 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  適当\n\t"
  :code: |
    (let ((xs (list 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9)))
      (delete-duplicates xs :from-end t))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '472'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/472
  :user_name: rubikitch
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/10 11:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  iterateパッケージを使ってみました。これ便利すぎ。\n\t"
  :code: |
    (require :iterate)
    (in-package :iterate)
    (iter (for x in '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9)) (adjoining x)) ; =&gt; (3 1 4 5 9 2 6 8 7)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '473'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/473
  :user_name: watta
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/183/
  :language: JavaScript
  :time: 2007/07/10 11:39 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  <pre class=\"compact\">forEachでまわしてる配列をいじるのってやばいですかね。</pre>\n\t"
  :code: |
    var xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9];
    xs.forEach(function(i) {
        if (xs.indexOf(i) != xs.lastIndexOf(i))
            xs.splice(xs.lastIndexOf(i), 1)
    });
    alert(xs);
  :tags:
  - JavaScript
  - JavaScript1.6
  :references:
    :url: 
    :title: 
- :id: '474'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/474
  :user_name: ocean
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/07/10 11:39 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  なんとなく内包表記で。\n\t"
  :code: |
    import sys

    def uniq(a):
        s = set()
        def check(x):
            if x not in s:
                s.add(x)
                return True
            else:
                return False
        return [x for x in a if check(x)]

    if __name__ == '__main__':
        print uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '478'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/478
  :user_name: kacchi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/145/
  :language: Emacs
  :time: 2007/07/10 11:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Emacs22で。</pre>\n\t"
  :code: |
    (setq xs [3 1 4 1 5 9 2 6 5 3 5 8 9 7 9])

    (vconcat (delete-dups (append xs nil)))
    =&gt;[3 1 4 5 9 2 6 8 7]
  :tags:
  - Emacs22
  :references:
    :url: 
    :title: 
- :id: '479'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/479
  :user_name: kozima
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/07/10 12:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  普通のコードはすでに出てるので無駄に高度なことをしてみる\n\t"
  :code: "(let ((xs '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9)))\n  (let ((*readtable* (copy-readtable)))\n
    \   (flet ((skip (stream char) (declare (ignore char stream)) (values)))\n      (flet
    ((read-digit (stream char)\n\t       (set-macro-character char #'skip)\n\t       (parse-integer
    (string char))))\n\t(dotimes (c 10)\n\t  (set-macro-character (code-char (+ 48
    c)) #'read-digit))\n\t(with-input-from-string (s (prin1-to-string xs))\n\t  (read
    s))))))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '481'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/481
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: OCaml
  :time: 2007/07/10 12:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  #456 は「配列状」を緩く解釈してリストを使いましたが、文字通り配列（だけ）を使うとこうなるのかなあと。\n\t"
  :code: "let rec appears_between p q m a =\n   if p = q then false\n   else\n     if
    a.(p) = m then true\n     else appears_between (succ p) q m a\n\nlet uniq2 xs
    = \n  let ys = Array.copy xs in\n  let rec move x y =\n    if (Array.length xs)
    = x then\n      Array.sub ys 0 y\n    else\n      if appears_between 0 y xs.(x)
    ys then\n        move (succ x) y\n      else\n        (ys.(y) &lt;- xs.(x); move
    (succ x) (succ y))\n  in\n  move 0 0\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '482'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/482
  :user_name: kacchi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/145/
  :language: 
  :time: 2007/07/10 12:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  こちらこそ。foldを使うなんて思い付きませんorz\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '483'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/483
  :user_name: send
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/185/
  :language: JavaScript
  :time: 2007/07/10 12:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  こんな感じかな？\r\nspidermonkey1.6で確認。\n\t"
  :code: "Array.prototype.uniq = function() {                                                                                                    \n
    \ label_unique:                                                                                                                        \n
    \ for(var uniformized = [], i = 0; i &lt; this.length; i++) {                                                                             \n
    \   for(var l = 0; l &lt; uniformized.length; l++) if(this[i] === uniformized[l])
    continue label_unique;                                  \n    uniformized.push(this[i]);
    \                                                                                                        \n
    \ }                                                                                                                                    \n
    \ return uniformized;                                                                                                                  \n}
    \                                                                                                                                     \nvar
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9];                                                                                \nxs.uniq();
    // 3,1,4,5,9,2,6,8,7 \n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '485'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/485
  :user_name: takatoh
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/189/
  :language: Haskell
  :time: 2007/07/10 13:06 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  再帰で\n\t"
  :code: |
    uniq []     = []
    uniq (x:xs) = x:uniq (filter (/=x) xs)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '486'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/486
  :user_name: smeghead
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/31/
  :language: Common
  :time: 2007/07/10 13:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">(print (uniq '(3 1 4 1 5 9 2 6 5 3 5 8 9 7
    9)))\r\n;他の人たちのコードを見てると勉強になります。\r\n</pre>\n\t"
  :code: |
    (defun uniq (lst)
      (labels ((rec (l acc)
                  (if (null l) (reverse acc)
                    (let ((top (car l)) (rests (cdr l)))
                      (if (member top acc)
                        (rec rests acc)
                        (rec rests (cons top acc)))))))
        (rec lst nil)))
  :tags:
  - clisp
  :references:
    :url: 
    :title: 
- :id: '488'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/488
  :user_name: watta
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/183/
  :language: 
  :time: 2007/07/10 13:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  var xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 5, 5, 5, 5];\r\nみたいな場合にちゃんと動いてませんでした。あう。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '490'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/490
  :user_name: id:nekoruri
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/111/
  :language: Perl
  :time: 2007/07/10 13:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  たまにはoneliner\n\t"
  :code: |
    % perl -e 'print join ",", (grep { $tmp{$_}++ == 0 } @ARGV); print "\n"' 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9
    3,1,4,5,9,2,6,8,7
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '491'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/491
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: Scala
  :time: 2007/07/10 13:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Scala で。バッファが使えるのであまり考えずに書ける。このコードは単体プログラムではなくインタプリタ向け。\n\t"
  :code: |
    import scala.collection.mutable._

    def uniq[T](xs: Array[T]): Array[T] = {
      val buffer = new ArrayBuffer[T]
      xs.foreach { e =&gt; if (!buffer.contains(e)) buffer + e }
      buffer.toArray
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '492'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/492
  :user_name: harupiyo
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/191/
  :language: Perl
  :time: 2007/07/10 14:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">初めて投稿してみます。Perl での短めコードを目指してみました。\r\nhash を使って、二度目を表示しないようにしています。\r\n</pre>\n\t"
  :code: |
    @xs = (3,1,4,1,5,9,2,6,5,3,5,8,9,7,9);
    print grep{$_ if!$t{$_}++}@xs;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '493'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/493
  :user_name: katsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/117/
  :language: Scheme
  :time: 2007/07/10 14:04 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  リストの処理で、foldを使うのならこういうのも。最後にreverseするのが残念な感じですが。!無しで。\n\t"
  :code: |
    (define (uniq a)
      (reverse
        (fold (lambda (e knil)
                (if (member e knil)
                  knil
                  (cons e knil))) () a)))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '494'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/494
  :user_name: ytakenaka
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/35/
  :language: Common
  :time: 2007/07/10 14:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  いい勉強になりますね。:-) 僕は末尾再帰版で\n\t"
  :code: "(defun uniq (list)\n  (labels ((uniq-sub (out in)\n\t     (if (null in)\n\t\t
    out\n\t\t (uniq-sub (append out (list (car in)))\n\t\t\t   (remove (car in) (cdr
    in))))))\n\n    (uniq-sub nil list)))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '496'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/496
  :user_name: katsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/117/
  :language: Prolog
  :time: 2007/07/10 14:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Prologって、マイナーなんだなぁ。</pre>\n\t"
  :code: |
    uniq([], R) :- fill(R).
    uniq([Xh|Xs], R) :- memv(Xh, R), uniq(Xs, R).
    uniq([Xh|Xs], R) :- add(Xh, R), uniq(Xs, R).

    memv(_, V) :- var(V), fail.
    memv(X, [X|_]).
    memv(X, [_|Vt]) :- memv(X, Vt).

    add(X, R) :- var(R), R=[X|_].
    add(X, [_|Rt]) :- add(X, Rt).

    fill(R):-var(R), R=[].
    fill([_|Rs]):-fill(Rs).

    :- uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9], R), writeln(R).
  :tags:
  - SWI-Prolog
  :references:
    :url: 
    :title: 
- :id: '499'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/499
  :user_name: tset
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/74/
  :language: JavaScript
  :time: 2007/07/10 15:32 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">効率の方を。</pre>\n\t"
  :code: |
    Array.prototype.uniq = function () {
      var result = [], prev = {}, value, prev_null = 0, i;
      for (i = 0; i &lt; this.length; ++i) {
        value = this[i];
        typeof value !== 'object'
          ? prev[value] || (prev[value] = 1, result.push(value))
          : value === null
            ? prev_null++ || result.push(null)
            : value === void(0) || value.__prev || (value.__prev = true, result.push(value));
      }
      for (i = 0; i &lt; this.length; ++i) {
        value instanceof Object &amp;&amp; delete value.__prev;
      }
      return result;
    };
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '500'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/500
  :user_name: tset
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/74/
  :language: 
  :time: 2007/07/10 15:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ミスりました。\r\nline 12 value -&gt; this[i]</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '501'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/501
  :user_name: es
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/147/
  :language: 
  :time: 2007/07/10 15:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">毎回 (null? l) する無駄や (append l (list e)) あたりの汚さが\r\n消えてすっきりキレイに!\r\nなるほど納得。ありがとうございます。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '503'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/503
  :user_name: yuin
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/10 16:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Scalaで手短に。\r\nかつRubyに対抗してArrayから呼べるように拡張。</pre>\n\t"
  :code: |
    class ExtendedArray[A](self:Array[A]) {
      def uniq = (for(i &lt;- List.range(0, self.length)
                      if self.findIndexOf(_==self(i))==i) yield self(i)).toArray
    }
    implicit def array2ext[A](self:Array[A]) = new ExtendedArray[A](self)

    Array(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9).uniq
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '508'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/508
  :user_name: ocean
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/177/
  :language: C
  :time: 2007/07/10 18:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  C++のSTLを使用。\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;

    template &lt;typename ForwardIterator&gt;
    ForwardIterator uniq(ForwardIterator beg, ForwardIterator end)
    {
        while (beg != end)
        {
            ForwardIterator cur = beg++;

            end = std::remove(beg, end, *cur);
        }

        return end;
    }

    int main()
    {
        const int a[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};

        std::vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(*a));

        v.erase(uniq(v.begin(), v.end()), v.end());

        std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " "));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '516'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/516
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Perl
  :time: 2007/07/11 02:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  わんらいなーらぶ\n\t"
  :code: |
    perl -e'print grep {!$h{$_}++} split//,"314159265358979"'
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '517'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/517
  :user_name: satoru.net
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/207/
  :language: Perl
  :time: 2007/07/11 02:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  わんらいなーらぶ\n\t"
  :code: |
    perl -e'print grep {!$h{$_}++} split//,"314159265358979"'
  :tags:
  - 湾ライナー
  :references:
    :url: 
    :title: 
- :id: '524'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/524
  :user_name: bonlife
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/83/
  :language: Python
  :time: 2007/07/11 03:13 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  Python界隈に足りないのは素人だと思います。\r\nということで、素人らしいコードも恥ずかしがらずに公開です。\n\t"
  :code: |
    def make_uniq_list(l):
        ul = list()
        for i in l:
            if ul.__contains__(i) == False:
                ul.append(i)
        return ul
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '526'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/526
  :user_name: katsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/117/
  :language: Scheme
  :time: 2007/07/11 03:32 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">同じ事をscheme(gauche)で。\r\nわかりやすい流れですねこれ。\r\npa$はcurry化です。</pre>\n\t"
  :code: |
    (use srfi-1)

    (define (uniq a)
      (if (null? a) a
        (cons (car a) (uniq (remove (pa$ = (car a)) (cdr a))))))

    (print (uniq '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9)))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '528'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/528
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/07/11 04:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">GenericなだけであとはC</pre>\n\t"
  :code: |
    #include &lt;stdio.h&gt;

    #define LEN(a) (sizeof(a) / sizeof(a[0]))

    template &lt;class T&gt;
    int uniq(T* a, int len)
    {
        int i = 0;
        int l = len;
        while(1 &lt; l) {
            l = remove(a+i+1, l-1, a[i]);
            i++;
        }
        return i + 1;
    }

    template &lt;class T&gt;
    int remove(T* a, int len, T p)
    {
        int l=0;
        for (int i=0; i&lt;len; i++) {
            if(a[i] != p)
                a[l++] = a[i];
        }

        return l;
    }

    int main()
    {
        int xs[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};

        int len = uniq(xs, LEN(xs));

        for(int i=0; i&lt;len; i++) {
            printf("%d ", xs[i]);
        }
        printf("\n");
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '529'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/529
  :user_name: にしお
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/07/11 05:01 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">簡潔でわかりやすい書き方だと思いますよ～。\r\n\r\nでも「勝手に添削」したくなっちゃいました。\r\n僕ならこう書く↓</pre>\n\t"
  :code: |
    def make_uniq_list(xs):
        result = []
        for x in xs:
            if not x in result:
                result.append(x)
        return result
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '530'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/530
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: JavaScript
  :time: 2007/07/11 05:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">いっそ両方とも実装してみるとか。ダメ？</pre>\n\t"
  :code: "Array.prototype.uniq = function(usedObjKey) {\n  if (typeof(usedObjKey)
    == 'undefined')\n    usedObjKey = (typeof(this[0]) == 'object');\n  \n  var ret
    = [];\n  if (usedObjKey) {\n    for (var i=0, len=this.length, s=[]; i&lt;len;
    i++) {\n      if (s.indexOf(this[i]) &lt; 0) {\n        ret.push(this[i]);\n        s.push(this[i]);\n
    \     }\n    }\n  }\n  else\n  {\n    for (var i=0, len=this.length, s={}; i&lt;len;
    i++) {\n      if (!s[this[i]])\n        ret.push(this[i]);\n      s[this[i]] =
    true;\n    }\n  }\n  return ret;\n}\n\n/**\n * @site http://developer.mozilla.org/ja/docs/\n
    *       Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf\n */\nif (!Array.prototype.indexOf)
    {\n  Array.prototype.indexOf = function(elt /*, from*/) {\n    var len = this.length;\n
    \   var from = Number(arguments[1]) || 0;\n    from = (from &lt; 0) ? Math.ceil(from)
    : Math.floor(from);\n    if (from &lt; 0)\n      from += len;\n    \n    for (;
    from&lt;len; from++)\n      if (from in this &amp;&amp; this[from] === elt)\n
    \       return from;\n    return -1;\n  };\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '533'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/533
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/07/11 06:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "def uniq(iterable):\n    \"\"\"                                                                                                                                                       \n
    \   &gt;&gt;&gt; uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])                                                                                                   \n
    \   [3, 1, 4, 5, 9, 2, 6, 8, 7]                                                                                                                               \n
    \   \"\"\"\n    s = set()\n    return [s.add(i) or i for i in iterable if i not
    in s]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '554'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/554
  :user_name: id:nekoruri
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/111/
  :language: Perl
  :time: 2007/07/11 08:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  List::MoreUtils使った版oneliner。\n\t"
  :code: |
    % perl '-MList::MoreUtils qw(uniq)' -e 'print join ",", uniq @ARGV; print "\n"' 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9
    3,1,4,5,9,2,6,8,7
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '564'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/564
  :user_name: tetsuro6502
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/213/
  :language: XSLT
  :time: 2007/07/11 12:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  XSLT\n\t"
  :code: "[XML]\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;array&gt;\n\t&lt;e&gt;3&lt;/e&gt;&lt;e&gt;1&lt;/e&gt;&lt;e&gt;4&lt;/e&gt;&lt;e&gt;1&lt;/e&gt;&lt;e&gt;5&lt;/e&gt;&lt;e&gt;9&lt;/e&gt;&lt;e&gt;2&lt;/e&gt;&lt;e&gt;6&lt;/e&gt;\n\t&lt;e&gt;5&lt;/e&gt;&lt;e&gt;3&lt;/e&gt;&lt;e&gt;5&lt;/e&gt;&lt;e&gt;8&lt;/e&gt;&lt;e&gt;9&lt;/e&gt;&lt;e&gt;7&lt;/e&gt;&lt;e&gt;9&lt;/e&gt;\n&lt;/array&gt;\n\n[XSLT]\n&lt;?xml
    version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:transform version=\"1.0\"\n\txmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n&lt;xsl:output
    method=\"xml\" encoding=\"UTF-8\"/&gt;\n\n&lt;xsl:template match=\"array\"&gt;\n&lt;array&gt;&lt;xsl:apply-templates
    select=\"e[not(. = preceding-sibling::e)]\"/&gt;&lt;/array&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template
    match=\"e\"&gt;\n&lt;e&gt;&lt;xsl:apply-templates /&gt;&lt;/e&gt;\n&lt;/xsl:template&gt;\n\n&lt;/xsl:transform&gt;\n"
  :tags:
  - XSLT
  :references:
    :url: 
    :title: 
- :id: '570'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/570
  :user_name: sybian
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/217/
  :language: JavaScript
  :time: 2007/07/11 13:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ObjectやFunctionにも対応してみた。firefox2.0.0.4+Firebugで確認。\r\nなんというかtoJSONString()の手抜き実装みたいだ。</pre>\n\t"
  :code: "Array.prototype.uniq=function(){\n\tvar h={};\n\tvar tostr=function(obj){\n\t\tif(typeof
    obj == \"object\"){\n\t\t\tvar str=\"\";\n\t\t\tfor(var p in obj){\n\t\t\t\tstr+=p+\":\"+arguments.callee(obj[p]);\n\t\t\t}\n\t\t\treturn
    \"{\"+str+\"}\";\n\t\t}\n\t\treturn obj;\n\t}\n\tfor(var i=0,h={},l=this.length,r=[];
    chk=tostr(this[i]),i&lt;l; i++){\n\t\tif(!h[chk]===true)r.push(this[i]);\n\t\th[chk]=true;\n\t}\n\treturn
    r;\n}\n\n// -------------------\n\nvar a=[1,2,[3,4],6,2,3,{},{},[4,3]\n\t,function(){},function(a){},function(){},function(){return
    this;}\n\t,{\"a\":\"test1\"}\n\t,{\"a\":\"nest\",\"b\":{\"c\":\"nest2\"}}\n\t,{\"a\":\"nest2\",\"b\":{\"c\":\"nest3\"}}\n\t,{\"a\":\"nest\",\"b\":{\"c\":\"nest2\"}}\n\t,{\"a\":\"test1\"}\n\t,{\"a\":\"test3\"}\n\t,[5,12,4],[4,3],[5]\n];\na.uniq();\n\n//[1,
    2, [3, 4], 6, 3, Object, [4, 3], function(), function(), function()\n//, Object
    a=test1, Object a=nest b=Object, Object a=nest2 b=Object, Object a=test3\n//,
    [5, 12, 4], [5]]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '579'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/579
  :user_name: iwk
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/49/
  :language: OCaml
  :time: 2007/07/11 14:07 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  関数型ということにこだわらなければこういう手も。\n\t"
  :code: |
    open System;;
    open Array;;

    let uniq xs =
        let ars = create (length xs) xs.(0) in
        let i = ref 1 in
        for idx = 1 to (length xs)-1
        do
            if not (exists (fun elem -&gt; xs.(idx) = elem) ars)
            then
                begin
                    ars.(!i) &lt;- xs.(idx);
                    i := !i+1
                end
            else ()
        done;
        sub ars 0 !i;;
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '584'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/584
  :user_name: takkanm
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/224/
  :language: Haskell
  :time: 2007/07/11 15:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">アレイのuniqということで、アレイをもらってアレイを返す。ごちゃごちゃして、範囲はEnumのみだけど</pre>\n\t"
  :code: "import Data.List ( nub )\nimport Array\n\naryUniq ::( Eq e , Ix i , Enum
    i) =&gt; Array i e -&gt; Array i e\naryUniq a = listArray ( fstBounds a , sndBounds
    a ) $ uniqArrayElem a\n    where \n          uniqArrayElem :: (Ix i, Eq e) =&gt;
    Array i e -&gt; [e]\n          uniqArrayElem a = nub $ Array.elems a\n          fstBounds
    :: (Ix i) =&gt; Array i e -&gt; i\n          fstBounds  a  = fst $ bounds a\n
    \         sndBounds :: (Eq e, Ix i, Enum i) =&gt; Array i e -&gt; i\n          sndBounds
    a = sndBounds' (fstBounds a) $ length $ uniqArrayElem a\n          sndBounds'
    :: (Enum a) =&gt; a -&gt; Int -&gt; a\n          sndBounds' f l = head $ reverse
    $ take l [f..]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '591'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/591
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/07/11 17:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">std::set&lt;T&gt;::insert()</pre>\n\t"
  :code: |
    #include&lt;set&gt;
    #include&lt;iostream&gt;
    template&lt;typename T&gt;
    void uniq_print( const T* begin, const T* end ) {
      using namespace std;
      set&lt;T&gt; s;
      for( const T* i = begin ; i != end ; ++i )
        if( s.insert(*i).second ) cout&lt;&lt; *i&lt;&lt; " ";
      cout&lt;&lt; endl;
    }
    #define nItems(array) (sizeof(array)/sizeof(*(array)))
    int main(void) {
      int xs[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};
      uniq_print( xs, xs+nItems(xs) );
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '594'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/594
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/07/11 18:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">問題文を読み間違えていたので修正</pre>\n\t"
  :code: |
    #include&lt;set&gt;
    #include&lt;vector&gt;
    #include&lt;iostream&gt;
    #include&lt;algorithm&gt;
    using namespace std;
    template&lt;typename T&gt;
    T* uniq( T* begin, T* end ) {
      set&lt;T&gt; s;
      vector&lt;T&gt; t;
      for( const T* i = begin ; i != end ; ++i )
        if( s.insert(*i).second ) t.push_back(*i);
      copy(t.begin(), t.end(), begin );
      return begin+t.size();
    }
    template&lt;typename T&gt;
    void print(const T&amp; x) {
      cout&lt;&lt; x&lt;&lt; " ";
    }
    #define nItems(array) (sizeof(array)/sizeof(*(array)))
    int main(void) {
      int xs[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};
      for_each( xs, uniq( xs, xs+nItems(xs) ), print&lt;int&gt; );
      cout&lt;&lt; endl;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '629'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/629
  :user_name: harupiyo
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/191/
  :language: Perl
  :time: 2007/07/12 09:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  自分ツッコミ\r\ngrep でなくて、map でもいけるようです。\r\n\n\t"
  :code: |
    @xs = (3,1,4,1,5,9,2,6,5,3,5,8,9,7,9);
    print map{$_ if!$t{$_}++}@xs;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '667'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/667
  :user_name: tetsuro6502
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/213/
  :language: Erlang
  :time: 2007/07/12 15:18 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  うーむ、イマイチ\n\t"
  :code: |
    -module(uniq).
    -export([uniq/1]).

    uniq(XS) -&gt;
      uniq(XS, []).

    uniq([First|Rest], Result) -&gt;
      Buff = (Result ++ [First]),
      uniq(Rest -- Buff, Buff);

    uniq([], Result) -&gt;
      Result.
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '690'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/690
  :user_name: kkobayashi
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/12 18:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    xs &lt;- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9)
    unique(xs)
  :tags:
  - R
  :references:
    :url: 
    :title: 
- :id: '769'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/769
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: Tcl
  :time: 2007/07/13 15:20 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  特にこれが一般的な Tcl 風スタイルというわけではありませんが tcllib の struct::list を使うと fold もできますという例です。\n\t"
  :code: |
    package require struct::list

    proc lappend_uniq {l e} {
      if {[lsearch $l $e] == -1} {lappend l $e}
      set l
    }

    proc uniq {l} {
      ::struct::list fold $l {} lappend_uniq
    }

    # % uniq {3 1 4 1 5 9 2 6 5 3 5 8 9 7 9}
    # 3 1 4 5 9 2 6 8 7
  :tags:
  - Tcl
  :references:
    :url: 
    :title: 
- :id: '821'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/821
  :user_name: lufia
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/242/
  :language: awk
  :time: 2007/07/14 05:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">こういうのは得意だね</pre>\n\t"
  :code: "BEGIN {\n\tn = split(\"3 1 4 1 5 9 2 6 5 3 5 8 9 7 9\", xs)\n\tna = uniq(xs,
    n, a)\n\tfor(i = 1; i &lt;= na; i++)\n\t\tprint a[i]\n}\nfunction uniq(xs, n,
    a,\t\tna,x,i) {\n\tfor(i = 1; i &lt;= n; i++)\n\t\tif(!x[xs[i]]++)\n\t\t\ta[++na]
    = xs[i]\n\treturn na\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '864'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/864
  :user_name: rubikitch
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/105/
  :language: Lua
  :time: 2007/07/14 18:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  んー、配列の表示すら自分で関数書かないといけないのは嫌だ…\n\t"
  :code: |
    function uniq(ary)
      exists = {}
      ret = {}
      table.foreachi(ary, function(i, x)
                            if exists[x] ~= 1 then
                              table.insert(ret, x)
                              exists[x] = 1
                            end
                   end)
      return ret
    end

    function print_array(ary)
      s = "[ "
      table.foreach(ary, function(k,v) s = s .. string.format("%s ",v) end)
      s = s.."]"
      print(s)
    end

    print_array(uniq({3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9}))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '866'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/866
  :user_name: rubikitch
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/105/
  :language: D
  :time: 2007/07/14 19:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    module doukaku;
    private import std.stdio;
    A[] uniq(A)(A[] ary) {          // 型推論！
        A[A] exists;
        A[] ret;
        foreach(x; ary) {
            if (!(x in exists)) {
                ret ~= x;
                exists[x] = 1;
            }
        }
        return ret;
    }

    void main() {
        writefln(uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '891'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/891
  :user_name: morchin
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/07/15 03:03 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  oceanさんの方法とほとんど同じですが…。\n\t"
  :code: |
    def uniq(xs):
        s = set()
        return [s.add(x) or x for x in xs if x not in s]

    print uniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '910'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/910
  :user_name: morchin
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/78/
  :language: 
  :time: 2007/07/15 09:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  よく見たら#533の匿名さんのコードと全く同じだった…。orz\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '964'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/964
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: Lua
  :time: 2007/07/16 04:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    function uniq(a)
      local seen = {}
      local a2 = {}
      for _,v in ipairs(a) do
        if not seen[v] then
          seen[v] = true
          table.insert(a2, v)
        end
      end
      return a2
    end

    function show_array(t)
      print("["..table.concat(t, " ").."]")
    end

    show_array(uniq{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9})
  :tags:
  - Lua5.1
  :references:
    :url: 
    :title: 
- :id: '1029'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1029
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/07/17 11:43 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">Javaでがんばる</pre>\n\t"
  :code: |
    import java.util.Arrays;
    import java.util.LinkedHashSet;

    public class Unique {
        public static Object[] toUniqueArray(Object[] array) {
            return new LinkedHashSet(Arrays.asList(array)).toArray();
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1048'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1048
  :user_name: JDO
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/257/
  :language: Java
  :time: 2007/07/17 19:50 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Java です。\r\n実行効率なんぞ、そっちのけで、面白い解き方という観点から、オブジェクト指向 と 関数型の考え方 (再帰) を合体した、回答です。\r\n\r\n自分の感覚的には、関数型の
    \"fold\" と同じ発想です。ただ、それをオブジェクト的にしただけです。\r\n\r\nもっと他に面白い着眼点ないかな？\n\t"
  :code: |
    class UniqList
      {
      private int value ;
      private UniqList next ;

      // このオブジェクトは、ひとつの値 value しか保持しない。
      public UniqList (int value)
        {
        this.value = value ;
        this.next = null ;
        }

      // ★ ここがポイント"add" ★
      // このオブジェクトが保持している値と同じなら、
      // 新規性なしゆえに、処理中止。
      // そうでなければ、自分が知らないだけで、後ろ
      // に続くオブジェクト next 以降が保持しているかも
      // 知れないので、next に処理を異常。
      // next がなければ、それこそ新規の値なので、
      // 自分の後ろに追加する。
      // 要は、再帰処理ね。

      public void add (int another)
        {
        if (another==this.value)
          {return ;}

        else if (this.next==null)
          {this.next = new UniqList (another) ;}

        else
          {this.next .add (another) ;}
        }

      // 配列につくり直す
      public int [] toArray ()
        {
        if (this.next==null)
          {
          int [] array = new int [1] ;
          array [0] = this.value ;
          return array ;
          }

        else
          {
          int [] tail = this.next .toArray () ;
          int [] array = new int [tail.length+1] ;
          System.arraycopy (tail,0, array,1, tail.length) ;
          array[0] = this.value ;
          return array ;
          }
        }

      // お試しルーチン
      public static void main (String [] _)
        {
        int [] xs = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9} ;

        UniqList ul = new UniqList (xs[0]) ;
        for (int i=1; i&lt;xs.length; ++i)
          {ul .add (xs [i]) ;}

        int [] uniq = ul .toArray () ;
        }
      }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1077'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1077
  :user_name: JDO
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/257/
  :language: Prolog
  :time: 2007/07/18 15:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Prolog です。 最近、Prolog にはまってます。\r\n\r\nユニークにする述語が、toUniq_uniq。\r\n\r\nイメージとしては、第2引数(Ts)に対して、第1引数(Xs)の要素(X)を順番に追加のトライをするのですが、それが既にTsに含まれている(contains(Ts,X))ものであれば、Tsへは追加されず、そうでない時にはTsに追加される。そして、同じことを
    Xs の残りの要素についても繰り返すという仕組みです。(Tsの初期値はもちろん空っぽリスト [] です。) 第1引数が空っぽになったら、Ts の中身を 第3引数にコピーして終了。\r\n\r\ntoUniq_uniq
    の処理結果は、(Ts に X を追加する処理の関係で) オリジナルに対して、リバースされてしまっているので、toUniq_reverse でリバースしなおしてます。\r\n\n\t"
  :code: |
    contains([Item|RestItems],Item) :- !.
    contains([Item|RestItems],Item_) :- contains(RestItems,Item_).

    toUniq_uniq([],Ts,Ts).
    toUniq_uniq([Item|Xs],Ts,Ys) :- contains(Ts,Item), !, toUniq_uniq(Xs,Ts,Ys).
    toUniq_uniq([Item|Xs],Ts,Ys) :- toUniq_uniq(Xs,[Item|Ts],Ys).

    toUniq_reverse([],Ts,Ts).
    toUniq_reverse([Item|Xs],Ts,Ys) :- toUniq_reverse(Xs,[Item|Ts],Ys).

    toUniq(Xs,Ys) :- toUniq_uniq(Xs,[],Ts), toUniq_reverse(Ts,[],Ys).

    ?- toUniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9], Ys).
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1088'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1088
  :user_name: katsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/117/
  :language: Prolog
  :time: 2007/07/19 01:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#496は無かったことにしたいんですけど。orz\r\n $ pl -sq uniq.pl\r\n[3,
    1, 4, 5, 9, 2, 6, 8, 7]\r\n $</pre>\n\t"
  :code: |
    % uniq.pl
    uniq([],[]).
    uniq([A|As],[A|Bs]):-uniq(As,Bss), delete(Bss,A,Bs).

    :-uniq([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9],W), writeln(W).
  :tags:
  - SWI-prolog
  :references:
    :url: 
    :title: 
- :id: '1349'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1349
  :user_name: 沢渡 みかげ
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/101/
  :language: Mathematica
  :time: 2007/07/22 11:55 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">一発でできる便利な関数は無いようなので，\r\n取り出した要素を残りのリストから消しつつ処理．\r\n\r\n実行例：\r\n\r\nIn[2]:=
    uniq[{1, 3, 5, 5, 4, 1, 2, 1}]\r\n\r\nOut[2]= {1, 3, 5, 4, 2}\r\n</pre>\n\t"
  :code: |
    uniq[l_] := Module[{r, x, t},
       r = {};
       t = l;
       While[Length[t] &gt; 0,
        x = t[[1]];
        r = Append[r, x];
        t = Select[t, x != # &amp;];
        ];
       r
       ];
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1579'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1579
  :user_name: にしお
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/07/30 06:47 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">誰も言及しないようなので…\r\nPython2.5では下のようにset(xs)で要素の重複を取り除くことができますが、\r\nこれは「集合型」なので順序が保存されません。\r\n速度が問題にならないのであれば\r\nsortedを使って元の順番に並べ直してやるのも手です。</pre>\n\t"
  :code: |
    &gt;&gt;&gt; xs = list("314159265358979")
    &gt;&gt;&gt; xs
    ['3', '1', '4', '1', '5', '9', '2', '6', '5', '3', '5', '8', '9', '7', '9']
    &gt;&gt;&gt; set(xs)
    set(['1', '3', '2', '5', '4', '7', '6', '9', '8'])
    &gt;&gt;&gt; sorted(set(xs), key = xs.index)
    ['3', '1', '4', '5', '9', '2', '6', '8', '7']
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1644'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1644
  :user_name: PoohKid
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/180/
  :language: Ruby
  :time: 2007/08/01 06:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">C#からRubyへ感覚を移行する練習です。\r\n1.foreach, Containsのまま移植\r\n2.injectを使いローカル変数を使用せずオブジェクトを返す(#467)\r\n3.uniqメソッドを使用(#448)
    \r\n全て同じ結果になります。\r\n\r\nHackety Hackにて作成／実行\r\nhttp://hacketyhack.net/\r\nhttp://www.radiumsoftware.com/0705.html#070515\r\n</pre>\n\t"
  :code: |
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]

    # C#の例(#470)をそのままRubyに変換
    us = []
    xs.each do |x|
      unless us.member?(x)
        us &lt;&lt; x
      end
    end
    p us

    # moroさん(#467) injectを使いローカル変数を使用せずオブジェクトを返す
    p xs.inject([]){|a, e| a.member?(e) ? a : a &lt;&lt; e }

    # 匿名さん(#448) uniqメソッドを使用
    p xs.uniq
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1664'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1664
  :user_name: ether
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/96/
  :language: PowerShell
  :time: 2007/08/01 15:38 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  \n\t"
  :code: |
    $xs = 3,1,4,1,5,9,2,6,5,3,5,8,9,7,9
    $seen = @{}
    foreach ($x in $xs) {
      if (-not $seen[$x]) {$x}
      $seen[$x] = $true
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1710'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1710
  :user_name: tomatsu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/323/
  :language: Pnuts
  :time: 2007/08/02 12:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    function uniq(a){
      s=set()
      l=list()
      for (e:a){
         if (!s.contains(e)){
           l.add(e)
           s.add(e)
         }
      }
      l
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1854'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1854
  :user_name: yattom
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/335/
  :language: awk
  :time: 2007/08/05 02:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">入力行をuniqして表示します。\r\n内部ではいったん配列に格納して、array_uniq()
    で\r\n値がユニークな配列を作ってます(なのでお題を満たす)。\r\n\r\nawkの配列って実はハッシュなので、微妙ですが。\r\nセパレータで区切った文字列を扱うほうが自然かも。</pre>\n\t"
  :code: "function array_uniq(array, size, result,   i, ridx, items) {\n\tridx = 0;\n\tfor(i
    = 0; i &lt; size; i++) {\n\t\tif(!(array[i] in items)) {\n\t\t\tresult[ridx++]
    = array[i]\n\t\t\titems[array[i]] = 1\n\t\t}\n\t}\n\treturn ridx\n}\n\n{\n\tinput[NR
    - 1] = $0\n}\n\nEND {\n\trsize = array_uniq(input, NR, result)\n\tfor(i = 0; i
    &lt; rsize; i++) {\n\t\tprint result[i]\n\t}\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1956'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/1956
  :user_name: whitebell
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/340/
  :language: Perl
  :time: 2007/08/07 03:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Tie::IxHashを使えば順序を保持するハッシュが使えるので。\n\t"
  :code: |
    use Tie::IxHash;

    my @xs = qw/3 1 4 1 5 9 2 6 5 3 5 8 9 7 9/;

    tie my %ixhash, Tie::IxHash;
    foreach (@xs) {
        $ixhash{$_}++;
    }
    print join ',', keys %ixhash;
  :tags: []
  :references:
    :url: /web/20100605050814/http://search.cpan.org/~gsar/Tie-IxHash/lib/Tie/IxHash.pm
    :title: ''
- :id: '2099'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2099
  :user_name: higeorange
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/194/
  :language: Io
  :time: 2007/08/13 05:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    xs unique
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2101'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2101
  :user_name: shg
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/383/
  :language: Matlab
  :time: 2007/08/13 06:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  MATLABの標準関数uniqueはソートした結果を返すが、オプションを与えることによって各要素のソート前の位置を得ることができる。それを用いて元の順序を復元する。\n\t"
  :code: |
    function y = unsortuniq(x)
    [b i] = unique(x,'first');
    bi = sortrows([b;i]',2)';
    y = bi(1,:);
  :tags:
  - MATLAB7.4
  :references:
    :url: 
    :title: 
- :id: '2107'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2107
  :user_name: miyamuko
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/382/
  :language: xtal
  :time: 2007/08/13 12:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    Iterator::uniq: method() {
        seen: Map();
        return fiber() {
            this.each {
                if (!seen[it]) {
                    yield it;
                    seen[it] = true;
                }
            }
        }
    }

    xs: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9];
    xs.each.uniq { it.p; }

    expected: [3, 1, 4, 5, 9, 2, 6, 8, 7];
    assert xs.each.uniq.to_a == expected;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2298'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2298
  :user_name: jz5
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/08/18 04:33 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">C#と同じですね……。</pre>\n\t"
  :code: |
    Sub Main()
        Dim xs() As Object = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9}
        Dim ret() As Object = UniqArray(xs)

        For Each obj As Object In ret
            Console.Write(obj.ToString &amp; ", ")
        Next
    End Sub

    Public Function UniqArray(ByVal ary() As Object) As Object()
        Dim uniq As New ArrayList
        For Each obj As Object In ary
            If Not uniq.Contains(obj) Then
                uniq.Add(obj)
            End If
        Next
        Return uniq.ToArray
    End Function
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2434'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2434
  :user_name: jz5
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/08/22 23:12 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">短くなりました。VS2008Betaインストール記念。\r\nObjectの配列なら\r\nDim
    ary() As Object = From x In xs Distinct.ToArray</pre>\n\t"
  :code: |
    Dim uniq = From x In xs Distinct
  :tags:
  - VB9.0
  :references:
    :url: 
    :title: 
- :id: '2437'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2437
  :user_name: jz5
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/344/
  :language: 
  :time: 2007/08/23 00:05 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">Dim uniq = xs.Distinct\r\nだけで良いようです……。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2448'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2448
  :user_name: nobsun
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/08/23 02:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">nub だと最悪のケースでO(n^2) になる。以下のuniqなら要素がOrd(順序)クラス\r\nという条件のもとで最悪ケースでO(n
    log n)にできる。\r\n\r\n最悪ケースのベンチマークは以下のとおり\r\n\r\n*Main&gt; length $ uniq [1..10000]\r\n10000\r\n(0.13
    secs, 11539780 bytes)\r\n*Main&gt; length $ uniq [1..100000]\r\n100000\r\n(1.00
    secs, 121637004 bytes)\r\n*Main&gt; length $ nub [1..10000]\r\n10000\r\n(0.98
    secs, 1045976 bytes)\r\n*Main&gt; length $ nub [1..100000]\r\n100000\r\n(95.85
    secs, 8910200 bytes)\r\n\r\n\r\n</pre>\n\t"
  :code: |
    import Data.List

    app o f x y = f x `o` f y
    cmpapp = app compare
    eqapp  = app eq

    uniq :: Ord a =&gt; [a] -&gt; [a]
    uniq  = map snd  . sort . map head . groupBy (eqapp snd) . sortBy (cmpapp snd) . zip [1..]

    uniq' :: Eq a =&gt; [a] -&gt; [a]
    uniq' = nub
  :tags:
  - O(nlogn)
  :references:
    :url: 
    :title: 
- :id: '2454'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2454
  :user_name: nobsun
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/08/23 08:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あれあれコードを写しそこねてる。ごめんなさい。\r\neq なんて関数ないし、型宣言を文脈をつけて書くのが正しい。</pre>\n\t"
  :code: |
    import Data.List

    app :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; a -&gt; c)
    app o f x y = f x `o` f y

    cmpapp :: Ord b =&gt; (a -&gt; b) -&gt; (a -&gt; a -&gt; Ordering)
    cmpapp = app compare

    eqapp :: Eq b =&gt; (a -&gt; b) -&gt; (a -&gt; a -&gt; Bool)
    eqapp  = app (==)

    uniq :: Ord a =&gt; [a] -&gt; [a]
    uniq  = map snd  . sort . map head . groupBy (eqapp snd) . sortBy (cmpapp snd) . zip [1..]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2474'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2474
  :user_name: tea
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/402/
  :language: Python
  :time: 2007/08/24 07:25 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">リスト内包表記の方がスマートだと思うけど、\r\none-linerに拘ってreduceで。ポイントは第３引数。\r\n関数部分は、末尾再起で関数に直すとわかり易いです。\r\n\r\n※
    python3kの場合は、 from functools import reduce</pre>\n\t"
  :code: |
    uniq = lambda xs: reduce(lambda a,b: a+[b] if b not in a else a, xs, [])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2566'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2566
  :user_name: 管理者
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/411/
  :language: 
  :time: 2007/08/28 08:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">同じくMoreUtilsを使ったPerl6版</pre>\n\t"
  :code: ''
  :tags:
  - Perl6
  :references:
    :url: /web/20100605050814/http://d.hatena.ne.jp/fbis/20070728/1185599125
    :title: どう書くでリハビリ
- :id: '2674'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2674
  :user_name: susu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/218/
  :language: Python
  :time: 2007/08/30 06:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "def uniq(xs=[]):\n\tfor i in xrange(len(xs)):\n\t\tn=i+1\n\t\t\n\t\twhile
    n&lt;len(xs):\n\t\t\tif xs[i]==xs[n]:\n\t\t\t\tdel xs[n]\n\t\t\telse: n+=1\n\t\n\treturn
    xs\n\nuniq([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])\nuniq([1,1,2,2,2,1,1])\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2813'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2813
  :user_name: nori
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/59/
  :language: Python
  :time: 2007/09/03 01:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">新たなお題をみて、過去の出題に回答・・・。\r\n再帰なコードしか投稿していないなぁ。\r\nひょっとして再帰フェチ？</pre>\n\t"
  :code: |
    def unique(xs):
      if len(xs)&lt;2:
        return xs
      u = unique(xs[:-1])
      if xs[-1] in u:
        return u
      else:
        return u + xs[-1:]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2907'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/2907
  :user_name: Y
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/428/
  :language: Mathematica
  :time: 2007/09/04 17:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">マニュアルの方法をちょっとだけ改良しました\r\n</pre>\n\t"
  :code: |
    uniq[x_] := Reap[Sow[True, x], _, #1 &amp;][[2]]

    uniq@{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9}
  :tags: []
  :references:
    :url: /web/20100605050814/http://reference.wolfram.com/mathematica/ref/Reap.html
    :title: Reap - Wolfram Mathematica
- :id: '3660'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3660
  :user_name: yohei
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/415/
  :language: Prolog
  :time: 2007/11/02 08:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    :- use_module(library(lists)).
    :- list_to_set([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9], S), writeln(S).
  :tags:
  - SWI-Prolog
  :references:
    :url: 
    :title: 
- :id: '3840'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3840
  :user_name: faultier
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/545/
  :language: Objective
  :time: 2007/11/11 07:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    #import &lt;Foundation/Foundation.h&gt;

    @interface NSArray (Uniq)
    - (NSArray *)uniq;
    @end

    @implementation NSArray (Uniq)
    - (NSArray *)uniq
    {
      NSMutableArray* uniqArray = [NSMutableArray array];
      for (id obj in self) {
        if (![uniqArray containsObject:obj]) {
          [uniqArray addObject:obj];
        }
      }
      return [NSArray arrayWithArray:uniqArray];
    }
    @end

    int main(void)
    {
      NSAutoreleasePool* pool = [NSAutoreleasePool new];

      NSArray* array = [NSArray arrayWithObjects:@"hoge", @"fuga", @"hoge", @"foo", @"bar", @"Fizz", @"foo", @"Buzz", nil];

      NSLog(@"%@", array);
      NSLog(@"%@", [array uniq]);

      [pool release];
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3877'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3877
  :user_name: matyr
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/343/
  :language: 
  :time: 2007/11/11 21:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  「uniq」相当の日本語が思いつかない…。\n\t"
  :code: |
    配列：uniq＝「｜ｒ｜ｒ＝配列！作る。
    　！「｜ｒ｜
    　　(未定義＝＝(ｒ！「｜ｘ｜ｘ＝＝自分」(自分)選ぶ　１番 見る))！なら「ｒ！(自分)入れる」実行。
    　　 」(ｒ)それぞれ実行。
    　ｒ」。

    ラベル！(配列！3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 作る　uniq)作る。
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3902'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3902
  :user_name: Psychs
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/554/
  :language: Objective
  :time: 2007/11/12 09:05 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  dictionary を使って高速化してみました。\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n\n@interface NSArray (Uniq)\n-
    (NSArray*)uniq;\n@end\n\n@implementation NSArray (Uniq)\n- (NSArray*)uniq\n{\n
    \ NSMutableDictionary* dic = [NSMutableDictionary dictionary];\n  NSMutableArray*
    result = [NSMutableArray array];\n  for (id obj in self) {\n    if (![dic objectForKey:obj])
    {\n      [result addObject:obj];\n      [dic setObject:obj forKey:obj];\n    }\n
    \ }\n  return result;\n}\n@end\n\nint main(int argc, char** argv)\n{\n  NSAutoreleasePool*
    pool = [NSAutoreleasePool new];\n  \n  NSArray* array = [NSArray arrayWithObjects:@\"a\",
    @\"b\", @\"c\", @\"b\", @\"d\", @\"a\", @\"c\", @\"e\", nil];  \n  \n  NSLog(@\"%@\",
    array);\n  NSLog(@\"%@\", [array uniq]);\n  \n  [pool release];\n  return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3908'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3908
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/12 09:31 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">実質的な処理は3行目だけです</pre>\n\t"
  :code: |
    list="3,1,4,1,5,9,2,6,5,3,5,8,9,7,9"
    ar=listを","で区切る
    ar=arの0を表重複削除
    arを","で配列結合して表示
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3927'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3927
  :user_name: faultier
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/545/
  :language: 
  :time: 2007/11/13 05:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ああそうか、containsObjectは遅いですよね。なるほど。\r\n[dic allValues]でもいいかなと思ったけど、\r\nよく考えたらDictionaryからArrayにするよりaddObjectのが速いか。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3932'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3932
  :user_name: ihag
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/560/
  :language: Ruby
  :time: 2007/11/13 07:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">もはやRubyである意味はありませんが……．\r\nregexpらぶ</pre>\n\t"
  :code: |
    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9].join(' ')

    code = 'xs'
    1.upto(9) do |i|
      code &lt;&lt; ".gsub(/#{i}/, '*').sub(/\\*/, '#{i}').gsub(/ \?\\*/, '')"
    end

    p eval(code)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3942'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/3942
  :user_name: Psychs
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/554/
  :language: 
  :time: 2007/11/13 11:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">[dic allValues] は順序が保てないんでまずいんじゃないかと。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4500'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/4500
  :user_name: かも
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/67/
  :language: Bash
  :time: 2007/11/30 08:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>シェルスクリプトでこういうのを書きたくなる場面ってよくありますよね。</p>\n\n\t"
  :code: |
    #!/bin/bash

    declare -a result
    declare rsize

    ordered_uniq(){
      local n
      result=()
      rsize=0
      for i in $*
      do
        n=_$i
        if [[ "${!n}" = "" ]]; then
          local _$i=1
          result[$((rsize++))]=$i
        fi
      done
    }
    ordered_uniq 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9
    echo ${result[@]}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4727'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/4727
  :user_name: vtwntmtn
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/380/
  :language: Erlang
  :time: 2007/12/10 17:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">リスト内包表記を使って。\r\n\r\n1&gt; c(uniq).\r\n{ok,uniq}\r\n2&gt;
    XS = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9].\r\n[3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]\r\n3&gt;
    uniq:uniq(XS).\r\n[3,1,4,5,9,2,6,8,7]\r\n</pre>\n\t"
  :code: |
    -module(uniq).
    -export([uniq/1]).

    uniq([]) -&gt; [];
    uniq([X | XS]) -&gt; [X | uniq([Y || Y &lt;- XS, X =/= Y])].
  :tags:
  - Erlang/OTP_R10B-10
  :references:
    :url: 
    :title: 
- :id: '4734'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/4734
  :user_name: omoikani
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/374/
  :language: StandardML
  :time: 2007/12/10 18:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>こんなモンでしょう。</p>\n\n\t"
  :code: |
    fun uniq l = foldr (fn (b, a) =&gt; b :: List.filter (fn x =&gt; x &lt;&gt; b) a) [] l
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4768'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/4768
  :user_name: pooq
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2007/12/11 21:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">「~.」という動詞（演算子）が、お題の要求を満たすようです。\r\n数値のリストだけでなく、文字のリストにも使えます。\r\n罫線で囲われているのは、boxというもので、引用符みたいなものです。\r\nこれに入れることで、box単位で処理できます。\r\n\r\n
    \  uniq 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9\r\n3 1 4 5 9 2 6 8 7\r\n   uniq 'aabbcc
    daeafag hijk'\r\nabc defghijk\r\n   s=. 'hoge';'hoge';'fizz';'hoge';'buzz'\r\n
    \  s\r\n+----+----+----+----+----+\r\n|hoge|hoge|fizz|hoge|buzz|\r\n+----+----+----+----+----+\r\n
    \  uniq s\r\n+----+----+----+\r\n|hoge|fizz|buzz|\r\n+----+----+----+\r\n</pre>\n\t"
  :code: |
    uniq=.~.
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5070'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5070
  :user_name: susu
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/218/
  :language: OCaml
  :time: 2007/12/31 07:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>foldがすごすぐる</p>\n\n\t"
  :code: |
    let uniq accm x = if (List.mem x accm) then accm else x::accm ;;

    let list_uniq lst = List.rev (List.fold_left uniq [] lst);;
    let array_uniq arr = Array.of_list (List.rev (Array.fold_left uniq [] arr));;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5082'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5082
  :user_name: g000001
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/405/
  :language: Other
  :time: 2008/01/01 01:57 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">全然関数型言語っぽくないですが、\r\n当時、結構こういう風に書いてるのも多かったようです。\r\n\r\n実行結果:\r\n
    FUNCTION   EVALQUOTE   HAS BEEN ENTERED, ARGUMENTS..\r\nUNIQ\r\n\r\n((3 1 4 1
    5 9 2 6 5 3 5 8 9 7 9))\r\n\r\nEND OF EVALQUOTE, VALUE IS ..\r\n(3 1 4 5 9 2 6
    8 7)</pre>\n\t"
  :code: "DEFINE((\n(REVERSE (LAMBDA (LST) (PROG (L RES)\n                  (SETQ
    L LST)\n            L     (COND ((NULL L) (RETURN RES)))\n                  (SETQ
    RES (CONS (CAR L) RES))\n                  (SETQ L (CDR L))\n                  (GO
    L))))\n \n(MEMBER (LAMBDA (ITEM LST) (COND\n           ((EQ ITEM (CAR LST)) LST)\n
    \          (T (MEMBER ITEM (CDR LST))))))\n\n(UNIQ (LAMBDA (LST) (PROG (L RES)\n
    \              (SETQ L LST)\n         L     (COND ((NULL L) (RETURN (REVERSE RES))))\n
    \              (COND ((MEMBER (CAR L) RES) ())\n                     (T (SETQ
    RES (CONS (CAR L) RES))))\n               (SETQ L (CDR L))\n               (GO
    L))))  ))\n\nUNIQ((3 1 4 1 5 9 2 6 5 3 5 8 9 7 9))\n"
  :tags:
  - Lisp1.5
  :references:
    :url: 
    :title: 
- :id: '5139'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5139
  :user_name: saws
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/642/
  :language: Other
  :time: 2008/01/03 09:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>地道に処理するとこんな感じになるのでしょうか.\n最初の要素を無視せざるを得ないのが妙な感じです.</p>\n\n\t"
  :code: "xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]\n(xs.size-1).times{|i|
    \n  if xs[0..i].include?(xs[i+1])\n    xs.delete_at(i+1)\n    redo\n  end\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5596'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5596
  :user_name: g000001
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/405/
  :language: Arc
  :time: 2008/01/31 07:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Arcです。\r<br>Arcでは、dedupがお題と同じ動作をするようです。\n\t"
  :code: |
    (dedup '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9))
    ;=&gt; (3 1 4 5 9 2 6 8 7)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5746'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5746
  :user_name: queck
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/681/
  :language: Other
  :time: 2008/02/12 12:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Factor です。reduce を使いました。</p>\n\n\t"
  :code: |
    USING: kernel sequences ;

    : f ( seq -- uniqseq )
        { } [ 2dup swap member? [ drop ] [ add ] if ] reduce ;

    USE: tools.test
    [ { 3 1 4 5 9 2 6 8 7 } ]
    [ { 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 } f ] unit-test
  :tags:
  - Factor
  :references:
    :url: 
    :title: 
- :id: '5829'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5829
  :user_name: まさぽん
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/711/
  :language: Scheme
  :time: 2008/02/22 02:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">実行例:\r\ngosh&gt; (uniq-vector '#(3 1 4 1 5
    9 2 6 5 3 5 8 9 7 9))\r\n#(3 1 4 5 9 2 6 8 7)</pre>\n\t"
  :code: |
    (use srfi-1)
    (define (uniq-vector vec)
      (list-&gt;vector (delete-duplicates (vector-&gt;list vec))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5832'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/5832
  :user_name: Nemo
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/685/
  :language: PostScript
  :time: 2008/02/22 17:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>無難に...</p>\n\n\t"
  :code: |
    %!PS

    /Uniq { % [array] Uniq [new array]
        [
            100 dict
            2 index {
                dup 2 index exch known {
                    pop
                }{
                    2 copy dup put exch
                } ifelse
            } forall
            pop
        ]
        exch pop
    } def

    % -------- Test -------
    [3 1 4 1 5 9 2 6 5 3 5 8 9 7 9] Uniq ==
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6493'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/6493
  :user_name: genzou
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/06/14 12:31 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n\t"
  :code: |
    def uniqueList( xs ){
        xs.unique()
    }

    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]
    println uniqueList(xs)
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '7705'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/7705
  :user_name: silverwire
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/646/
  :language: Batchfile
  :time: 2008/09/25 06:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">バッチで。(バッチには配列が無いので、変数で代用しています。)</pre>\n\t"
  :code: "@echo off\nsetlocal enabledelayedexpansion\n  set t=\n  set #=0\n\n  if
    \"%*\" == \"\" exit /b 1\n\n  for %%v in (%*) do (\n    if not defined %%v (\n
    \     set %%v=!#!\n      set /a #+=1\n    )\n  )\n\n  for /f \"tokens=1,2 delims==\"
    %%i in ('set ^| findstr /r \"^[0-9]\"') do set %%j=%%i\n\n  set /a #-=1\n  for
    /l %%i in (0,1,%#%) do set t=!t!!%%i! \nendlocal &amp; echo %t%\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7706'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/7706
  :user_name: silverwire
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/646/
  :language: 
  :time: 2008/09/25 19:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">処理的にまずい箇所があったので、一部修正。\r\n\r\n15c15\r\n&lt;
    \  for /f \"tokens=1,2 delims==\" %%i in ('set ^| findstr /r \"^[0-9]\"') do set
    %%j=%%i\r\n---\r\n&gt;   for /f \"tokens=1,2 delims==\" %%i in ('set ^| findstr
    /r \"^[0-9]\"') do set _%%j=%%i\r\n18c18\r\n&lt;   for /l %%i in (0,1,%#%) do
    set t=!t!!%%i! \r\n---\r\n&gt;   for /l %%i in (0,1,%#%) do set t=!t!!_%%i! </pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8027'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8027
  :user_name: hchbaw
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/950/
  :language: Other
  :time: 2008/11/11 11:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>Clojure です、distinct のようです。Clojure では、 sequence が返ってくところが特徴的ですね。\n</p>\n\n\n\n\t"
  :code: |
    (distinct [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9])
    ;=&gt; (3 1 4 5 9 2 6 8 7)
  :tags:
  - Clojure
  :references:
    :url: 
    :title: 
- :id: '8125'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8125
  :user_name: bonotake
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/976/
  :language: Other
  :time: 2008/12/07 03:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>仕様記述言語Alloyで。ysが戻り値です。\r</p>\n<p>\r</p>\n<p>Anyという適当な何かの配列を対象に。</p>\n</div>\n\t"
  :code: |
    sig Any {}

    pred uniq (xs, ys: seq Any) {
      #ys = #xs[Int]
      all i: Int | 0 &lt;= i and i &lt; #xs implies
        let dups = {j: Int | some k: Int | 0 &lt;= k and k &lt; j and j &lt;= i and xs[k]=xs[j]} |
          i !in dups implies ys[i-#dups] = xs[i]
    }

    run uniq for 6 but 4 int
  :tags:
  - Alloy
  :references:
    :url: 
    :title: 
- :id: '8281'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8281
  :user_name: 割と普通
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/581/
  :language: C
  :time: 2009/01/04 12:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <div class=\"section\">\n<p>LINQ使ってワンライナー。\r</p>\n<p>\r</p>\n<p>LINQのお陰でCollection関係の操作が楽チンです。</p>\n</div>\n\t"
  :code: |
    foreach (int n in new List&lt;int&gt;() { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9 }.Distinct()) Console.WriteLine(n);
  :tags:
  - LINQ
  :references:
    :url: 
    :title: 
- :id: '8368'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8368
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2009/01/19 13:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n\t"
  :code: |
    def my_uniq(x)
      r=[]
      x.each{|i|r += [i]-r}
      r
    end

    xs = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]
    p my_uniq(xs) # =&gt; [3, 1, 4, 5, 9, 2, 6, 8, 7]
  :tags:
  - 1.8.6
  - ruby
  :references:
    :url: 
    :title: 
- :id: '8514'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8514
  :user_name: 匿名
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2009/02/16 02:32 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Mathematica 7以降にはDeleteDuplicatesがあります。</p>\n\n\t"
  :code: |
    DeleteDuplicates@{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9}

    {3, 1, 4, 5, 9, 2, 6, 8, 7}
  :tags: []
  :references:
    :url: /web/20100605050814/http://reference.wolfram.com/mathematica/ref/DeleteDuplicates.html
    :title: DeleteDuplicates
- :id: '8622'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/8622
  :user_name: selpo
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/1013/
  :language: C
  :time: 2009/03/10 09:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  すごく微妙です。速いのやら遅いのやら…。一応、これでもいろいろ考えたんですがね。\r<br>ListのContins()は遅そうですが、Dictionaryだと順番が変わりうるし、両方だと、メモリが…。\r<br>"
  :code: |
    using System;
    using System.Collections.Generic
    using System.Text;
    class P
    {
        static void Main(string[] args)
        {
            var tmp = new List&lt;int&gt;()
                { 3, 1, 4, 1, 5, 9, 2
                , 6, 5, 3, 5, 8, 9, 7, 9 };
            tmp.PrintArray();
            tmp.Unique.PrintArray();
        }
        static IList&lt;T&gt; Unique&lt;T&gt;(this IList&lt;T&gt; array)
        {
            var length = array.Count;
            var tmp = new List&lt;T&gt;();
            for (var i = 0; i &lt; length; i++)
            {
                tmp.Add(array[i]);
                while (i &lt; length - 1
                         &amp;&amp; tmp.Contains(array[i + 1]))
                    i++;
            }
            return tmp;
        }
        static void PrintArray&lt;T&gt;(this T[] array)
        {
            string str = ToRawString&lt;T&gt;(array);
            Console.Write(str);
        }
        static string ToRawString&lt;T&gt;(this T[] array)
        {
            var sb = new StringBuilder(3 * array.Length);
            sb.Append("{ ");
            for (int i = 0; i &lt; array.Length - 1; i++)
                sb.Append(array[i] + ", ");
            sb.Append(array[array.Length - 1] + " }");
            return sb.ToString();
        }
    }
  :tags:
  - C#3.0
  :references:
    :url: 
    :title: 
- :id: '9091'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/9091
  :user_name: bleis-tift
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/732/
  :language: SQL
  :time: 2009/06/10 06:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>SQL Server 2008 で確認しました。</p>\n\n\t"
  :code: |
    WITH
      Input(i, n) AS (
        SELECT 1, 3
        UNION ALL SELECT 2, 1
        UNION ALL SELECT 3, 4
        UNION ALL SELECT 4, 1
        UNION ALL SELECT 5, 5
        UNION ALL SELECT 6, 9
        UNION ALL SELECT 7, 2
        UNION ALL SELECT 8, 6
        UNION ALL SELECT 9, 5
        UNION ALL SELECT 10, 3
        UNION ALL SELECT 11, 5
        UNION ALL SELECT 12, 8
        UNION ALL SELECT 13, 9
        UNION ALL SELECT 14, 7
        UNION ALL SELECT 15, 9
      )
    SELECT
        n
    FROM
        Input P
    WHERE
        NOT EXISTS(
          SELECT * FROM Input C
          WHERE P.n = C.n AND P.i &gt; C.i
        )
    ORDER BY
        i
  :tags:
  - QDLMWMLVAoYCEQBW
  :references:
    :url: 
    :title: 
- :id: '9515'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/9515
  :user_name: margarite
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/741/
  :language: PowerShell
  :time: 2009/08/25 09:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>コマンドレットで</p>\n\n\t"
  :code: |
    3,1,4,1,5,9,2,6,5,3,5,8,9,7,9 | Select-Object -Unique
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10398'
  :parent_id: '16'
  :url: http://ja.doukaku.org/comment/10398
  :user_name: gushwell
  :user_url: /web/20100605050814/http://ja.doukaku.org/user/1046/
  :language: C
  :time: 2010/04/16 21:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  LINQを使たコードです。 \r\nintに限定しないようにジェネリックメソッドにしました。\n\t"
  :code: |
    static T[] Uniq&lt;T&gt;(T[] array) {
         return array.Distinct().ToArray();
    }
  :tags: []
  :references:
    :url: 
    :title: 
