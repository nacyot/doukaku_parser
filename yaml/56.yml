---
:id: '56'
:title: 重複する要素を取り除く
:comments:
- :id: '3412'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3412
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/02 20:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  与えられたリストxsの中から、\r\n2回以上出現するものを全部取り除いてください。\r\n<p>\r\n</p>\n<pre>\r\nサンプル入力\r\n[3,
    1, 4, 1, 5, 9, 2, 6, 5]\r\nサンプル出力\r\n[3, 4, 9, 2, 6]\r\n</pre>\r\n<p>\r\nこれは<a
    href=\"/web/20100606040154/http://ja.doukaku.org/16/\">アレイのuniq</a>の派生問題です。\r\nリストとかアレイという言葉は言語によってまちまちの意味で使われているので、\r\n「配列のようなもの」という漠然とした意味にとって構いません。\r\n\t</p>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2801'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2801
  :user_name: rubikitch
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/105/
  :language: Ruby
  :time: 2007/09/02 20:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    def only_unique(ary)
      freq = ary.inject(Hash.new(0)){|h,x| h[x]+=1; h }
      ary.select{|x| freq[x]==1 }
    end
    only_unique([3, 1, 4, 1, 5, 9, 2, 6, 5]) # =&gt; [3, 4, 9, 2, 6]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2802'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2802
  :user_name: rubikitch
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/09/02 20:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    (defun only-unique (list)
      (remove-if (lambda (x) (&gt;= (count x list) 2)) list))
    (only-unique '(3 1 4 1 5 9 2 6 5))      ; =&gt; (3 4 9 2 6)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2803'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2803
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/02 22:39 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">要素がEqクラスのインスタンスなら</pre>\n\t"
  :code: |
    uniqOnly :: Eq a =&gt; [a] -&gt; [a]
    uniqOnly = uniq []
      where uniq xs [] = reverse xs
            uniq xs (y:ys) = case break (y ==) xs of
              (_,[])    -&gt; uniq (y:xs) ys
              (ps,_:qs) -&gt; uniq (ps++qs) ys

    {-
    uniqOnly [3,1,4,1,5,9,2,6,5]
    [3,4,9,2,6]
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2804'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2804
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/02 22:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ああやっちゃった。お題を全然満たしてない！</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2805'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2805
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/02 23:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">こっちが正解のはず</pre>\n\t"
  :code: |
    uniqOnly :: Eq a =&gt; [a] -&gt; [a]
    uniqOnly = uniq [] []
      where uniq xs ys [] = reverse xs
            uniq xs ys (z:zs) = case break (z==) xs of
              (_,[]) | z `notElem` ys -&gt; uniq (z:xs) ys zs
                     | otherwise      -&gt; uniq xs ys zs
              (ps,_:qs)               -&gt; uniq (ps++qs) (z:ys) zs

    {-
    *Main&gt; uniqOnly [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]
    [4,2,6,8,7]
    -}
  :tags:
  - bugfix版
  :references:
    :url: 
    :title: 
- :id: '2806'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2806
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/02 23:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">要素がOrdクラスのインスタンスなら、こちらの方が効率がいいはず</pre>\n\t"
  :code: "import Data.List\n\nbinapp :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt;
    (a -&gt; a -&gt; c)\nbinapp o f x y = f x `o` f y\neqapp :: Eq b =&gt; (a -&gt;
    b) -&gt; (a -&gt; a -&gt; Bool)\neqapp = binapp (==) \ncmpapp :: Ord b =&gt; (a
    -&gt; b) -&gt; (a -&gt; a -&gt; Ordering)\ncmpapp = binapp compare\n\nmapFilter
    f p xs = [ f x | x &lt;- xs, p x ]\n\nlenOne [x] = True\nlenOne _   = False\n\nuniqOnly
    :: Ord a =&gt; [a] -&gt; [a]\nuniqOnly = map snd\n         . sortBy (cmpapp fst)
    \n         . mapFilter head lenOne \n         . groupBy (eqapp snd) \n         .
    sortBy (cmpapp snd) \n         . zip [0..]\n"
  :tags:
  - Ordクラス
  :references:
    :url: 
    :title: 
- :id: '2807'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2807
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/02 23:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">foldl を使う版</pre>\n\t"
  :code: "uniqOnly :: Eq a =&gt; [a] -&gt; [a]\nuniqOnly = reverse . fst . foldl uniq
    ([],[])\n  where uniq (xs,ys) z = case break (z==) xs of\n           (_,[]) |
    z `notElem` ys -&gt; (z:xs,ys)\n                  | otherwise      -&gt; (xs,ys)\n
    \          (ps,_:qs)               -&gt; (ps++qs,z:ys) \n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2808'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2808
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/02 23:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ああっ。寝惚けてる mapAccumL じゃなくて foldlだ！\r\n御免なさい。タグまでうっちゃった。\r\nimport
    Data.List は不要です。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2809'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2809
  :user_name: jz5
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/09/02 23:55 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    Dim uniq = From x In xs Group By x Into Count() Where Count = 1 Select x
  :tags:
  - VB9.0
  :references:
    :url: 
    :title: 
- :id: '2810'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2810
  :user_name: ocean
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/09/03 00:25 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  速度的には、defaultdict より\r<br>h[i] = h.get(i, 0) + 1\r<br>のようなものを使ったほうが速いんでしょうけど・・・\r<br>可読性重視で。\n\t"
  :code: |
    import collections

    def only_unique(a):
        h = collections.defaultdict(int)
        for i in a:
            h[i] += 1
        return [i for i in a if h[i] == 1]

    def main():
        print only_unique([3, 1, 4, 1, 5, 9, 2, 6, 5])

    if __name__ == '__main__':
        main()
  :tags:
  - Python2.5
  :references:
    :url: 
    :title: 
- :id: '2811'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2811
  :user_name: matyr
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/09/03 00:26 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t   uneval の無い環境とプロパティの順番が保証されない可能性に配慮したら，えらく冗長になってしまった。\n\t"
  :code: |
    function doukaku56(a){
      if(typeof uneval != 'function') var uneval = function(o){
        if(o === undefined) return 'undefined';
        if(o === null)      return 'null';
        var s = o.toString();
        switch(o.constructor){
         case Object:
          if(s.indexOf('[object Object')) return s;
          var m = []; for(var p in o) m[m.length] = p +':'+ arguments.callee(o[p]);
          return '({'+ m.join(', ') +'})';
         case Array:
          var a = []; for(var i = o.length; i--;) a[i] = arguments.callee(o[i]);
          return '['+ a.join(', ') +']';
         case String:
          return '"'+ s.replace(/[\"\\]/g,'\\$&amp;').replace(/\r/g,'\\r').replace(/\n/g,'\\n') +'"';
         case Date: return '(new Date('+ +o +'))';
         default:   return s;
        }
      };
      var r = [], h = {}, k, i, l;
      for(i = 0, l = a.length; i &lt; l; i++) h[k = uneval(a[i])] = k in h ? -1 : i;
      for(k in h) if(h[k] &gt;= 0) r[r.length] = h[k];
      for(i = r.sort(function(x, y){ return x - y }).length; i--;) r[i] = a[r[i]];
      return r;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2812'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2812
  :user_name: yuin
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/09/03 01:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>ふつうに。\n</p>\n\n\n\n\t"
  :code: |
    import scala.collection.mutable.HashMap

    def uniqOnly[A](a:Seq[A]) = {
      val map = a.foldLeft(new HashMap[A,int]){(r,v)=&gt;r(v)=r.getOrElse(v,0)+1;r}
      a.filter(map(_)==1)
    }

    println(uniqOnly(Array(3, 1, 4, 1, 5, 9, 2, 6, 5)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2814'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2814
  :user_name: nori
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/59/
  :language: Python
  :time: 2007/09/03 01:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">再帰再帰・・・。\r\n\r\npythonで再帰にこだわるのは間違っている気がするが。</pre>\n\t"
  :code: |
    def oneces(xs, duplicated=None):
      if duplicated is None:
        duplicated = []
      if len(xs) &lt; 2:
        return xs
      o = oneces(xs[:-1], duplicated)
      if xs[-1] in duplicated:
        return o
      if xs[-1] in o:
        o.remove(xs[-1])
        duplicated.append(xs[-1])
        return o
      return o+xs[-1:]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2815'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2815
  :user_name: Mistfeal
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/153/
  :language: PHP
  :time: 2007/09/03 01:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">PHPは配列操作得意ですね。</pre>\n\t"
  :code: "&lt;?php\nfunction only_unique($ary) {\n\tforeach ( $ary as $val ) {\n\t\tif
    ( count(array_keys($ary,$val)) == 1 ) {\n\t\t\t$rtn[] = $val;\n\t\t}\n\t}\n\treturn
    $rtn;\n}\n\nprint_r(only_unique(array(3, 1, 4, 1, 5, 9, 2, 6, 5)));\n?&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2816'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2816
  :user_name: sumim
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/09/03 01:33 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Squeak Smalltalk で。\r<br><br>#occurrencesOf: は配列（array）にも適用できますが非効率なので、bag を介在させています。bag は内部的に要素を要素種と数で管理するコレクションです。\n\t"
  :code: |
    | array bag |
    array := #(3 1 4 1 5 9 2 6 5).
    bag := array asBag.
    ^array reject: [:each | (bag occurrencesOf: each) &gt; 1]  "=&gt; #(3 4 9 2 6) "
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '2817'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2817
  :user_name: sawat
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/322/
  :language: Java
  :time: 2007/09/03 01:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "import java.util.*;\n\npublic class UniqOnly {\n\tpublic static void main(String[]
    args) {\n\t\tList&lt;Integer&gt; list = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6,
    5);\n\t\t\n\t\tSet&lt;Integer&gt; counter = new HashSet&lt;Integer&gt;();\n\t\tSet&lt;Integer&gt;
    dup = new HashSet&lt;Integer&gt;();\n\t\t\n\t\tfor (int i = 0, n = list.size();
    i &lt; n; i++) {\n\t\t\tif(!counter.add(list.get(i))) {\n\t\t\t\tdup.add(list.get(i));\n\t\t\t}\n\t\t}\n\t\tlist
    = new LinkedList&lt;Integer&gt;(list);\n\t\tlist.removeAll(dup);\n\t\tSystem.out.println(list);\n\t}\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2818'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2818
  :user_name: tea
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/402/
  :language: Python
  :time: 2007/09/03 01:51 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">[x for x in xs if xs.count(x) == 1] から、\r\n重複する値が多数あった場合を考えて、ループ回数を減らすために集合を利用。\r\n最後は、
    sorted(..., key=xs.index) で元の順番に並べ替え。</pre>\n\t"
  :code: |
    def only_uniq(xs):
        return sorted((x for x in set(xs) if xs.count(x) == 1), key=xs.index)
  :tags:
  - Python2.5
  :references:
    :url: 
    :title: 
- :id: '2819'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2819
  :user_name: 匿名
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/09/03 02:15 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">なら、もしかしてこれでいける？\r\n</pre>\n\t"
  :code: |
    def only_uniq(xs):
        return sorted(set(xs), key=xs.index)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2820'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2820
  :user_name: naoya_t
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/09/03 02:28 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ナイーブな実装。\r\n% awk -f remove_multiples_1.awk\r\n3
    14 15 92 65 35 89 79 32 38 46 26 43 38 32 79\r\n3 14 15 92 65 35 89 46 26 43 \r\ncat
    lion tiger lion\r\ncat tiger \r\n1  2  1  0\r\n2 0 </pre>\n\t"
  :code: "{\n\txs_size = split($0,xs)\n\tremove_multiples(xs,xs_size)\n\tfor (i=1;i&lt;=result_size;i++)
    printf result[i] \" \" ; printf \"\\n\"\n}\n\nfunction remove_multiples(xs,xs_size,
    i) # 結果は result[], result_size へ\n{\n\tdelete occurrence\n\tfor (i=1;i&lt;=xs_size;i++)
    occurrence[xs[i]]++\n\n\tdelete result\n\tresult_size = 0\n\tfor (i=1;i&lt;=xs_size;i++)\n\t\tif
    (occurrence[xs[i]] == 1) result[++result_size] = xs[i]\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2821'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2821
  :user_name: naoya_t
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/09/03 02:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">配列を使わずにremove_multiples_1.awkと（ほぼ）同じ動作をする版。\r\n%
    awk -f remove_multiples_2.awk\r\n3 14 15 92 65 35 89 79 32 38 46 26 43 38 32 79\r\n3
    14 15 92 65 35 89 46 26 43 \r\ncat lion tiger lion\r\ncat tiger \r\n1  2  1  0\r\n2
    \ 0\r\n</pre>\n\t"
  :code: "{\n\torig = $0\n\twhile (match(orig,/[^ ]+/)) {\n\t\titem = substr(orig,RSTART,RLENGTH)\n\t\tif
    (occurence[item]++ &gt; 0) gsub(item \" *\",\"\")\n\t\torig = substr(orig,RSTART+RLENGTH)\n\t}\n\tprint\n\tdelete
    occurence\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2822'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2822
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 02:32 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>それは2回以上出現する要素を取り除いていないですね。<a href=\"/web/20100606040154/http://ja.doukaku.org/16/\">前の問題</a>の解答としてならアリですね。\n</p>\n\n\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2823'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2823
  :user_name: 匿名
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/09/03 02:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あ、お題を誤読してました。順序を保存したuniqではなく\r\n要素がひとつだけのものを残すんですね。\r\n上のコードにマイナス付けておいてください。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2826'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2826
  :user_name: g000001
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/405/
  :language: Common
  :time: 2007/09/03 02:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">member二回で濾過してみました。</pre>\n\t"
  :code: "(defun uniq-only (lst)\n  (remove-if (lambda (item)\n\t       (member item
    (cdr (member item lst))))\n\t     lst))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2827'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2827
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 03:12 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">効率について曖昧に書いてしまったので補足です．\r\n\r\n#2806のuniqOnlyでは最悪のケースでの計算オーダーではＯ(n
    log n)です．\r\n#2805や#2807のuniqOnlyでは最悪のケースでの計算オーダーはＯ(n^2)です．\r\n\r\n入力リストとして[1..10^4]周辺の値を与えて計算時間を比較するとわかります．\r\n\r\n他の言語でも，集合やバッグを使う場合，入力リストの要素が順序決定できる\r\n値でないと最悪の場合
    O(n^2) の計算になるとだろうと想像しています．\r\n</pre>\n\t"
  :code: ''
  :tags:
  - 効率
  :references:
    :url: 
    :title: 
- :id: '2828'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2828
  :user_name: ocean
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/177/
  :language: 
  :time: 2007/09/03 03:14 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">ちゃんと計測してみたら、要素が多いときは\r\ncollections.defaultdict
    の方が速かったです。\r\n# 一概にどちらが遅いとはいえない</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2829'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2829
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 03:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">&gt;&gt;&gt; import collections\r\n&gt;&gt;&gt;
    collections\r\n&lt;module 'collections' (built-in)&gt;\r\n\r\nなるほど、collectionsはネイティブで書かれてますね。\r\n「初期化のコストが少し高いけども、\r\n多くのデータを扱うならcollectionsの方がよい」\r\nということかもしれませんね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2831'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2831
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 03:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">修正しておきました。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2832'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2832
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 03:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">pythonを知らないので想像ですが、\r\n#2827で言及したことと同じことがおこってるのでは？\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2833'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2833
  :user_name: sumim
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/09/03 03:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  念のため時間を計測して bag を介することの有無の影響をみてみました。非力なマシン（PowerPC 1GHz, OS X）なので、1e3  で(^_^;)。\r<br><br>結果の単位はミリ秒で、順に「bag  使用時（bag への変換時間も込み）」「bag 使用時（同、含まず）」「bag 不使用時」です。\n\t"
  :code: "| array bag millisecondsWithBag millisecondsWithBag2 millisecondsWioutBag
    |\narray := (1 to: 1e3) asArray.\n\nmillisecondsWithBag := [\n\tbag := array asBag.\n\tarray
    reject: [:each | (bag occurrencesOf: each) &gt; 1]] timeToRun.\n\nmillisecondsWithBag2
    := [\n\tarray reject: [:each | (bag occurrencesOf: each) &gt; 1]] timeToRun.\n\nmillisecondsWioutBag
    := [\n\tarray reject: [:each | (array occurrencesOf: each) &gt; 1]] timeToRun.\n\n^{millisecondsWithBag.
    millisecondsWithBag2. millisecondsWioutBag}   \"=&gt; #(19 8 526) \"\n"
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '2834'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2834
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 04:03 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">1e3だけでなく2e3と4e3などの複数のプロファイルデータをとると、\r\n計算量の増加の程度がそれぞれの場合で想像できるのではないでしょうか。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2838'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2838
  :user_name: 130R
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/409/
  :language: PowerShell
  :time: 2007/09/03 04:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">PS C:\\&gt; $list = (3, 1, 4, 1, 5, 9, 2, 6,
    5)\r\nPS C:\\&gt; $list | %{$h=@{}} {$h[$_] += 1}\r\nPS C:\\&gt; $list | %{if($h[$_]
    -eq 1) {$_}}\r\n3\r\n4\r\n9\r\n2\r\n6</pre>\n\t"
  :code: |
    $list = (3, 1, 4, 1, 5, 9, 2, 6, 5)
    $list | %{$h=@{}} {$h[$_] += 1}
    $list | %{if($h[$_] -eq 1) {$_}}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2839'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2839
  :user_name: tea
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/402/
  :language: Other
  :time: 2007/09/03 05:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    集合+ソートを用いたものでは、Pythonでの僕の投稿 #2818 も、
    最悪のケースでの計算量は指数オーダーでした。

    ユニークな要素の数が多すぎると sortとcountで効率が落ちる。
    効率考えたつもりが返って悪化した悪い例になってしまった（恥
  :tags:
  - 効率
  :references:
    :url: 
    :title: 
- :id: '2840'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2840
  :user_name: ocean
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/177/
  :language: C
  :time: 2007/09/03 05:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">STLを使用。</pre>\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;algorithm&gt;

    template &lt;typename ForwardIterator&gt;
    ForwardIterator only_unique(ForwardIterator beg, ForwardIterator end)
    {
        while (beg != end)
        {
            ForwardIterator new_beg = beg; ++new_beg;

            ForwardIterator new_end = std::remove(new_beg, end, *beg);

            if (new_end != end) // removed some elements
            {
                end = std::copy(new_beg, new_end, beg); // remove *beg
            }
            else
            {
                beg = new_beg;
            }
        }

        return end;
    }

    int main()
    {
        int a[] = {3, 1, 4, 1, 5, 9, 2, 6, 5};

        int* p = only_unique(a, a + sizeof(a) / sizeof(*a));

        std::copy(a, p, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2841'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2841
  :user_name: drop
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/388/
  :language: Haskell
  :time: 2007/09/03 05:52 GMT
  :vote_count: '7'
  :vote_score: '7'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    uniqOnly xs = [x | [x]&lt;-[[z | z&lt;-xs, z==y] | y&lt;-xs]]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2842'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2842
  :user_name: yohei
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/415/
  :language: C
  :time: 2007/09/03 06:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">引数の配列を書き換えて。</pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n\nint only_uniq(int *a, int len) {\n\tint i, j,
    dup = -1;\n\tint n, skip;\n\t\n\tfor (i = 0; i &lt; len; i++) {\n\t\tfor (j =
    i + 1; j &lt; len; j++) {\n\t\t\tif (a[i] == a[j]) {\t\n\t\t\t\tdup = i;\n\t\t\t\ti
    = len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (dup == -1) return len;\n\tskip
    = a[dup];\n\t\n\tfor (i = dup + 1; i &lt; len; i++) {\n\t\tif ((n = a[i]) == skip)
    continue;\n\t\tfor (j = i + 1; j &lt; len; j++) {\n\t\t\tif (a[j] == n) {\n\t\t\t\ta[i]
    = skip;\n\t\t\t\ta[j] = skip;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tj = 0;\n\tfor (i = 0;
    i &lt; len; i++) {\n\t\tif (a[i] != skip) a[j++] = a[i];\n\t}\n\n\treturn j;\n}\n\nint
    main() {\n\tint a[] = { 3, 1, 4, 1, 5, 9, 2, 6, 5 };\n\tint i, len;\n\t\n\tlen
    = only_uniq(a, sizeof(a) / sizeof(a[0]));\n\t\n\tfor (i = 0; i &lt; len - 1; i++)
    {\n\t\tprintf(\"%d, \", a[i]);\n\t}\n\tif (len &gt; 0) printf(\"%d\\n\", a[i]);\n\t\n\treturn
    0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2843'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2843
  :user_name: tea
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/402/
  :language: 
  :time: 2007/09/03 06:13 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">効率の話題に付いて、\r\nPythonのCookbookのForumでも同じような話題があったので、こっちに返信付けます。\r\n\r\nリンク先の内容は、Pythonでのunique関数のレシピで、\r\n今回のお題では、リスト内の要素の型について特に指定はありませんでしたが、\r\nハッシュや集合を用いる場合に、リストの要素がunhashableの場合等にも言及があります。\r\n#
    あと、リスト内包内の隠し変数を使うとか裏技っぽいことが・・・\r\n</pre>\n\t"
  :code: ''
  :tags:
  - 効率
  :references:
    :url: /web/20100606040154/http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560
    :title: Remove duplicates from a sequence
- :id: '2844'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2844
  :user_name: sumim
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/09/03 06:16 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  了解です。では、あらためて。\n\t"
  :code: "| array bag millisecondsWithBag millisecondsWithBag2 millisecondsWioutBag
    |\n#(1e3 2e3 4e3) collect: [:size |\n\n\tarray := (1 to: size) asArray.\n\n\tmillisecondsWithBag
    := [\n\t\tbag := array asBag.\n\t\tarray reject: [:each | (bag occurrencesOf:
    each) &gt; 1]] timeToRun.\n\n\tmillisecondsWithBag2 := [\n\t\tarray reject: [:each
    | (bag occurrencesOf: each) &gt; 1]] timeToRun.\n\n\tmillisecondsWioutBag := [\n\t\tarray
    reject: [:each | (array occurrencesOf: each) &gt; 1]] timeToRun.\n\n\tsize -&gt;
    {millisecondsWithBag. millisecondsWithBag2. millisecondsWioutBag}]\n\n\"=&gt;
    {1000-&gt;#(19 8 548) . 2000-&gt;#(43 19 2169) . 4000-&gt;#(82 38 8725)} \"\n"
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '2846'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2846
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 06:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">むむ、一瞬何が起きているのかと思いました。\r\nxs内の各要素yについて、「xsから値がyであるものだけを取り出したリスト」を作って\r\n([3,
    1, 4, 1 5]だったら[[3], [1, 1], [4], [1, 1], [5]])\r\nその中から[x]の形のものだけを取り出している？？\r\nHaskellのリスト内包ってパターンマッチもやって、\r\nマッチしない場合は捨ててくれるのかな？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2848'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2848
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 07:02 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">&gt; Haskellのリスト内包ってパターンマッチもやって、\r\n&gt; マッチしない場合は捨ててくれるのかな？\r\n\r\nyes\r\n\r\n効率はO(n^2)ですが、niceなコードですね。</pre>\n\t"
  :code: ''
  :tags:
  - リスト内包表記
  :references:
    :url: 
    :title: 
- :id: '2850'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2850
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 07:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">パターンマッチがうらやましい…</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2851'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2851
  :user_name: rucker
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/130/
  :language: PHP
  :time: 2007/09/03 07:31 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">array_count_valuesを使って。\r\nやってみたところ配列の順序は保存される様ですが、\r\n関数の仕様として保証されているものではなさそうなので\r\n順序(というかキー)を保存するバージョンもセットで投稿します。\r\n(…お題の要件として順序の保存は必要なかったのかな?)\r\n配列の値で何度も検索するような場合は(状況が許せば)array_flipで\r\nキーと値を入れ換えちゃうと速い(気がする)。</pre>\n\t"
  :code: "&lt;?php\nfunction oneces($a) {\n\t$cs=array_count_values($a);\n\t$r=array();\n\twhile(list($v,$c)=each($cs))\n\t{\tif($c==1)\n\t\t\t$r[]=$v;\n\t}\n\treturn
    $r;\n}\n\n//キーを保存するバージョン\nfunction oneces2($a) {\n\t$cs=array_count_values($a);\n\t$a=array_flip($a);\n\twhile(list($v,$c)=each($cs))\n\t{\tif($c&gt;1)\n\t\t\tunset($a[$v]);\n\t}\n\treturn
    array_flip($a);\n}\n\nprint_r(oneces(array(3, 1, 4, 1, 5, 9, 2, 6, 5)));\nprint_r(oneces2(array(3,
    1, 4, 1, 5, 9, 2, 6, 5)));\n?&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2852'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2852
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 07:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Pythonの辞書(連想配列)は存在しないキーを読み出そうとすると例外を投げるのですが、\r\ndefaultdictはキーが存在しない場合にデフォルトの値を返す辞書なんです。\r\nなのでアルゴリズム上はどっちを使ってもオーダーは同じはずです。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2853'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2853
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 07:49 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">h[i] = h.get(i, 0) + 1の場合：\r\n\r\n  0 LOAD_GLOBAL
    \             0 (h)\r\n  3 LOAD_ATTR                1 (get)\r\n  6 LOAD_GLOBAL
    \             2 (i)\r\n  9 LOAD_CONST               1 (0)\r\n 12 CALL_FUNCTION
    \           2\r\n 15 LOAD_CONST               2 (1)\r\n 18 BINARY_ADD          \r\n
    19 LOAD_GLOBAL              0 (h)\r\n 22 LOAD_GLOBAL              2 (i)\r\n 25
    STORE_SUBSCR        \r\n\r\nh[i] += 1の場合：\r\n\r\n  0 LOAD_GLOBAL              0
    (h)\r\n  3 LOAD_GLOBAL              1 (i)\r\n  6 DUP_TOPX                 2\r\n
    \ 9 BINARY_SUBSCR       \r\n 10 LOAD_CONST               1 (1)\r\n 13 INPLACE_ADD
    \        \r\n 14 ROT_THREE           \r\n 15 STORE_SUBSCR        \r\n\r\nLOAD命令の数がかなり違うので、そこが性能の差につながっているのかな、と思います。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2856'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2856
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 08:13 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">後学のために教えてくださいまし．\r\nPythonの連想配列と辞書とでキーになれる値の制限は特にないのでしょうか？\r\nそれぞれのコレクションのエントリーを追加あるいは更新のときの手間はO(log
    n)?それともO(n)?\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2858'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2858
  :user_name: yuin
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/09/03 08:37 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n<p>そこでScalaですよ。\n</p>\n<p>同じやり方で書いてみました。\n</p>\n\n\n\n\t"
  :code: "def uniqOnly[A](xs:List[A]) =  \n  for(x::Nil &lt;- (for(y&lt;-xs) yield
    (for(z&lt;-xs if z==y) yield z))) yield x\n\nprintln(uniqOnly(List(3, 1, 4, 1,
    5, 9, 2, 6, 5)))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2859'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2859
  :user_name: eban
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/97/
  :language: Ruby
  :time: 2007/09/03 08:41 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">無難に</pre>\n\t"
  :code: |
    def remove_dups(a)
      a.select{|x|a.grep(x).size == 1}
    end

    p remove_dups([3, 1, 4, 1, 5, 9, 2, 6, 5]) #=&gt; [3, 4, 9, 2, 6]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2861'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2861
  :user_name: shiro
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/41/
  :language: C
  :time: 2007/09/03 08:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Cで。ちょっとひねくれてみました。\r<br><br>入力は非負整数限定で、取り得る最大の要素がわかっているとします(コード中ではMAXVAL)。\r<br>わからなければ一回スキャンして最大値を探せば良いだけですが。\r<br><br>配列linkは入力値が取り得る各要素に対応し、「要素が出現する順番に並べた時に、次に出現する要素」が格納されます。ポインタを使わない一種のリンクトリストです。表示部ではそのリンクをたどりながら、重複が無かった要素を出力します。\r<br>"
  :code: |
    #include &lt;stdio.h&gt;
    #define MAXVAL 10

    static int input[] = { 3, 1, 4, 1, 5, 9, 2, 6, 5 };

    int main(void)
    {
        int dup[MAXVAL+1], link[MAXVAL+1], i, j;
        int len = sizeof(input)/sizeof(int);
        for (j=0; j&lt;MAXVAL+1; j++) dup[j] = link[j] = -1;
        for (i=0,j=MAXVAL; i&lt;len; i++) if (!++dup[input[i]]) j = link[j] = input[i];

        for (j=link[MAXVAL]; j&gt;=0; j=link[j]) if (!dup[j]) printf("%d ", j);
        printf("\n");
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2862'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2862
  :user_name: yohei
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/415/
  :language: C
  :time: 2007/09/03 09:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "using System;\nusing System.Collections.Generic;\nclass Program {\n    static
    T[] OnlyUnique&lt;T&gt;(T[] list) {\n        List&lt;T&gt; uniq = new List&lt;T&gt;();\n
    \       List&lt;T&gt; dup = new List&lt;T&gt;();\n        foreach (T o in list)
    {\n            if (uniq.Contains(o)) { uniq.Remove(o); dup.Add(o); }\n            else
    if (!dup.Contains(o)) uniq.Add(o);\n\t    }\n        return uniq.ToArray();\n
    \   }\n    static void Main(string[] args) {\n        int[] a = { 3, 1, 4, 1,
    5, 9, 2, 6, 5 };\n        foreach (int n in OnlyUnique(a)) Console.WriteLine(n);\n
    \   }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2865'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2865
  :user_name: hirataka
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/233/
  :language: PHP
  :time: 2007/09/03 10:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">シンプルに</pre>\n\t"
  :code: "&lt;?php\nfunction only_unique($a){\n\treturn array_keys(array_count_values($a),
    1);\n}\n\nprint_r(only_unique(array(3, 1, 4, 1, 5, 9, 2, 6, 5)));\n?&gt;\n"
  :tags:
  - PHP4
  - PHP5
  :references:
    :url: 
    :title: 
- :id: '2869'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2869
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/09/03 11:32 GMT
  :vote_count: '6'
  :vote_score: '6'
  :body: "\n\t  \n<p>連想配列と辞書の違いはありません、というより「Pythonの『辞書』はPerlの『連想配列』やJavaのHashtableのようなもの」ということです。\n
    \  実装はハッシュテーブルなのでO(1)のはず。ハッシュ値の計算方法さえ定義してやればどんなオブジェクトでも入ります。組み込み型のリストと辞書は故意にハッシュ値の計算方法が未定義にされているのでそのままでは入りませんが、__hash__メソッドを定義してやれば入るようになります。\n</p>\n<pre><code>{[]:
    1} # TypeError: list objects are unhashable\n\nclass MyList(list):\n    def __hash__(self):\n
    \       return id(self)\n\n\n{MyList(): 1} # {[]: 1}\n</code></pre>\n\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2872'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2872
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/03 12:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ありがとうございます。勉強になります。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2873'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2873
  :user_name: raynstard
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/127/
  :language: Perl
  :time: 2007/09/03 13:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">そうか！お題には「 重複する要素を取り除く」としか書いてない(笑\r\nということで順序は壊れるし効率もわるいけど。。。\r\nこんなのもあり？</pre>\n\t"
  :code: "sub eraseDuplicate(@)\n{\n\t$_ = join(' ', sort(@_));\n\ts/([^ ]+ )\\1+//g;\n\treturn
    split(' ');\n}\n\nmy @sample = (3, 1, 4, 1, 5, 9, 2, 6, 5);\n\nprint '入力：[' .
    join(', ', @sample) . \"]\\n\";\n@sample = &amp;eraseDuplicate( @sample );\nprint
    '出力：[' . join(', ', @sample) . \"]\\n\";\n\nexit 0;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2875'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2875
  :user_name: talo
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/237/
  :language: Python
  :time: 2007/09/03 14:16 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    def uniq2(target):
        counter = target.count
        return [v for v in target if counter(v) &lt; 2]
  :tags: []
  :references:
    :url: /web/20100606040154/http://newworld.ddo.jp/doc/PerformanceTips/#id6
    :title: 'Python Performance Tips: ドットを避ける'
- :id: '2876'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2876
  :user_name: miyamuko
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/382/
  :language: xtal
  :time: 2007/09/03 15:19 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">配列の要素を [その要素、*残りの要素] に map して\r\n「残りの要素」に「その要素」が含まれていなければ
    yield します。\r\n</pre>\n\t"
  :code: |
    Iterator::skip: method(n) {
        n.times { this { break; } }
    }
    Iterator::window: method(start, length) {
        this.skip(start);
        return this.take(length);
    }

    only_uniq: fun(arr) fiber {
        len: arr.length;
        iters: range(0, len).map(|i| arr.cycle.window(i, len).to_a);
        iters {|it,rest|
            if (rest.select(|e| e == it).to_a.empty) {
                yield it;
            }
        }
    }

    only_uniq([3, 1, 4, 1, 5, 9, 2, 6, 5]).to_a.p;
  :tags:
  - xtal0.9.7
  :references:
    :url: 
    :title: 
- :id: '2877'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2877
  :user_name: kkobayashi
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/09/03 16:05 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <pre class=\"compact\">Rらしく集合演算。\r\n\r\n&gt; unique.only(c(3, 1, 4,
    1, 5, 9, 2, 6, 5))\r\n[1] 3 4 9 2 6\r\n</pre>\n\t"
  :code: |
    unique.only &lt;- function(l){
       setdiff(l, l[duplicated(l)])
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2879'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2879
  :user_name: matyr
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/09/03 21:18 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t   uneval なんか使わずとも === で比較して除けばいいことに気付く。↑ の20倍以上速い…。(－－；)\r<br><br> doukaku56( [ 1, \"1\", [1], new Number(1), { valueOf: function(){ return 1 } } ] )\r<br>  =&gt; 1,1,1,1,[object Object]\n\t"
  :code: |
    function doukaku56(a){
      for(var r = [], d = {}, i = 0, j, l = a.length; i &lt; l; i++) if(!d[i]){
        for(j = l; --j &gt; i;) if(a[i] === a[j]) d[i] = d[j] = true;
        if(!d[i]) r[r.length] = a[i];
      }
      return r;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2880'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2880
  :user_name: raynstard
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/127/
  :language: Perl
  :time: 2007/09/03 23:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">一手間かけて順序保持するように修正～\r\nだけど、文字列(単語)の重複含めて排除するでもない限りは\r\n使い物にならないかなと(笑</pre>\n\t"
  :code: |
    sub eraseDuplicate(@)
    {
        my @out;
        my $a = ' ' . join(' ', sort(@_)) . ' ';
        $a =~ s/([^ ]+ )\1+//g;
        foreach my $b ( @_ )
        {
            push(@out, $1) if( $a =~ m/ ($b) / );
        }
        return @out;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2881'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2881
  :user_name: raynstard
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/127/
  :language: 
  :time: 2007/09/03 23:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">この投稿に気がつかず上で悪ふざけしてしまいましたが、\r\n「派生」というあたり前回問題の要件を満たした上で、\r\n今回は重複した本人も削除すると\r\n解釈した方が素直なように思います。\r\n#
    「類似」とかなら気にしなかったかもしれませんけどね(笑</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2882'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2882
  :user_name: morchin
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/09/04 00:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#2818の3.0a1版。3.0a1リリース記念。</pre>\n\t"
  :code: |
    &gt;&gt;&gt; L = [3, 1, 4, 1, 5, 9, 2, 6, 5]
    &gt;&gt;&gt; sorted({v for v in L if L.count(v) == 1}, key=L.index)
    [3, 4, 9, 2, 6]
  :tags:
  - Python3.0a1
  :references:
    :url: 
    :title: 
- :id: '2883'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2883
  :user_name: morchin
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/78/
  :language: 
  :time: 2007/09/04 00:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">{v for v in L}でLの要素の個数分評価しているみたいで、セット内包表記使う意味が全くなかったorz</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2896'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2896
  :user_name: 匿名
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/4/
  :language: OCaml
  :time: 2007/09/04 09:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">コスト高そうですが。。</pre>\n\t"
  :code: |
    open List;;

    let only_unique l = [for x in l when find_all ((=) x) l |&gt; length = 1 -&gt; x];;
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '2923'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2923
  :user_name: fbis
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/89/
  :language: Perl
  :time: 2007/09/06 07:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">無理やりワンライナーでやってみた\r\n指定はなかったが一応配列の順番も保障。</pre>\n\t"
  :code: |
    my @array = (3, 1, 4, 1, 5, 9, 2, 6, 5);

    my @array2 = do { my %hash; grep { $hash{$_} == 1 } map { $hash{$_}++; $_; } @array };

    print join ', ', @array2;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2926'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2926
  :user_name: ？せんたくいた
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/241/
  :language: Bash
  :time: 2007/09/06 10:50 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">bashでの常套句、sortしてuniqして。そんなワンライナー。\r\nカンマ区切りを想定しています。\r\n\r\n$
    ./only_uniq.sh \"3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,\"\r\n4,2,6,8,7,\r\n</pre>\n\t"
  :code: |
    #!/bin/bash
    n="$1"
    separator=','

    echo "$n" |tr $separator '\n' |nl |sort -k2 |uniq -f1 -u  |sort -k1 |cut -f2 | tr '\n' $separator &amp;&amp; echo
  :tags:
  - cut
  - nl
  - sort
  - tr
  - uniq
  :references:
    :url: 
    :title: 
- :id: '2932'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2932
  :user_name: カノエ
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/376/
  :language: SQL
  :time: 2007/09/06 15:52 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">SQLで「配列のようなもの」をどう考えるかで悩んだ時間の方が長かったです。\r\nテーブルを使うのは都合良すぎで、お題から外れるような気がするのですが。</pre>\n\t"
  :code: |
    drop table if exists xs;
    create table xs(id int not null auto_increment primary key, x int not null);
    insert into xs(x) values (3), (1), (4), (1), (5), (9), (2), (6), (5);

    select
      x
    from xs
    group by x having count(x) &lt; 2
    order by min(id);
  :tags:
  - MySQL
  :references:
    :url: 
    :title: 
- :id: '2933'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2933
  :user_name: カノエ
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/376/
  :language: SQL
  :time: 2007/09/06 16:10 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  '3, 1, 4, 1, 5, 9, 2, 6, 5'という「配列のような文字列」をカンマで区切って重複を調べます。\n\t"
  :code: |
    set @xs = '3, 1, 4, 1, 5, 9, 2, 6, 5';

    drop table if exists num_chars;
    create table num_chars(id int not null);
    insert into num_chars values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9);

    drop table if exists nums;
    create table nums as (
      select n1.id + (n2.id * 10) + (n3.id * 100) as id
      from num_chars n1, num_chars n2, num_chars n3);

    select
      x
    from (
      select
        num
      , trim(substring_index(substring_index(@xs, ',', num), ',', -1)) as x
      from (
        select id as num from nums
        where id &gt;= 1
          and id &lt;= (length(@xs) - length(replace(@xs, ',', '')) + 1)
        ) as nums
      ) as xs
    group by x having count(x) &lt; 2
    order by min(num);
  :tags:
  - MySQL
  :references:
    :url: 
    :title: 
- :id: '2971'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2971
  :user_name: 匿名
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/4/
  :language: JavaFxScript
  :time: 2007/09/10 21:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">コピー作ってるあたりがダメな感じかも。。。</pre>\n\t"
  :code: |
    var input: int = [3, 1, 4, 5, 1, 0, 5, 9, 7];
    var fuga: int = only(input);

    println(fuga);

    operation only(input: int){
        var hoge = input.hashCode();
        for(i in input){
            if(sizeof(select j from j in hoge where j == i) &gt; 1){
                delete hoge[. == i];
            }
        }
        return hoge;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2999'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/2999
  :user_name: mamamoto
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/437/
  :language: Ruby
  :time: 2007/09/13 07:58 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">正規表現で。\r\n一桁専用+数字専用+ruby1.9じゃ動かないですが。</pre>\n\t"
  :code: |
    def string_only_unique(s)
      s.gsub(/(\d)(\d*)\1/){|s|
        string_only_unique($2)
      }
    end

    def only_unique(ary)
      string_only_unique(ary.to_s).split(//).map{|n| n.to_i}
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3015'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3015
  :user_name: koguro
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/438/
  :language: Scheme
  :time: 2007/09/14 13:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Schemeの解がでていなかったので投稿(Gaucheに特化していますが)。\r\nあと長いリストだとapplyでエラーになることがあります。</pre>\n\t"
  :code: |
    (use gauche.collection)

    (define (only-unique lst)
      (apply append (filter (compose (cut = 1 &lt;&gt;) length) (group-collection lst))))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3035'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3035
  :user_name: shiro
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/41/
  :language: 
  :time: 2007/09/16 04:04 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  非常に多くのリストをappendするときは(apply append ...)ではなくsrfi-1のconcatenateを使うと引数の数の制限を受けません。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3185'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3185
  :user_name: yohei
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/415/
  :language: Prolog
  :time: 2007/09/27 11:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    only_uniq([],[]).
    only_uniq([X|Xs], [X|Ys]) :- delete(Xs, X, Xs), !, only_uniq(Xs, Ys).
    only_uniq([X|Xs], Ys) :- delete(Xs, X, Zs), only_uniq(Zs, Ys).

    :- only_uniq([3, 1, 4, 1, 5, 9, 2, 6, 5], U), writeln(U).
  :tags:
  - SWI-Prolog
  :references:
    :url: 
    :title: 
- :id: '3243'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3243
  :user_name: cooldaemon
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/451/
  :language: Erlang
  :time: 2007/10/04 01:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">与えられた配列要素の順序を守ってます。</pre>\n\t"
  :code: "-module(doukaku56).\n-export([u2z/1, only_uniq/1, only_uniq/2]).\n  \nu2z(undefined)
    -&gt; 0;\nu2z(X) -&gt; X.\n\nonly_uniq(XS) -&gt;\n  spawn_link(?MODULE, only_uniq,
    [self(), XS]),\n  receive\n    List -&gt; List\n  end.\n\nonly_uniq(Pid, XS) -&gt;\n
    \ lists:foreach(fun (X) -&gt; put(X, u2z(get(X))+1) end, XS),\n  Pid ! [X || X
    &lt;- XS, get(X) =:= 1].\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3881'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3881
  :user_name: dankogai
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/26/
  :language: Perl
  :time: 2007/11/11 23:25 GMT
  :vote_count: '5'
  :vote_score: '-3'
  :body: "\n\t  \n<p>fbisさん惜しい！uniqは\n</p>\n<p><code>sub uniq{ my %u; grep {!$u{$_}++}
    @_}</code>\n</p>\n<p>というidiomがすでにあるのです。\n</p>\n<p>Dan the Perl Monger\n</p>\n\n\n\n\t"
  :code: |
    % perl -le 'print do{my %u; grep {\!$u{$_}++} @ARGV}' 1 2 1 2 3 1 2 3 4
    1234
  :tags: []
  :references:
    :url: /web/20100606040154/http://0xcc.net/blog/archives/000043.html
    :title: '配列操作の比較表: Ruby, Python, JavaScript, Perl, C++'
- :id: '3883'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3883
  :user_name: dankogai
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/26/
  :language: Ruby
  :time: 2007/11/11 23:29 GMT
  :vote_count: '5'
  :vote_score: '-5'
  :body: "\n\t  \n<p>rubyには<code>Array#uniq</code>があるというのになぜか使われていないので。\n</p>\n<p>Dan
    the Occasional Rubyist\n</p>\n\n\n\n\t"
  :code: |
    % ruby -e 'puts ARGV.uniq' 1 2 1 2 3 1 2 3 4
    1
    2
    3
    4
  :tags: []
  :references:
    :url: /web/20100606040154/http://0xcc.net/blog/archives/000043.html
    :title: '配列操作の比較表: Ruby, Python, JavaScript, Perl, C++'
- :id: '3888'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3888
  :user_name: にしお
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/11/12 02:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  問題文が少しわかりにくいですが、この場合出力は4だけになることが求められています。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3898'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3898
  :user_name: nantan
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/535/
  :language: Java
  :time: 2007/11/12 08:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">sawat氏のとほとんど同じですが一応投稿。\r\n（クラス名、変数名は参考にさせていただきました）</pre>\n\t"
  :code: |
    import java.util.*;
    public class UniqueOnly {
        public static void main(String[] args) {
            int[] xs = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9};
            List res = unique(xs);
            System.out.println(res);    // =&gt; [4, 2, 6, 8, 7]
        }
        public static List&lt;Integer&gt; unique(int[] xs) {
            LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;Integer&gt;();
            HashSet&lt;Integer&gt; dup = new HashSet&lt;Integer&gt;();
            for (int x : xs) {
                if (!set.add(x)) dup.add(x);
            }
            set.removeAll(dup);
            return new ArrayList&lt;Integer&gt;(set);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3920'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/3920
  :user_name: 匿名
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/12 18:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  適当ですが\n\t"
  :code: |
    listとは配列=「3,1,4,1,5,9,2,6,5」
    list=区切(list,",");aとは配列;nとは整数;sとは配列;s=list;配列数値ソート(s)
    表重複削除(list,0)で反復;n=配列検索(s,0,対象);もし(s[n]!=s[n+1])ならば;配列追加(a,対象)
    表示(配列結合(a,","))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4022'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/4022
  :user_name: Psychs
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/554/
  :language: Objective
  :time: 2007/11/14 13:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n\n@interface NSArray (UniqueElements)\n-
    (NSArray*)uniqueElements;\n@end\n\n@implementation NSArray (UniqueElements)\n\n-
    (NSArray*)uniqueElements\n{\n  NSMutableDictionary* dic = [NSMutableDictionary
    dictionary];\n  for (id obj in self) {\n    NSNumber* n = [dic objectForKey:obj];\n
    \   if (n) {\n      [dic setObject:[NSNumber numberWithInteger:[n intValue] +
    1] forKey:obj];\n    } else {\n      [dic setObject:[NSNumber numberWithInteger:1]
    forKey:obj];\n    }\n  }\n  \n  NSMutableArray* result = [NSMutableArray array];\n
    \ for (id obj in self) {\n    NSNumber* n = [dic objectForKey:obj];\n    if ([n
    intValue] == 1) [result addObject:obj];\n  }\n  return result;\n}\n\n@end\n\nint
    main(int argc, char** argv)\n{\n  NSAutoreleasePool* pool = [NSAutoreleasePool
    new];\n  \n  NSArray* array = [NSArray arrayWithObjects:@\"a\", @\"b\", @\"c\",
    @\"b\", @\"d\", @\"a\", @\"d\", @\"e\", nil];\n  NSLog(@\"%@\", array);\n  NSLog(@\"%@\",
    [array uniqueElements]);\n  \n  [pool release];\n  return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4729'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/4729
  :user_name: pooq
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2007/12/10 17:49 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">j言語です。重複する要素をすべて消します。\r\n   dup_del 3 1 4 1
    5 9 2 6 5\r\n3 4 9 2 6\r\n   dup_del 'Hello, world!'\r\nHe, wrd!\r\n</pre>\n\t"
  :code: |
    dup_del=.3 :'y-.(-.~:y)#y'
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4879'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/4879
  :user_name: omoikani
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/374/
  :language: StandardML
  :time: 2007/12/19 01:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>まぁ、効率は良くない.。</p>\n\n\t"
  :code: |
    val xs = [3, 1, 4, 1, 5, 9, 2, 6, 5]

    fun uniq [] = []
      | uniq (x::xs) =
      if List.exists (fn y =&gt; y = x) xs then uniq (List.filter (fn z =&gt; z &lt;&gt; x) xs)
      else x :: uniq xs

    val _ = uniq xs
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5068'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5068
  :user_name: susu
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/218/
  :language: OCaml
  :time: 2007/12/31 07:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    (*リスト内のxの数はn未満か*)
    let rec count_lt lst n x =
      if n=0 then false else
      match lst with
      | [] -&gt; true
      | hd::tl -&gt; count_lt tl (if hd=x then (n-1) else n) x;;

    let list_only lst = List.filter (count_lt lst 2) lst;;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5221'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5221
  :user_name: 割と普通
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/581/
  :language: C
  :time: 2008/01/08 04:31 GMT
  :vote_count: '2'
  :vote_score: '0'
  :body: "\n\t  <p>Linqのサンプル的な位置づけで。\nDistinctは遅延実行してくれるそうですが、今回の例だと遅延実行の意味が無いなぁ…。</p>\n\n\t"
  :code: |
    using System;
    using System.Linq;

    class Program
    {
        public static void Main( string[] args )
        {
            int[] array = { 3, 1, 4, 1, 5, 9, 2, 6, 5 };
            foreach( int unique in (from num in array select num).Distinct() )
                Console.WriteLine( unique );
        }
    }
  :tags:
  - 冗長
  :references:
    :url: 
    :title: 
- :id: '5595'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5595
  :user_name: g000001
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/405/
  :language: Arc
  :time: 2008/01/31 07:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Arcです。\r<br>(uniq-only '(3 1 4 1 5 9 2 6 5))\r<br>;=&gt; (3 4 9 2 6)\n\t"
  :code: "(def uniq-only (lst)\n  (rem (fn (item) (mem item (cdr:mem item lst))) \n
    \      lst))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5597'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5597
  :user_name: g000001
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/405/
  :language: Arc
  :time: 2008/01/31 07:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Arcです。\r<br>[]記法が使えるのを忘れてました。短いのは良いとは思えど…。\n\t"
  :code: |
    (def uniq-only (lst)
      (rem [mem _ (cdr:mem _ lst)] lst))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5625'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5625
  :user_name: SumiTomohiko
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/614/
  :language: Scheme
  :time: 2008/02/01 18:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    (define (remove-elem l e result)
        (if (= (length l) 0)
            result
            (if (= (car l) e)
                (remove-elem (cdr l) e result)
                (remove-elem (cdr l) e (append result (list (car l)))))))

    (define (has-elem? l e)
        (if (= (length l) 0)
            #f
            (if (= (car l) e)
                #t
                (has-elem? (cdr l) e))))

    (define (uniq-only-inner l all result)
        (if (= (length l) 0)
            result
            (if (has-elem? all (car l))
                (uniq-only-inner (cdr l) all (remove-elem result (car l) ()))
                (uniq-only-inner (cdr l) (append all (list (car l))) (append result (list (car l)))))))

    (define (uniq-only l)
        (uniq-only-inner l () ()))

    (display (uniq-only '(3 1 4 1 5 9 2 6 5)))  ;; (3 4 9 2 6)
    (display (uniq-only '(1 2 1 2 3 1 2 3 4)))  ;; (4)
    (display (uniq-only '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9)))  ;; (4 2 6 8 7)
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '5689'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5689
  :user_name: queck
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/681/
  :language: Other
  :time: 2008/02/05 14:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Factor です。</p>\n\n\t"
  :code: |
    USING: kernel sequences combinators.lib math ;

    : uniq-only ( seq -- newseq )
        dup [ [ = ] curry ] swap [ slip swap count 1 = ] 2curry subset ;

    ! example
    USE: prettyprint
    { 3 1 4 1 5 9 2 6 5 } uniq-only .
  :tags:
  - Factor
  :references:
    :url: 
    :title: 
- :id: '5690'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5690
  :user_name: naranja
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/448/
  :language: JavaScript
  :time: 2008/02/05 14:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  ワンライナー。\n\t"
  :code: |
    [3, 1, 4, 1, 5, 9, 2, 6, 5].filter(function(e, i, a){return a.slice(0, i).indexOf(e) == -1 &amp;&amp; a.slice(i + 1).indexOf(e) == -1;});
  :tags:
  - JavaScript1.6
  :references:
    :url: 
    :title: 
- :id: '5771'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/5771
  :user_name: saws
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/642/
  :language: Ruby
  :time: 2008/02/18 05:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>折角なので, uniqメソッドを利用してみました.</p>\n\n\t"
  :code: |
    class Array
      def get_uniq
        uniq.delete_if{|x| index(x) != rindex(x)}
      end
    end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6171'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6171
  :user_name: pooq
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/606/
  :language: Io
  :time: 2008/04/12 05:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Io&gt; list(1,2,4,3,2,1,4,5,6,7) removeDup\r\n==&gt;
    list(3, 5, 6, 7)</pre>\n\t"
  :code: |
    List removeDup := method(
      self uniqueCount select(last == 1) map(first)
    )
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6445'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6445
  :user_name: 誤字脱字
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/817/
  :language: J
  :time: 2008/06/06 06:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">J言語です。</pre>\n\t"
  :code: |
    uniq =. ]-.(([:-.~:)#])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6581'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6581
  :user_name: turugina
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/760/
  :language: XSLT
  :time: 2008/06/24 21:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">selector ([]) が sequenceに対しても使えるので楽ですね。</pre>\n\t"
  :code: |
    &lt;xsl:stylesheet version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:fn="http://www.w3.org/2005/xpath-functions"
      &gt;

      &lt;xsl:output method="text" /&gt;

      &lt;xsl:template match="/" &gt;
        &lt;xsl:variable name="seq" as="xs:integer*"
          select="(3,1,4,1,5,9,2,6,5)" /&gt;
        &lt;xsl:value-of
          select="$seq[fn:count(fn:index-of($seq,.))=1]" /&gt;
      &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6627'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6627
  :user_name: nobsun
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2008/06/30 15:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>unfoldr を使ってみた</p>\n\n\t"
  :code: "import Data.List\n\nuniqOnly :: Eq a =&gt; [a] -&gt; [a]\nuniqOnly = unfoldr
    phi\n  where \n   phi [] = Nothing\n   phi (x:xs) = if x `notElem` xs then Just
    (x,xs)\n                else phi (filter (x /=) xs)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6640'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6640
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2008/07/02 05:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Data.Map を使って。</pre>\n\t"
  :code: |
    import Data.Map (fromListWith,(!))

    uniqOnly xs = filter ((==1).(m!)) xs  where
      m = fromListWith (+) [(x,1)| x &lt;- xs]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6828'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6828
  :user_name: nemo_kaz
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/837/
  :language: Groovy
  :time: 2008/07/25 01:57 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  この簡潔さ、イケてると思う。\r<br>Groovyは、モテ言語といえるでしょう。\r<br><br>実行結果\r<br>----------------------------------\r<br>[3, 1, 4, 5, 9, 2, 6]\n\t"
  :code: |
    def xs=[3, 1, 4, 1, 5, 9, 2, 6, 5]

    println xs.unique()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6830'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/6830
  :user_name: pooq
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/606/
  :language: 
  :time: 2008/07/25 03:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">問題をよくみて解きましょう。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7037'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/7037
  :user_name: matyr
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/343/
  :language: Groovy
  :time: 2008/08/07 04:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    groovy -e "print args.grep{!args.grep(it)[1]}" 3 1 4 1 5 9 2 6 5
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7219'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/7219
  :user_name: emasaka
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/852/
  :language: sed
  :time: 2008/08/19 08:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>echo '314159265' | sed -f onlyunique.sed\nのように使います。</p>\n\n\t"
  :code: |
    s/$/#/
    :loop
    s/\(.\)\(.*\)\1\(.*\)$/\2\3\1/
    t loop
    s/#.*//
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7707'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/7707
  :user_name: silverwire
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/646/
  :language: Batchfile
  :time: 2008/09/25 20:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">バッチで。(内容は #7705とほぼ同様です。)</pre>\n\t"
  :code: "@echo off\nsetlocal enabledelayedexpansion\n  set t=\n  set v=\n  set #=0\n\n
    \ if \"%*\" == \"\" exit /b 1\n\n  for %%v in (%*) do (\n    echo !v! | findstr
    /l \"%%v\" &gt; NUL &amp;&amp; (set v=!v:%%v=!) || (set v=!v!%%v )\n  )\n\n  for
    %%v in (%v%) do (\n    if not defined %%v (\n      set %%v=!#!\n      set /a #+=1\n
    \   )\n  )\n\n  for /f \"tokens=1,2 delims==\" %%i in ('set ^| findstr /r \"^[0-9]\"')
    do set _%%j=%%i\n\n  set /a #-=1\n  for /l %%i in (0,1,%#%) do (\n    if defined
    !_%%i! set t=!t!!_%%i! \n  )\nendlocal &amp; if not \"%t%\" == \"\" echo %t%\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8154'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/8154
  :user_name: taninsw
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/973/
  :language: Other
  :time: 2008/12/13 09:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>import抜きなら一行。</p>\n<p>元のリストから「元のリストをnubで重複削除したもの」の中身を消していけば、重複している要素だけが残るという寸法。</p>\n<p>あとは、それをフィルターで排除するだけ。</p>\n\n\t"
  :code: |
    import List
    unique xs = filter (\x-&gt;notElem x (xs \\ nub xs)) xs
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8155'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/8155
  :user_name: taninsw
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/973/
  :language: Haskell
  :time: 2008/12/13 09:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>言語指定するの忘れてました。訂正ついでにどうせ2行なので再投稿。</p>\n\n\t"
  :code: |
    import List
    unique xs = filter (\x-&gt;notElem x (xs \\ nub xs)) xs
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10399'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/10399
  :user_name: gushwell
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1046/
  :language: Other
  :time: 2010/04/16 21:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>オーソドックスな方法で。</p>\n\n\t"
  :code: |2
     static IEnumerable&lt;T&gt; UniqOnly&lt;T&gt;(IEnumerable&lt;T&gt; list) {
         Dictionary&lt;T, int&gt; mem = new Dictionary&lt;T, int&gt;();
         foreach (var n in list) {
             if (mem.ContainsKey(n))
                 mem[n] = mem[n] + 1;
             else
                 mem[n] = 1;
         }
         return list.Where(e =&gt; mem[e] == 1);
     }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10400'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/10400
  :user_name: gushwell
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1046/
  :language: C
  :time: 2010/04/16 21:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>LINQのクエリ式で。</p>\n\n\t"
  :code: |2
     static IEnumerable&lt;T&gt; UniqOnly&lt;T&gt;(IEnumerable&lt;T&gt; list) {
         var q = from n in list
                 group n by n;
         return from g in q
                where g.Count() == 1
                select g.Key;
     }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10401'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/10401
  :user_name: gushwell
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1046/
  :language: C
  :time: 2010/04/16 21:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>効率無視の方法で。</p>\n\n\t"
  :code: |2
     static IEnumerable&lt;T&gt; UniqOnly&lt;T&gt;(IEnumerable&lt;T&gt; list) {
         return list.Where(n =&gt; (list.Count(x =&gt; x.Equals(n)) == 1));
     }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10404'
  :parent_id: '56'
  :url: http://ja.doukaku.org/comment/10404
  :user_name: gushwell
  :user_url: /web/20100606040154/http://ja.doukaku.org/user/1046/
  :language: 
  :time: 2010/04/16 21:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  「#10399」は、C#のコードです。\r\n失礼しました。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
