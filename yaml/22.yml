---
:id: '22'
:title: 実行時間の測定
:comments:
- :id: '3378'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/3378
  :user_name: にしお
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/14 20:13 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  ある比較的重たい処理をする関数「func」があるとします。\r\nこの関数を呼び出して、その実行にかかった時間を表示する関数「profile」を書いてください。\r\n<p>\r\n言語として可能であれば、「profile」が「func」と同じ引数で呼び出せるようにしてください。\r\n\t</p>"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '869'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/869
  :user_name: shiro
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/41/
  :language: Scheme
  :time: 2007/07/14 20:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  「同じ引数で…」ということは、funcは決め打ちでいいのかな。\n\t"
  :code: |
    (define (profile . args) (time (apply func args)))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '870'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/870
  :user_name: onjo
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/235/
  :language: Common
  :time: 2007/07/14 20:42 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  Common Lisp には TIME マクロが標準機能として規格に入ってます\n\t"
  :code: |
    CL-USER&gt; (defun func (n) (if (&lt;= n 0) 'ok (foo (1- n))))
    FOO
    CL-USER&gt; (compile 'func)
    FOO
    NIL
    NIL
    CL-USER&gt; (time (func 100000))
    ; cpu time (non-gc) 15 msec user, 0 msec system
    ; cpu time (gc)     0 msec user, 0 msec system
    ; cpu time (total)  15 msec user, 0 msec system
    ; real time  5 msec
    ; space allocation:
    ;  1 cons cell, -32 other bytes, 0 static bytes
    OK
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '871'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/871
  :user_name: onjo
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/235/
  :language: Common
  :time: 2007/07/14 20:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  関数にしないとだめかな…\n\t"
  :code: |
    (defun profile (&amp;rest args) (time (apply #'func args)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '872'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/872
  :user_name: id:amachang
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/62/
  :language: JavaScript
  :time: 2007/07/14 20:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  何のひねりもなしでつ＞＜\n\t"
  :code: |
    var profile = function() {
      var start = new Date;
      func.apply(this, arguments);
      alert((new Date).getTime() - start.getTime() + 'ms');
    };
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '874'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/874
  :user_name: anekos
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/170/
  :language: Ruby
  :time: 2007/07/14 20:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  安直\n\t"
  :code: "def profile (*args, &amp;block)\n\tbefore = Time.now\n\tfunc(*args, &amp;block)\n\tputs
    \"profile: #{Time.now - before} sec\"\nend\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '876'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/876
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: Ruby
  :time: 2007/07/14 21:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  かぶってそう…\n\t"
  :code: |
    require 'benchmark'
    def profile(&amp;block)
      real = Benchmark::measure(&amp;block).real
      $stderr.puts "#{real} secs"
    end

    def func
      puts "output from func"
      sleep 1
    end

    profile { func }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '878'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/878
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: Lua
  :time: 2007/07/14 21:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  luaは整数秒しか出なくて困る＞＜\r\n\r\n高階関数が使えるから、これでいいよね。\n\t"
  :code: |
    function profile(block)
      start = os.clock()
      block()
      endt = os.clock()
      print(string.format("%s secs", os.difftime(endt, start)))
    end

    function func(n)
      print("output from func")
      for i = 1, n, 1 do
        -- do nothing
      end
    end

    profile( function() func(100000000) end )
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '879'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/879
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: Emacs
  :time: 2007/07/14 21:41 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  elispだとビット数の制限のせいでcurrent-timeの表現が複雑…\n\t"
  :code: |
    (require 'cl)
    (defun profile (block)
      (labels ((timediff (s e)
                 (destructuring-bind (h1 l1 m1) s
                   (destructuring-bind (h2 l2 m2) e
                     (+ (* 65536 (- h2 h1)) (- l2 l1) (* 0.000001 (- m2 m1)))))))
        (let ((s-time (current-time)) e-time)
          (funcall block)
          (setq e-time (current-time))
          (message "%s secs" (timediff s-time e-time)))))

    ;; (profile (lambda () (sit-for 1)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '880'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/880
  :user_name: 沢渡 みかげ
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/101/
  :language: Erlang
  :time: 2007/07/15 00:09 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">erl -noshell -eval 'profile:profile([1, 2]),init:stop().'\r\nのように実行します．\r\n\r\n任意の可変長の引数をとる方法はないはずなので，引数のリストを渡すか，\r\n必要と予想される引数の個数まで定義をたくさん書くしか方法はないと思います．\r\n\r\n今回は引数のリストを渡す形にしました．</pre>\n\t"
  :code: |
    -module(profile).
    -export([profile/1, func/2]).

    func(A, B) -&gt;
        io:format("func ~w ~w~n", [A, B]).

    profile(Args) -&gt;
        io:format("~w~n", [timer:tc(?MODULE, func, Args)]).
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '881'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/881
  :user_name: cats
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/172/
  :language: C
  :time: 2007/07/15 00:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    using System;
    using System.Diagnostics;
    using System.Threading;
    class Program
    {
      public delegate void Func(params object[] args);
      static void Main()
      {
        Func de1 = delegate(object[] args) { func((string)args[0]); };
        profile(de1, "test1");
        Func de2 = delegate(object[] args) { func2((int)args[0], (string)args[1]); };
        profile(de2, 123, "test2");
      }
      static void profile(Func de, params object[] args)
      {
        Stopwatch sw = new Stopwatch();
        sw.Start();
        de(args);
        sw.Stop();
        Console.WriteLine("{0} sec", sw.Elapsed.TotalSeconds);
      }
      static void func(string s)
      {
        Console.WriteLine("Start func {0}", s);
        Thread.Sleep(1000);
      }
      static void func2(int i, string s)
      {
        Console.WriteLine("Start func2 {0} {1}", s, i);
        Thread.Sleep(1000);
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '885'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/885
  :user_name: kkobayashi
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/15 01:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Rでは可変引数は扱えないようなので、引数のリストを渡すか、決めうちか、\r\nfunc(a,b,c)ごと渡すしかないようです。\r\n\r\n&gt;
    profile(100,10,1)\r\nuser : 76.56\r\nsys : 0.110000000000000\r\ntotal : 82.0100000000001\r\ncumulative
    user : NA\r\ncumulative sys : NA</pre>\n\t"
  :code: "profile &lt;- function(a, b, c){\n    cat(paste(c(\"user\", \"sys\", \"total\",
    \"cumulative user\", \"cumulative sys\"), \n        system.time(func(a,b,c)),
    sep=\" : \"), sep=\"\\n\")\n}\n\nfunc &lt;- function(a,b,c){\n    for (i in 1:1000000)
    sample(a:b)\n    for (i in 1:1000000) sample(a:c)\n    for (i in 1:1000000) sample(b:c)\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '886'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/886
  :user_name: 匿名
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/07/15 01:47 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  これでいけるんだっけかな。\r\n\n\t"
  :code: |
    import time

    def profile(f, *a, **b):
      t = time.time()
      f(*a, **b)
      return time.time() - t

    def func(a, b, *c, **d):
      time.sleep(3)

    print '%dsec' % profile(func,1,2)
    print '%dsec' % profile(func,1,2,3,4)
    print '%dsec' % profile(func,1,2,x=7,y=8)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '888'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/888
  :user_name: 匿名
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/07/15 02:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  題意からは関数名は固定されているのですが、任意のinterfaceの任意のメソッド名に対応できるように勝手に拡張しました。Proxyクラスを使用しています。\n\t"
  :code: "import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport
    java.lang.reflect.Method;\n\npublic class Profiler {\n    private BenchInvocationHandler
    handler;\n    private Object proxy;\n    private Object target;\n\n    public
    Profiler(Class targetInterface, Object myTarget) {\n        target = myTarget;\n
    \       handler = new BenchInvocationHandler(target);\n        proxy = Proxy.newProxyInstance(targetInterface.getClassLoader(),
    \n                                       new Class[]{targetInterface}, handler);\n
    \   }\n\n    public Object getProxy() {\n        return proxy;\n    }\n\n    public
    long getEstimatedTime() {\n        return handler.getEstimatedTime();\n    }\n}\n\nclass
    BenchInvocationHandler implements InvocationHandler {\n    private Object target;\n
    \   private long estimatedTime;\n\n    public BenchInvocationHandler(Object myTarget)
    {\n        target = myTarget;\n    }\n\n    public Object invoke(Object proxy,
    Method method, Object[] args) throws Exception {\n        long start = System.nanoTime();\n
    \       Object res = method.invoke(target, args);\n        estimatedTime = System.nanoTime()
    - start;\n        return res;\n    }\n\n    public long getEstimatedTime() {\n
    \       return estimatedTime;\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '889'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/889
  :user_name: 匿名
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/07/15 02:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  使い方のサンプルをあげておきます。コンストラクタで測定対象のinterfaceとインスタンスを渡します。getProxyで得られるProxyインスタンスを通常通り呼び出した後でgetEstimatedTimeメソッドの呼び出しで、直前のメソッドの実行時間（ナノ秒）が得られます。\n\t"
  :code: |
    public class Sample implements Runnable {
        public static void main(String[] args) throws Exception {
            Profiler prof = new Profiler(Runnable.class, new Sample());
            Runnable p = (Runnable)prof.getProxy();
            p.run();
            System.out.println(prof.getEstimatedTime());
        }

        public void run() {
            System.out.println("Hello refrelction world.");
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '890'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/890
  :user_name: sumim
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/15 02:42 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Squeak Smalltalk で処理の時間を計りたいときは、処理をブロック化（無名関数化）して記述し、それに timeToRun
    を送信します。\n\t"
  :code: |
    [obj func] timeToRun
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '892'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/892
  :user_name: ココサブ
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/24/
  :language: C
  :time: 2007/07/15 03:40 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">http://seclan.dll.jp/c99d/c99d02.htm#dt19990405\r\n\r\nを参考にマクロで実装。\r\nprofileは正確には関数でなくなってしまいました。\r\nただ、引数の数を気にせず動きます。</pre>\n\t"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;time.h&gt;

    #define profile(FUNC, ...) \
        {\
            time_t start, end;\
            \
            start = clock();\
            FUNC(__VA_ARGS__);\
            end = clock();\
            printf("%f\n", (double)(end - start) / CLOCKS_PER_SEC);\
        }

    int main()
    {
        profile(printf, "%s:%d\n", "hoge", 10);
        profile(puts, "abcdef");
        return 0;
    }
  :tags:
  - C99
  :references:
    :url: 
    :title: 
- :id: '894'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/894
  :user_name: kacchi
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/145/
  :language: Emacs
  :time: 2007/07/15 04:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">timeという自前の関数があったので、名前だけ変えました。</pre>\n\t"
  :code: |
    (defun profile (func &amp;rest args)
      (let ((start (current-time)))
        (apply func args)
        (time-to-seconds (time-subtract (current-time) start))))
  :tags:
  - Emacs22
  :references:
    :url: 
    :title: 
- :id: '897'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/897
  :user_name: yuin
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/15 06:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">オーバーロードされたメソッドがあっても始めに見つかったメソッドのみ対象。</pre>\n\t"
  :code: |
    def profile(args: Any*):Unit = {
      val f = getClass.getDeclaredMethods.find(_.getName.startsWith("func")).get
      val start = System.nanoTime
      f.invoke(this, args.map(_.asInstanceOf[AnyRef]).toArray)
      println(System.nanoTime-start + " nano seconds.")
    }

    def func(i:Int, j:Int):Unit = {
      println(i, j)
    }

    profile(1,2)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '901'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/901
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: D
  :time: 2007/07/15 08:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    module doukaku;
    private import std.stdio;
    private import std.date;

    d_time profile(void delegate() yield) {
        d_time s = getUTCtime(), diff;
        yield();
        diff = getUTCtime() - s;
        writefln("%f secs", cast(real)diff / TicksPerSecond);
        return diff;
    }

    void func(int n) {
        writefln("output from func");
        for (int i=0; i&lt;n; i++){};
    }

    void main() {
        profile(delegate() { func(1000000000); });
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '902'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/902
  :user_name: ether
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/96/
  :language: Lua
  :time: 2007/07/15 08:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  以前 Higher Order Perl を参考にして Lua で書いたことがあるもの &lt;http://nul.jp/2007/hol/profile&gt;
    からほぼ転載。\r\n\r\n「func = profile(func, \"func\")」とすると func そのものが時間を計測する func に置き換わります。\r\n\r\n新しい
    func は同じ引数で使えて同じ戻り値（多値も可）を返しますが、副作用として time[\"func\"] に所要時間を累積していきます（ちょっと題意からは外れるかな）。\n\t"
  :code: |
    time = {}

    function profile(func, name)
      return function(...)
        local start = os.clock()
        local result = {func(...)}
        local end_ = os.clock()
        local elasped = end_ - start

        time[name] = time[name] and time[name] + elasped or elasped

        return unpack(result)
      end
    end

    function func(n)
      print("output from func")
      for i = 1, n, 1 do
        -- do nothing
      end
    end

    func = profile(func, "func")

    func(9999999)

    print(time.func)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '903'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/903
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: Perl
  :time: 2007/07/15 08:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  あー、referenceなんかすっかり忘れてる＞＜\n\t"
  :code: |
    sub profile {
        my $yield = $_[0];
        $start = time();
        &amp;$yield();
        $end = time();
        printf("%s secs\n", $end-$start);
    }

    sub func {
        my $n = $_[0];
        my $i;
        for ($i=0; $i&lt;$n; $i++){};
    }

    profile(sub { func(10000000) });
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '907'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/907
  :user_name: ether
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/96/
  :language: 
  :time: 2007/07/15 09:06 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  主要な環境では os.clock の精度は秒より細かいはずで、単に引き算すればよいと思います。\r\n\r\nまた os.difftime
    が引数として期待する時刻は os.time が返すような値（普通エポックからの秒数）なので os.clock の戻り値（システム依存の精度の CPU 時間）を与えるのは適切でないと思います。整数秒しか出ないのは多分
    os.difftime のせいで、それでもうまく行っているように見えるのは os.difftime を突き詰めていくと結局引き算（おそらく整数の）にたどり着くからだと思われます。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '916'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/916
  :user_name: 匿名
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/07/15 11:06 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あらためて考えてみると、この場合、戻り値も返すべきなんじゃないかな。</pre>\n\t"
  :code: |
    import time

    def profile(__f, *a, **b):
      t = time.time()
      r = __f(*a, **b)
      print time.time() - t
      return r
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '920'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/920
  :user_name: iwk
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/49/
  :language: OCaml
  :time: 2007/07/15 11:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    open System;;

    let time f =
        let start = DateTime.Now in
        let res = f () in
        let finish = DateTime.Now in
        Console.WriteLine( (finish-start) );
        res;;

    let rec fib n =
        if n = 0
        then 1
        elif n = 1
        then 1
        else fib (n-1) + fib (n-2);;

    let profile n = time (fun () -&gt; fib n);;
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '921'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/921
  :user_name: mjy
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/94/
  :language: Bash
  :time: 2007/07/15 12:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    function profile(){
        time func $@
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '922'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/922
  :user_name: 時間蠅
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/250/
  :language: Matlab
  :time: 2007/07/15 12:04 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Matlabでは、ticで時間を記録し、tocでticからの時間を得ることができます。vararginは可変長引数のため。\n\t"
  :code: |
    function profile(varargin)
      tic;
      func(varargin{:});
      disp(toc);
    end
  :tags:
  - Matlab
  :references:
    :url: 
    :title: 
- :id: '923'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/923
  :user_name: 時間蠅
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/250/
  :language: Matlab
  :time: 2007/07/15 12:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">以下のfuncを定義したときの実行結果は\r\n\r\n&gt;&gt; profile(3)\r\n
    \   3.0018\r\n\r\nとなりました。単位は秒のようです。</pre>\n\t"
  :code: |
    function func(x)
      pause(x);
    end
  :tags:
  - Matlab
  :references:
    :url: 
    :title: 
- :id: '941'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/941
  :user_name: rubikitch
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/105/
  :language: 
  :time: 2007/07/15 19:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ほんとですね。\r\n&gt; === os.difftime (t2, t1)\r\n&gt;
    時刻 t1 から時刻 t2 までの秒数を返す。 POSIX や Windows、その他のいくつかのシス\r\n&gt; テムでは、この値は t2-t1 に等しい。\r\nマニュアルの説明からでは思い付きませんでした。ありがとうございます。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1008'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1008
  :user_name: kkobayashi
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/16 13:18 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  すいませんウソつきました。\"...\"で可変長引数を扱えるようです。\r\n\n\t"
  :code: "profile &lt;- function(...){\n    cat(paste(c(\"user\", \"sys\", \"total\",
    \"cumulative user\", \"cumulative sys\"), \n        system.time(func(...)), sep=\"
    : \"), sep=\"\\n\")\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1020'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1020
  :user_name: noeta
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/60/
  :language: PHP
  :time: 2007/07/17 04:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  PHP6非対応\n\t"
  :code: |
    &lt;?php
    function profile(/* args */) {
        $func_name = 'func';
        if (!function_exists($func_name)) {
            return false;
        }
        $args = func_get_args();
        $start = microtime();
        call_user_func_array($func_name, $args);
        $end = microtime();
        list($susec, $ssec) = explode(" ", $start);
        list($eusec, $esec) = explode(" ", $end);
        return ($esec - $ssec) + ($eusec - $susec);
    }
    ?&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1025'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1025
  :user_name: TGBT
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/167/
  :language: C
  :time: 2007/07/17 06:55 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  インスパイヤして高精度タイマー版を作ってみたり。\r\nせっかくだから、#ifdefを使ってWindowsでもLinuxでもOKにしておきました。\n\t"
  :code: "#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/types.h&gt;\n\n#ifdef
    _WIN32\n#include &lt;windows.h&gt;\t\t// LARGE_INTEGERに必要\n#endif\n\n#ifdef _LINUX\n#include
    &lt;sys/time.h&gt;\t\t// timezoneに必要\n#endif\n\n#ifdef _WIN32\n#define profile(FUNC,
    ...) \\\n    {\\\n\tLARGE_INTEGER liFreq, liBegin, liEnd;\\\n\tdouble dSec;\\\n\tQueryPerformanceFrequency(&amp;liFreq);\\\n\tQueryPerformanceCounter(&amp;liBegin);\\\n
    \       FUNC(__VA_ARGS__);\\\n\tQueryPerformanceCounter(&amp;liEnd);\\\n\tdSec\t=
    (double)(liEnd.QuadPart - liBegin.QuadPart)/(double)liFreq.QuadPart;\\\n        printf(\"%f
    sec\\n\", dSec);\\\n    }\n#endif\n\n#ifdef _LINUX\n#define profile(FUNC, ...)
    \\\n    {\\\n\tstruct timeval tBegin, tEnd;\\\n\tstruct timezone tz;\\\n\tdouble
    dSec;\\\n\tdouble dBegin, dEnd;\\\n\tgettimeofday(&amp;tBegin, &amp;tz);\\\n        FUNC(__VA_ARGS__);\\\n\tgettimeofday(&amp;tEnd,
    &amp;tz);\\\n\tdBegin\t= tBegin.tv_sec + (double)tBegin.tv_usec*1.0e-6;\\\n\tdEnd\t=
    tEnd.tv_sec + (double)tEnd.tv_usec*1.0e-6;\\\n\tdSec\t= dEnd - dBegin;\\\n        printf(\"%f
    sec\\n\", dSec);\\\n    }\n#endif\n\nint main()\n{\n    profile(printf, \"%s:%d\\n\",
    \"hoge\", 10);\n    profile(puts, \"abcdef\");\n    return 0;\n}\n"
  :tags:
  - Linux
  - Windows
  :references:
    :url: 
    :title: 
- :id: '1027'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1027
  :user_name: talo
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/237/
  :language: Java
  :time: 2007/07/17 07:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">単純にinvokeしたものを計測。</pre>\n\t"
  :code: |
    import java.lang.reflect.Method;

    public class Profiler {

        public static long profile(Object o, String methodName, Object... args)
            throws Exception {
            long start = System.currentTimeMillis();
            Method method = getMethod(o.getClass(), methodName);
            method.invoke(o, args);
            return System.currentTimeMillis() - start;
        }

        private static Method getMethod(Class&lt;?&gt; cls, String name)
            throws Exception {
            for (Method m: cls.getDeclaredMethods()) {
                if (m.getName().equals(name)) {
                    m.setAccessible(true);
                    return m;
                }
            }
            throw new NoSuchMethodException("メソッドがありません");
        }

        private Profiler() {
        }

        /**
         * サンプルメソッド
         */
        private int func(int a, int b) throws Exception {
            Thread.sleep(1000);
            return a + b;
        }

        public static void main(String[] args)
            throws Exception {
            Profiler o = new Profiler();
            System.out.println(Profiler.profile(o, "func", 1, 2) + "ms.");
        }

    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1038'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1038
  :user_name: ココサブ
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/24/
  :language: 
  :time: 2007/07/17 15:05 GMT
  :vote_count: '3'
  :vote_score: '-1'
  :body: "\n\t  おおお。\r\nスゴイ！！\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1278'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1278
  :user_name: katsu
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/117/
  :language: Prolog
  :time: 2007/07/21 12:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">こんなかんじで。\r\nところで、前回書いた投稿の言語とタグは、そのまま残るとありがたいです。</pre>\n\t"
  :code: |
    profile(X,T):-get_time(Before),X,get_time(After),T is After - Before.

    :-profile(sleep(1),T),writeln(T).
  :tags:
  - SWI-prolog
  :references:
    :url: 
    :title: 
- :id: '1348'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1348
  :user_name: 沢渡 みかげ
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/101/
  :language: Mathematica
  :time: 2007/07/22 11:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">結果は秒です．\r\nAbusoluteTimingの代わりにTimingでCPU時間になります．\r\n\r\n実行例：\r\n\r\nIn[1]:=
    func[x_, y_] := \r\n Module[{i, s}, s = 0; For[i = 0, i &lt;= x, i++, s = s +
    i y]; s]\r\n\r\nIn[2]:= profile[p__] := Module[{time, res},\r\n   {time, res}
    = AbsoluteTiming[func[p]];\r\n   Print[time];\r\n   res];\r\n\r\nIn[3]:= func[100000,
    2]\r\n\r\nOut[3]= 10000100000\r\n\r\nIn[4]:= profile[100000, 2]\r\n\r\n0.7500000\r\n\r\nOut[4]=
    10000100000\r\n\r\n</pre>\n\t"
  :code: |
    profile[p__] := Module[{time, res},
       {time, res} = AbsoluteTiming[func[p]];
       Print[time];
       res];
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1499'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1499
  :user_name: zigorou
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/64/
  :language: Perl
  :time: 2007/07/27 07:23 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Time::HiRes版\n\t"
  :code: |
    #!/usr/bin/perl

    use strict;
    use warnings;

    use Time::HiRes qw/time/;

    sub profile {
        my ($code, @args) = @_;
        my $start = time();
        $code-&gt;(@args);
        my $end = time();
        printf("%.4f secs\n", $end - $start);
    }

    {
        no warnings 'recursion';
        sub factorial {
            my $n = shift;
            ($n &gt; 2) ? $n * factorial($n - 1) : $n;
        }
    }

    profile(\&amp;factorial, 1000000);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1619'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1619
  :user_name: nobsun
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/07/31 05:53 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">とりあえずWHNFにまで簡約する時間(秒)</pre>\n\t"
  :code: |
    import System.IO.Unsafe
    import System.CPUTime
    profile :: a -&gt; a
    profile e = unsafePerformIO
              $ do { s &lt;- getCPUTime
                   ; r &lt;- return $! e
                   ; e &lt;- getCPUTime
                   ; putStrLn $ show $ fromInteger (e - s) / fromInteger (10^12)
                   ; return r
                   }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1641'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1641
  :user_name: morchin
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/08/01 04:42 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">#916のコードをデコレータに対応させてみた。\r\nデコレータをネストすると、func.__name__でおおもとの関数の名前が取れなくなるが、\r\nリフレクション使っても、おおもとの関数がどこかを判別できない気がする。何か良い方法ないかな。\r\n</pre>\n\t"
  :code: "import time\n\ndef profile(func):\n\tdef foo(*a, **k):\n\t\tt = time.time()\n\t\tr
    = func(*a, **k)\n\t\tprint '%s: %g sec elapsed' % (func.__name__, time.time()
    - t)\n\t\treturn r\n\treturn foo\n\nif __name__ == '__main__':\n    @profile\n
    \   def func(a, b):\n        time.sleep(2)\n\n    func(1, 2)\n    # func: 2 sec
    elapsed\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1642'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1642
  :user_name: morchin
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/08/01 05:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">デコレータに引数を付ければOKみたいだけど、引数なしの場合に\r\nprofileの後に()を付けなければいけないので分かりづらい…。\r\n</pre>\n\t"
  :code: "import time\n\ndef profile(name = None):\n\tdef profile2(func):\n\t\tdef
    profile3(*a, **k):\n\t\t\tt = time.time()\n\t\t\tr = func(*a, **k)\n\t\t\tname2
    = name if name else func.__name__\n\t\t\tprint '%s: %g sec elapsed' % (name2,
    time.time() - t)\n\t\t\treturn r\n\t\treturn profile3\n\treturn profile2\n\ndef
    loop(func):\n    ...\n\n@profile('test')\n@loop\ndef test(a, b):\n    time.sleep(2)\n\n@profile()\ndef
    test(a, b):\n    time.sleep(2)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1643'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1643
  :user_name: ocean
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/08/01 06:24 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  確か、functools.wraps がこの用途に用いられる関数だった気がします。\n\t"
  :code: |
    import time
    import functools

    def profile(func):
        @functools.wraps(func)
        def foo(*a, **k):
            t = time.time()
            r = func(*a, **k)
            print '%s: %g sec elapsed' % (func.__name__, time.time() - t)
            return r
        return foo

    def loop(func):
        @functools.wraps(func)
        def foo(*a, **k):
            return func(*a, **k)
        return foo

    @loop
    @profile
    @loop
    def test(a, b):
        time.sleep(0.5)

    test(1, 2)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1645'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1645
  :user_name: morchin
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/78/
  :language: 
  :time: 2007/08/01 06:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">なるほど。すばらしいです。\r\n但し、既存のデコレータと組み合わせることを考えると、loop()関数の中で\r\n@functools.wraps()を書かなくて良いようになればベストなのですが…。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1716'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1716
  :user_name: tomatsu
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/323/
  :language: Pnuts
  :time: 2007/08/02 12:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    function profile (f){
       function (args[]) {
             t = currentTimeMillis()
             r = call(f, args)
             println(currentTimeMillis() - t)
             r
       }
    }

    function looptest(n){
       for (i:1..n){}
    }

    profile(looptest)(100000000)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1961'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/1961
  :user_name: jz5
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/08/07 03:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">SharedでないClass内の関数という想定。\r\nSharedだとMeが使えないので違った記述になります。</pre>\n\t"
  :code: |
    Public Sub profile(ByVal ParamArray args() As Object)
        Dim tm As DateTime = Now
        Me.GetType.InvokeMember("func", Reflection.BindingFlags.InvokeMethod, Nothing, Me, args)
        Console.WriteLine(Now.Subtract(tm).TotalMilliseconds)
    End Sub
  :tags: []
  :references:
    :url: /web/20100324085422/http://dobon.net/vb/dotnet/programing/typeinvokemember.html
    :title: 型のメンバを動的に呼び出す
- :id: '2118'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/2118
  :user_name: higeorange
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/194/
  :language: Io
  :time: 2007/08/13 14:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    profile := method(
         writeln(Date cpuSecondsToRun(func))
    )
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2189'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/2189
  :user_name: yagihiro
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/364/
  :language: xtal
  :time: 2007/08/15 01:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">0.9.7 から追加された(と思われる) clock() 関数を使ってみました。\r\n\r\n*
    profile 関数と func 関数が同じ引数を受け取れる。\r\n* func 関数の戻り値を profile 関数の戻り値としている。\r\n\r\nsvn
    rev154 (0.9.7.1)です。</pre>\n\t"
  :code: |
    profile: fun(...) {
      fmt: %f!profile: %d sec!;

      start: clock();
      result: func(...);
      fmt(clock() - start).p;

      return result;
    }

    func: fun(...) {
      for (i: 0; i &lt; 1000000; i++) {
        // 重たい処理
      }
    }

    profile("test");
  :tags:
  - xtal
  :references:
    :url: 
    :title: 
- :id: '2336'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/2336
  :user_name: omoikani
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/374/
  :language: StandardML
  :time: 2007/08/20 01:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">引数をタプルにすれば一応、可変個引数になる。</pre>\n\t"
  :code: |
    fun profile n =
      let
        val tm = Timer.startCPUTimer ()
        val _ = func n
        val ct = Timer.checkCPUTimer tm
        val ut = Time.toMilliseconds (#usr ct)
      in
        print ((LargeInt.toString ut) ^ "\n")
      end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2941'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/2941
  :user_name: 130R
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/409/
  :language: PowerShell
  :time: 2007/09/07 10:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">$argsが展開されて渡されてしまうのでとりあえず引数は無しで。綺麗に渡す方法無いかなー。\r\n\r\nPS
    C:\\&gt; function func{sleep 3}\r\nPS C:\\&gt; profile\r\n\r\n\r\nDays              :
    0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 2\r\nMilliseconds
    \     : 997\r\nTicks             : 29977106\r\nTotalDays         : 3.4695724537037E-05\r\nTotalHours
    \       : 0.000832697388888889\r\nTotalMinutes      : 0.0499618433333333\r\nTotalSeconds
    \     : 2.9977106\r\nTotalMilliseconds : 2997.7106</pre>\n\t"
  :code: |
    function profile{measure-command{func}}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3742'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/3742
  :user_name: fujidig
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/507/
  :language: 
  :time: 2007/11/07 06:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |2
        call profile;
        endmacro;

    profile:
        ##start = tickcount;
        call func;
        ##end = tickcount;
        message str( ##end - ##start ) + " ミリ秒";
        return;

    func:
        ##i = 500000;
        while ( ##i &gt; 0 ) {
            ##i = ##i - 1;
        }
        return;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3939'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/3939
  :user_name: 匿名
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/13 10:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">なでしこでは可変関数は無理っぽいのでこれで。</pre>\n\t"
  :code: |
    ●profile(a,b)
    　　stimeとは整数=システム時間
    　　tmpとは文字列
    　　tmp=func(a,b)
    　　(システム時間-stime)を表示
    　　tmpで戻る
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3979'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/3979
  :user_name: matyr
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/343/
  :language: 
  :time: 2007/11/13 18:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  こんな感じで計れますが，精度は期待できません。\n\t"
  :code: |
    profile＝「｜間　物｜(未定義＝＝間)！なら「間＝0.1」実行。(未定義＝＝物)！なら「物＝ルート」実行。
    　「｜時　秒｜時！(間)間隔「秒＝秒＋間」実行。物！func。時！中断。秒」！(タイマー！作る) ０ 実行」。

    func＝「「｜Ｔ｜「｜ｘ｜Ｔ！(ｘ＊２)円」！100回 繰り返す」！(タートル！作る)実行」。
    ラベル！(profile！実行)作る　-300 200 位置。
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4080'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/4080
  :user_name: faultier
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/545/
  :language: Objective
  :time: 2007/11/15 17:25 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  任意のオブジェクトに任意のメッセージを送ってその実行時間を測定するようにしてみました。\r<br>実行結果はこんな感じ。\r<br><br>$ ./profile                                                                                                                           \r<br>2007-11-16 02:11:49.268 profile[3982:10b] start  profiling [TestClass func:]\r<br>2007-11-16 02:11:49.274 profile[3982:10b] 一言言って1.000000秒待つことを3回繰り返すだけの簡単なお仕事です\r<br>2007-11-16 02:11:50.275 profile[3982:10b] 一言言って1.000000秒待つことを3回繰り返すだけの簡単なお仕事です\r<br>2007-11-16 02:11:51.276 profile[3982:10b] 一言言って1.000000秒待つことを3回繰り返すだけの簡単なお仕事です\r<br>2007-11-16 02:11:52.277 profile[3982:10b] finished!\r<br>2007-11-16 02:11:52.278 profile[3982:10b] process time: 3.003400 (sec)\n\t"
  :code: "#import &lt;Foundation/Foundation.h&gt;\n\n@interface Profiler : NSObject\n{\n
    \   id target;\n}\n- (id)initWithObject:(id)aTarget;\n- (void)setTarget:(id)aTarget;\n@end\n\n@implementation
    Profiler\n- (id)initWithObject:(id)aTarget\n{\n    [super init];\n    target =
    aTarget;\n    return self;\n}\n- (id)init\n{\n    return [self initWithObject:nil];\n}\n-
    (void)setTarget:(id)aTarget\n{\n    target = aTarget;\n    return;\n}\n- (void)profile:(NSInvocation
    *)anInvocation\n{\n    NSLog(@\"start profiling [%@ %s]\", [target className],
    [anInvocation selector]);\n    NSDate *startTime = [NSDate date];\n    [anInvocation
    invokeWithTarget:target];\n    NSDate *endTime = [NSDate date];\n    NSLog(@\"finished!\");\n
    \   NSLog(@\"process time: %f (sec)\", [endTime timeIntervalSinceDate:startTime]);\n
    \   return;\n}\n// メッセージ転送によって「対象の関数と同じ引数でプロファイル」を実現する\n// Profilerの実装していないメッセージが来たら、\n//
    実行時間の計測をしつつ実際の処理はtargetに移譲\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n
    \   if ([target respondsToSelector:aSelector])\n        return [target methodSignatureForSelector:aSelector];\n
    \   else\n        return [super methodSignatureForSelector:aSelector];\n}\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n
    \   if ([super respondsToSelector:aSelector])\n        return YES;\n    if ([self
    methodForSelector:aSelector] != (IMP)NULL)\n        return YES;\n    if ([target
    respondsToSelector:aSelector])\n        return YES;\n    return NO;\n}\n- (void)forwardInvocation:(NSInvocation
    *)anInvocation\n{\n    if ([target respondsToSelector:[anInvocation selector]])\n
    \   {\n        [self profile:anInvocation];\n    }\n    else\n    {\n        [super
    forwardInvocation:anInvocation];\n    }\n    return;\n}\n//--- メッセージ転送処理ここまで\n@end\n\n@interface
    TestClass : NSObject\n{\n    NSTimeInterval interval;\n}\n- (void)func:(int)times;\n@end\n\n@implementation
    TestClass\n- (id)init\n{\n    [super init];\n    interval = 1.0;\n    return self;\n}\n-
    (void)func:(int)times\n{\n    int i;\n    for (i = 0; i &lt; times; i++)\n    {\n
    \       NSLog(@\"一言言って%f秒待つことを%d回繰り返すだけの簡単なお仕事です\", interval, times);\n        [NSThread
    sleepForTimeInterval:interval];\n        // Xcode 2.x だとスレッドのスリープはこっち\n        //
    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:interval]];\n    }\n}\n@end\n\nint
    main(int argc, const char *argv[])\n{\n    NSAutoreleasePool *pool = [NSAutoreleasePool
    new];\n    \n    id testTarget = [TestClass new];\n    Profiler *profiler = [[Profiler
    alloc] initWithObject:testTarget];\n\n    //profilerに本来testTargetが受けとるはずのメッセージを送ってやる\n
    \   [profiler func:3];\n\n    [pool release];\n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4083'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/4083
  :user_name: faultier
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/545/
  :language: 
  :time: 2007/11/15 17:29 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <p>よく考えたらお題とずれてるなー。また何か考えます。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4947'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/4947
  :user_name: susu
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/218/
  :language: Python
  :time: 2007/12/24 02:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    import time

    def prof(func):
      start=time.time()
      func()
      return time.time()-start

    def foo(n):
      time.sleep(n)

    prof( lambda:foo(2) )
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5035'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5035
  :user_name: susu
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/218/
  :language: OCaml
  :time: 2007/12/28 11:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "#load \"unix.cma\";;\r\n\r\nmodule Prof = struct\r\n  (*秒以上で良いならUnix.time
    ()を使う。*)\r\n  let prof f =\r\n    let time () = Unix.gettimeofday () in\r\n    let
    start = time() in\r\n    f (); time() -. start\r\n  \r\n  (*複数回のテスト*)\r\n  let
    result n f =\r\n    Array.init n (fun _ -&gt; prof (fun() -&gt; f()) )\r\nend;;\r\n\r\n
    \ (* Preview *)\r\n    Prof.prof (fun () -&gt; Unix.sleep 2);;\r\n    Prof.result
    3 (fun () -&gt; Unix.sleep 1);;\r\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5043'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5043
  :user_name: pooq
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2007/12/28 19:51 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">実行時間を返す動詞「6!:2」がありました。右引数で測定したい部分\r\nを文字列で渡します。左引数を指定するとその回数だけ繰り返して平\r\n均値(秒)を返します。funcの中身は多倍長整数の階乗の階乗です。\r\n\r\n
    \  10 profile 'func 7'\r\n0.173487\r\n</pre>\n\t"
  :code: |
    func=:!&amp;!&amp;x:
    profile=:6!:2
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5143'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5143
  :user_name: saws
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/642/
  :language: Ruby
  :time: 2008/01/03 11:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ほとんど他の方と一緒.\nprofileとfuncに同じ引数を与えるより, funcを含む処理部分をProcオブジェクトとして扱った方がprofileに汎用性がでていいと思った.</p>\n\n\t"
  :code: |
    def profile(&amp;proc)
      start = Time.now
      proc.call
      "#{Time.now - start} sec."
    end
    p profile{ func(*arg) }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5306'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5306
  :user_name: szktty
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/648/
  :language: Other
  :time: 2008/01/13 16:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Mac OS X (PowerPC 32bit) アセンブリで。profile 関数は func と同じ引数を持つ、func
    専用の関数です。（表示するのは面倒だったので）実行時間をクロックカウントで返します。</p>\n<p>PowerPCはリアルタイムクロックをサポートせず、その代わりに64bit（32bitレジスタ2つ）のタイムベースレジスタというレジスタが用意されています。しかしタイムベースレジスタの精度はCPUの実装依存でして、正確な計測は保証されません。</p>\n<p>さらに、二つのレジスタの値を取り出す際に、下位32bitのレジスタ値の桁が繰り上がる場合があります。繰り上がった場合は状態レジスタ（MSR）のビットフラグが立ちますが、このレジスタにアクセスする命令が特権命令のため、通常のプログラムでは桁の繰り上がりを調べられません。というわけで桁の繰り上がりの考慮はあきらめています。</p>\n<p>使用例:</p>\n<pre
    class=\"literal-block\">\n#include &lt;stdio.h&gt;\n\nunsigned int profile(void
    (*fp)(int), int arg);\nvoid func(int n);\n\nvoid func(int n)\n{\n  /* 処理 */\n}\n\nint
    main()\n{\n  printf(\"time -- %u\\n\", profile(func, 3));\n  return 0;\n}\n</pre>\n\n\t"
  :code: |2
            .machine ppc
            .globl _profile

    ;; unsigned int profile(void (*fp)(int), int arg)

    ;; r3-&gt;r0: fp: 関数ポインタ
    ;; r4: int arg
    _profile:
            mr      r0, r3          ; ポインタを別のレジスタにコピー
            mr      r3, r4          ; 計測する関数の第一引数にする

            ;; レジスタをスタックに退避
            mftb    r4              ; タイムベースレジスタ
            stwu    r0, -4(r1)
            stwu    r3, -4(r1)
            stwu    r4, -4(r1)
            mflr    r12             ; リンクレジスタ
            stwu    r12, -4(r1)

            ;; 関数呼び出し
            mtctr   r0              ; カウントレジスタに関数ポインタをコピー
            bctrl

            ;; レジスタをスタックから復帰
            lwz     r12, 0(r1)
            mtlr    r12
            lwzu    r4, 4(r1)
            lwzu    r3, 4(r1)
            lwzu    r0, 4(r1)
            addi    r1, r1, 4

            ;; 実行時間を返す
            mftb    r3              ; 関数呼び出し後のタイムベースレジスタ
            sub     r3, r3, r4
            blr
  :tags:
  - Assembly
  - MacOSX
  - PowerPC
  :references:
    :url: /web/20100324085422/http://mput.dip.jp/mput/?date=20040314
    :title: 'mput の日記: PowerPC でもクロックカウント'
- :id: '5434'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5434
  :user_name: queck
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/681/
  :language: Other
  :time: 2008/01/23 14:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Factor  です。\nprofile という関数(ワード)がすでにあったので、prof という名前にしました。\ntime
    ワードで 1116 ms run / 6 ms GC time のように処理時間と GC にかかった時間が表示されます。</p>\n\n\t"
  :code: |
    USE: tools.time
    : prof [ func ] time ;
  :tags:
  - Factor
  :references:
    :url: 
    :title: 
- :id: '5668'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5668
  :user_name: silverwire
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/646/
  :language: Batchfile
  :time: 2008/02/03 12:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">バッチで書いてみました。(言わずもがなと思いますが、精度は期待しないでください。)\r\n\r\n現在時刻の取得にtimeコマンドを使用しています。timeコマンドの出力形式はロケールに\r\n依存するため、事前にコードページ番号を
    932(日本)にしておく必要があります。\r\n\r\nWindows XPで動作を確認。</pre>\n\t"
  :code: |
    @echo off
      setlocal
        set t1=0
        set t2=0

        call :time t1
        ping -n 3 127.0.0.1&gt;NUL
        call :time t2

        for /f "delims=" %%t in ('set /a "t2-t1"') do echo %%t (ms)
      endlocal
    goto :EOF

    :time
      set h=0
      set m=0
      set s=0
      set _=0
      set t=

      :: 標準出力を介して改行コードを渡すことで、timeコマンドを終了させる。
      for /f "tokens=2 delims= " %%t in ('echo.^|time') do set t=%%t

      ::  8進数として解釈されないよう 0を加算する。
      for /f "tokens=1,2 delims=." %%a in ('echo %t%') do (
        set t=%%a
        set _=%%b+0
      )

      for /f "tokens=1-3 delims=:" %%a in ('echo %t%') do (
        set /a h=%%a+0
        set /a m=%%b+0
        set /a s=%%c+0
      )

      set /a %1=%h%*3600000+%m%*60000+%s%*1000+%_%
    goto :EOF
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5881'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/5881
  :user_name: ocean
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2008/02/27 10:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>私も今知ったのですが、少なくとも Windows ではtime.time() は 1msec (CLOCKS_PER_SEC
    == 1000) 程度の精度しかないのに対し、time.clock() は QueryPerformanceCounter を使うのでもっと精度が高いみたいです。</p>\n<p>#
    今度から time.clock() を使おう。。。</p>\n\n\t"
  :code: |
    import time

    def func(sec):
        time.sleep(sec)

    def profile(*a, **kw):
        c1 = time.clock()
        func(*a, **kw)
        c2 = time.clock()
        print c2 - c1, "[sec]"

    profile(2.1)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6129'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/6129
  :user_name: Nemo
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/685/
  :language: PostScript
  :time: 2008/04/01 14:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#6128 をベースに少しいじりました。\r\n実際に使用するならば #6128 のほうが融通が効く気がします。\r\n\r\n\r\n</pre>\n\t"
  :code: "%!PS\n/TimerStart { % (Label) TimerStart -  \n    (Enter: ) print dup =\n
    \   currentdict /ProfilingTimer known not {\n        /ProfilingTimer  10 dict
    def\n    } if\n    ProfilingTimer exch 2 copy known {\n        get\n    } {\n
    \       [0 0] dup 4 1 roll put\n    } ifelse\n    1 usertime 1000 div put \n}
    bind def\n\n/TimerStop { % (Label) TimerStop -  \n    (Leave: ) print dup print
    ( : ) print\n    \n    currentdict /ProfilingTimer known {\n        ProfilingTimer
    exch 2 copy known\n        {\n            get\n            aload 3 1 roll\n            usertime
    1000 div sub neg\n            dup 10 string cvs print ( sec  Total =) print\n
    \           add\n            dup 10 string cvs print ( sec) =\n            0 exch
    put\n        } {\n            pop pop\n        } ifelse\n    } {\n        pop\n
    \   } ifelse\n} bind def\n\n/profile { % ...function arguments...  /Function  profile
    \ -\n    currentdict /ProfileFunction-temp known not {\n        /ProfileFunction-temp
    [] def\n    } if\n    dup \n    ProfileFunction-temp aload length 1 add dup 1
    add -1 roll exch\n    % /Func [F1 (Func)]\n    array astore /ProfileFunction-temp
    exch def\n    dup 100 string cvs TimerStart \n    cvx exec\n    ProfileFunction-temp
    aload length 1 sub exch\n    100 string cvs TimerStop\n    array astore /ProfileFunction-temp
    exch def\n} bind def\n% ----------------- Test Code ----------------\n\n/TestLoop2
    { % Count  TestLoop2 -\n    10000 mul {\n        1000 {\n        } repeat\n    }
    repeat\n} def \n\n/TestLoop { % - TestLoop -\n    0 1 5 {\n        /TestLoop2
    profile\n    } for\n} def\n\n/TestLoop profile\n"
  :tags: []
  :references:
    :url: /web/20100324085422/http://ja.doukaku.org/comment/6128/
    :title: 'メソッドのフック #6128'
- :id: '7197'
  :parent_id: '22'
  :url: http://ja.doukaku.org/comment/7197
  :user_name: genzou
  :user_url: /web/20100324085422/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/08/18 11:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>可変パラメータでも動くようにするには、どうしたらいいのでしょう？？\n誰かご存知ですか？</p>\n\n\t"
  :code: |
    def func = { x, y -&gt;
        (x..y).each{
            Thread.sleep(50 + (int)(50*Math.random()))
        }
    }

    def profile = { function, x, y -&gt;
        def start = java.util.Calendar.instance.timeInMillis
        function(x, y)
        println(java.util.Calendar.instance.timeInMillis - start)
    }


    def newFunc = profile.curry(func)
    newFunc( 200, 250 )
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
