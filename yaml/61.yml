---
:id: '61'
:title: 逆転したビット列
:comments:
- :id: '3417'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3417
  :user_name: herumi
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/564/
  :language: 
  :time: 2007/09/17 14:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\r\n\t  32以下の正の整数nが与えられた場合に、\r\n0以上、2のn乗未満の整数を「ビット的に逆転したもの」のリストを\r\n作成する関数を書いてください。\r\nなお「ビット的に逆転」とはnotを使った反転ではなく、\r\n「0001」を「1000」にするような処理を指すものとします。\r\n<p>\r\nn
    = 4の時には\r\n[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\r\nが正解です。\r\n</p>\n<p>\r\n問題の理解を促すために上のリストを2進数表記で表示してみます。\r\n</p>\n<pre>\r\n0000
    0\r\n1000 8\r\n0100 4\r\n1100 12\r\n0010 2\r\n1010 10\r\n0110 6\r\n1110 14\r\n0001
    1\r\n1001 9\r\n0101 5\r\n1101 13\r\n0011 3\r\n1011 11\r\n0111 7\r\n1111 15\r\n</pre>\r\n\r\nn
    = 8などの場合のリストは音声のFFT演算でよく使わているそうです。\r\nこの問題は光成さんの投稿を元にしています。\r\nご協力ありがとうございました。\r\n\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3037'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3037
  :user_name: ぱみ
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/420/
  :language: Ruby
  :time: 2007/09/17 15:20 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">こんな感じでどうでしょうか。</pre>\n\t"
  :code: |
    def reverse_list(n)
      ret = []
      0.upto(2 ** n - 1) do |i|
        str = "%0#{n}b" % i
        ret &lt;&lt; str.split(//).reverse.join.to_i(2)
      end
      ret
    end

    p reverse_list(4) #=&gt; [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3038'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3038
  :user_name: xsd
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/154/
  :language: OCaml
  :time: 2007/09/17 15:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">memoizeとか末尾最適化とかPervasivesで使えそうなものをみつくろうとか\r\n色々まだ残ってますが、とりあえず投稿。</pre>\n\t"
  :code: "let rec dup n = function\n    | []      -&gt; []\n    | x :: xs -&gt; x
    :: (x+n) :: (dup n xs)\n\nlet makerev n = \n    let rec makerev' = function\n
    \       | 1 -&gt; [0; 1]\n        | x -&gt; dup x (makerev' (x/2))\n    in makerev'
    (1 lsl (n-1))\n\n\n# makerev 4;;\n- : int list = [0; 8; 4; 12; 2; 10; 6; 14; 1;
    9; 5; 13; 3; 11; 7; 15]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3039'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3039
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/09/17 15:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  題意より、2の32乘個のリストまで表現する必要があるためLinkedListを使用しています（64bit環境でメモリを大量に積んでいないと現実的ではありませんが）。\n\t"
  :code: |
    import java.util.*;

    public class Sample {
        public static List&lt;Long&gt; reverseList(int n) {
            List&lt;Long&gt; a = new LinkedList&lt;Long&gt;();
            for (long i = 0; i &lt; (1L &lt;&lt; n); i++) {
                a.add(Long.reverse(i) &gt;&gt;&gt; (64 - n));
            }
            return a;
        }
        public static void main(String[] args) {
            System.out.println(reverseList(4));
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3040'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3040
  :user_name: ココサブ
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/24/
  :language: C
  :time: 2007/09/17 15:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">分割して逆転させています。</pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint
    reverse_bits(unsigned int number, int size)\n{\n    unsigned int low, high;\n\n
    \   if (size != 1) {\n        size &gt;&gt;= 1;\n        low    = number &amp;
    (int)(pow(2, size)-1);\n        high   = number &gt;&gt; size;\n        low    =
    reverse_bits(low, size);\n        high   = reverse_bits(high, size);\n        number
    = high | (low &lt;&lt; size);\n    }   \n\n    return number;\n}\n\nint main()\n{\n
    \   int i, n, two_n;\n    int *list;\n\n    printf(\"n : \");\n    scanf(\"%d\",
    &amp;n);\n    two_n = pow(2, n); \n    list  = malloc(sizeof(*list) * two_n);\n\n
    \   for (i = 0; i &lt; two_n; i++) {\n        list[i] = reverse_bits(i, n);\n
    \       printf(\"%d\\n\", list[i]);\n    }\n    \n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3041'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3041
  :user_name: ocean
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/09/17 15:38 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">泥臭く。</pre>\n\t"
  :code: |
    def iter_flipped(n):
        if not n &gt; 0:
            raise ValueError("should be positive: %d" % n)
        for src in xrange(1 &lt;&lt; n):
            dst = 0
            for i in xrange(n):
                dst &lt;&lt;= 1
                if src &amp; (1 &lt;&lt; i):
                    dst |= 1
            yield dst

    def list_flipped(n):
        return list(iter_flipped(n))

    if __name__ == '__main__':
        print list_flipped(4)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3042'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3042
  :user_name: nskj77
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/375/
  :language: Haskell
  :time: 2007/09/17 15:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">*Main&gt; exec 4\r\n[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]</pre>\n\t"
  :code: |
    import Data.List (elemIndices)

    tobinaries 0 = []
    tobinaries n = (iterate f ["0","1"]) !! (n - 1)
      where f xs = concatMap (\x -&gt;  map (x++) xs) ["0","1"]

    exec = map (sum . map (\x -&gt; 2 ^ x) . elemIndices '1') . tobinaries
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3043'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3043
  :user_name: yuin
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/09/17 16:05 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  \n<p>有名なアレですね。\n</p>\n\n\n\n\t"
  :code: |
    def bitReverse(n:int) = {
      val shift = 32 - n
      (0 to Math.pow(2, n).toInt-1).map{v =&gt;
        var x = v
        x = (((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1))
        x = (((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2))
        x = (((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4))
        x = (((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8))
        x = ((x &gt;&gt; 16) | (x &lt;&lt; 16))
        x &gt;&gt;&gt; shift
      }.toList
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3044'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3044
  :user_name: ココサブ
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/24/
  :language: 
  :time: 2007/09/17 16:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">これだとnが偶数じゃないと動かないか</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3045'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3045
  :user_name: vtwntmtn
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/380/
  :language: Python
  :time: 2007/09/17 16:35 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">無理やりワンライナに。\r\nn=4で動作を確認しました。</pre>\n\t"
  :code: |
    def reverse_list(n):
        return [sum([(((x &gt;&gt; i) &amp; 1) and (1 &lt;&lt; ((n - 1) - i))) for i in range(n)]) for x in xrange(1 &lt;&lt; n)]

    #print reverse_list(4)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3046'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3046
  :user_name: mc
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/405/
  :language: Common
  :time: 2007/09/17 16:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">すいません、真っ先に思い付いたのがこの方法でした^^;\r\nビット操作のものも考えてみたいと思います。\r\n\r\n(reverse-bit-list
    4) \r\n=&gt; (0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15)</pre>\n\t"
  :code: "(defun reverse-bit-list (n)\n  (mapcar (lambda (x) (reverse-bit x n))\n\t
    \ (loop for i below (expt n 2) collect i)))\n\n(defun reverse-bit (n lim)\n  (let
    ((format-string (sconc \"~\" (princ-to-string lim) \",'0,B\")))\n    (values \n
    \    (read-from-string \n      (sconc \"#b\" (reverse (format nil format-string
    n)))))))\n\n(defun sconc (&amp;rest strs)\n  (apply #'concatenate 'string strs))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3047'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3047
  :user_name: satooM
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/424/
  :language: Haskell
  :time: 2007/09/17 16:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  何の変哲もありませんが。\n\t"
  :code: |
    bitReverse n = map bitReverse' [0..2^n-1] where
      toBinary 0 = []
      toBinary k = let (d,m) = divMod k 2 in m:toBinary d

      bitReverse' = sum
                  . zipWith (*) [2^r | r &lt;- reverse [0..n-1]]
                  . toBinary
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3048'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3048
  :user_name: yuin
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/09/17 16:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n<p>まぁ標準でこの機能があるので普通書くならこっちですね。\n</p>\n\n\n\n\t"
  :code: |
    def bitReverse(n:int) = {
      (0 to Math.pow(2, n).toInt-1).map{v =&gt;
        Integer.reverse(v) &gt;&gt;&gt; (32 - n)
      }.toList
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3049'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3049
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Haskell
  :time: 2007/09/17 16:54 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">ハッカーのたのしみ(isbn:4434046683)に乗っている方法で書いてみました。\r\nシフト演算子(&gt;&gt;)や(&lt;&lt;)がMonad用に使われてしまっているのが、残念な所です。</pre>\n\t"
  :code: "import Data.Word\nimport Data.Bits\nimport Control.Applicative\n\nrevbit
    :: Int -&gt; [Word32]\nrevbit n = (flip shiftR (32-n)).revword &lt;$&gt; [0..(2^n
    - 1)] \n    where\n    revword = (\\x -&gt; shiftL (x .&amp;. 0x55555555) 1  .|.
    shiftR (x .&amp;. 0xAAAAAAAA) 1)\n            . (\\x -&gt; shiftL (x .&amp;. 0x33333333)
    2  .|. shiftR (x .&amp;. 0xCCCCCCCC) 2)\n            . (\\x -&gt; shiftL (x .&amp;.
    0x0F0F0F0F) 4  .|. shiftR (x .&amp;. 0xF0F0F0F0) 4)\n            . (\\x -&gt;
    shiftL (x .&amp;. 0x00FF00FF) 8  .|. shiftR (x .&amp;. 0xFF00FF00) 8)\n            .
    (\\x -&gt; shiftL x 16 .|. shiftR x 16)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3050'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3050
  :user_name: fkmn
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/190/
  :language: Perl
  :time: 2007/09/17 16:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">もっといいやり方がありそう</pre>\n\t"
  :code: |
    sub reverse_bin2dec {
        my ( $n, $len ) = @_;
        my $rev_bin = unpack( "b" . $len, pack( "C", $n ) );
        return eval "0b" . $rev_bin;
    }

    sub reverse_bit_num_list {
        my $n = shift;
        return map { reverse_bin2dec( $_, $n ) } 0 .. ( 2**$n - 1 );
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3051'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3051
  :user_name: sumim
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/09/17 17:18 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  Squeak Smalltalk で。\r<br><br>与えられた数値列と等価なビットパターンを持つ画像データについて左右入れ替え操作を行ない、変換後画像のビット列を取り出しています。\n\t"
  :code: |
    | flipBits |
    flipBits := [:numOfBits :vals |
        | form bits |
        form := Form extent: 32 @ vals size.
        form bits: (Bitmap newFrom: vals).
        bits := (form flipBy: #horizontal centerAt: 0@0) bits.
        bits asArray collect: [:each | each &gt;&gt; (32 - numOfBits)]].

    ^flipBits value: 4 value: (0 to: 15) "=&gt; #(0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15) "
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '3052'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3052
  :user_name: matyr
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/09/17 18:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t   アレなど使わず強引に変換するものと，おとなしく使うもの。速度差は優に数十倍。\r<br><br>javascript:(function(q,p){do{p=(function(n){for(var r=[],i=n=Math.pow(2,n);i--;)r[i]=parseInt((n+i).toString(2).slice(1).split('').reverse().join(''),2);return r})(q)}while(q=prompt('n = '+q+'\\n'+p,q))})(4)\n\t"
  :code: |
    function doukaku61(n){
      for(var r = [], i = n = Math.pow(2, Number(n)); i--;)
        r[i] = parseInt((n + i).toString(2).slice(1).split('').reverse().join(''), 2);
      return r;
    }

    function doukaku61_(n){
      for(var r = [], i = Math.pow(2, n = Number(n)), k = 32 - n; ~(n = --i);){
        n = (n &amp; 0xaaaaaaaa) &gt;&gt; 1 | (n &amp; 0x55555555) &lt;&lt; 1;
        n = (n &amp; 0xcccccccc) &gt;&gt; 2 | (n &amp; 0x33333333) &lt;&lt; 2;
        n = (n &amp; 0xf0f0f0f0) &gt;&gt; 4 | (n &amp; 0x0f0f0f0f) &lt;&lt; 4;
        n = (n &amp; 0xff00ff00) &gt;&gt; 8 | (n &amp; 0x00ff00ff) &lt;&lt; 8;
        n = n &gt;&gt; 16 | n &lt;&lt; 16;
        r[i] = n &gt;&gt;&gt; k;
      }
      return r;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3053'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3053
  :user_name: naoya_t
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/09/17 19:03 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">n=32まで対応することを考えると、（配列などに記憶せずに）１つずつ演算して吐き出していくのがよさそう。\r\nこれとは別に\r\nfunction
    gyakuten(n, i,j,cnt)\r\n{\r\n\tx[0] = 0\r\n\tcnt = 1\r\n\r\n\tfor (j=1; j&lt;=n;
    j++) {\r\n\t\tprintf(\"[%d]\\n\", j)\r\n\t\tfor (i=cnt-1; i&gt;=0; i--) {\r\n\t\t\tx[i*2]
    \  = x[i]\r\n\t\t\tx[i*2+1] = x[i] + cnt\r\n\t\t}\r\n\t\tcnt *= 2\r\n\t}\r\n\treturn
    cnt\r\n}\r\nのようなやり方も思いついたのだけれど、これは結果を配列に保持し、\r\n全てが出来るまで表示しないので n が大きいと結果が出るまでに長い沈黙があります。\r\n（n≦20ぐらいまでなら何とか使い物になるでしょう）\r\n%
    awk -f gyakuten.awk -v n=4\r\n[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11,
    7, 15]\r\n% awk -f gyakuten.awk -v n=8\r\n[0, 128, 64, 192, 32, ... ,127, 255]</pre>\n\t"
  :code: "BEGIN {\n\tif (n &lt; 1 || 32 &lt; n) {\n\t\tprint \"1≦n≦32 でよろしく\"\n\t\texit\n\t}\n\n\tprintf
    \"[\"\n\tcnt = 2 ** n\n\tfor (i=0; i&lt;cnt; i++) {\n\t\tx = i\n\t\ts = 0\n\t\tfor
    (j=0; j&lt;n; j++) {\n\t\t\ts *= 2\n\t\t\tif (x % 2 != 0) s++\n\t\t\tx = int(x/2)\n\t\t}\n\t\tif
    (i &gt; 0) printf \", \"\n\t\tprintf(\"%s\", s) # %dでも%uでも 2^31 以上が正しく表示されなかったので\n\t}\n\tprintf
    \"]\\n\"\n\texit\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3054'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3054
  :user_name: shiro
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/41/
  :language: Scheme
  :time: 2007/09/17 19:33 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  手元に「任意ビット長の整数のビット順を逆にするルーチン」があったので利用してみました。仕事で128bitまでの整数を比較的高速に逆順にする必要があって書いたものです (実はこれをお題投稿してみようかなとか考えてたんですが先越されちゃいましたね)。\r<br><br>今回は32bitまでとなってますが、n=32でeagerにリストを作るとメモリが大変なので、遅延ストリームを返すlazy版も作っときました。必要な分だけ計算できます。\r<br><br> gosh&gt; (stream-&gt;list (stream-take (reverse-stream 32) 16))\r<br> (0 2147483648 1073741824 3221225472 536870912 2684354560 1610612736 \r<br>  3758096384 268435456 2415919104 1342177280 3489660928 805306368 \r<br>  2952790016 1879048192 4026531840)\r<br><br>32bit越えても大丈夫。仕様外だけど。\r<br><br> gosh&gt; (stream-&gt;list (stream-take (reverse-stream 99) 10))\r<br> (0 316912650057057350374175801344 158456325028528675187087900672\r<br>  475368975085586025561263702016 79228162514264337593543950336\r<br>  396140812571321687967719751680 237684487542793012780631851008\r<br>  554597137599850363154807652352 39614081257132168796771975168\r<br>  356526731314189519170947776512)\r<br><br>"
  :code: |
    (use gauche.uvector)
    (use util.stream)

    ;; Eager版。nが大きいと破綻する
    (define (reverse-list bits)
      (list-ec (: n (expt 2 bits)) (reverse-bits n bits)))

    ;; Lazy版。
    (define (reverse-stream bits)
      (stream-map (cut reverse-bits &lt;&gt; bits) (stream-iota (expt 2 bits))))

    ;; 任意ビット長の整数の反転。速度を稼ぐためテーブル使用。
    (define (reverse-bits word bits)
      (define rev8
        '#u8(0 128 64 192 32 160 96 224 16 144 80 208 48 176 112 240 8
               136 72 200 40 168 104 232 24 152 88 216 56 184 120 248 4
               132 68 196 36 164 100 228 20 148 84 212 52 180 116 244 12
               140 76 204 44 172 108 236 28 156 92 220 60 188 124 252 2
               130 66 194 34 162 98 226 18 146 82 210 50 178 114 242 10
               138 74 202 42 170 106 234 26 154 90 218 58 186 122 250 6
               134 70 198 38 166 102 230 22 150 86 214 54 182 118 246 14
               142 78 206 46 174 110 238 30 158 94 222 62 190 126 254 1
               129 65 193 33 161 97 225 17 145 81 209 49 177 113 241 9
               137 73 201 41 169 105 233 25 153 89 217 57 185 121 249 5
               133 69 197 37 165 101 229 21 149 85 213 53 181 117 245 13
               141 77 205 45 173 109 237 29 157 93 221 61 189 125 253 3
               131 67 195 35 163 99 227 19 147 83 211 51 179 115 243 11
               139 75 203 43 171 107 235 27 155 91 219 59 187 123 251 7
               135 71 199 39 167 103 231 23 151 87 215 55 183 119 247 15
               143 79 207 47 175 111 239 31 159 95 223 63 191 127 255))
      (let loop ((bits bits)
                 (word word)
                 (revs '()))
        (if (&lt;= bits 0)
          (ash (fold (lambda (dig r) (+ dig (ash r 8))) 0 (reverse revs)) bits)
          (loop (- bits 8)
                (ash word -8)
                (cons (u8vector-ref rev8 (logand word #xff)) revs)))))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3055'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3055
  :user_name: kozima
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/09/17 23:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">なんとなく短縮してみました。</pre>\n\t"
  :code: |
    (defun reverse-bit-list (n)
      (loop for i below (expt n 2)
        collect (parse-integer (reverse (format nil "~V,'0,B" n i)) :radix 2)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3056'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3056
  :user_name: kozima
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/09/17 23:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">reverse -&gt; nreverse にした方がちょっと効率よかったですね。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3057'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3057
  :user_name: kozima
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/164/
  :language: 
  :time: 2007/09/17 23:46 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">何度もすみません。\r\nexpt の引数が逆みたいです。\r\nn=4 だと 2^4=4^2=16
    なので結果は正しいのですが。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3058'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3058
  :user_name: kozima
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2007/09/17 23:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">再帰。\r\n効率は思ったほどは悪くないようで。</pre>\n\t"
  :code: |
    (defun reverse-bit-list (n)
      (if (= n 1) (list 0 1)
        (let ((list (reverse-bit-list (1- n))))
          (append (mapcar (lambda (x) (* x 2)) list)
                  (mapcar (lambda (x) (1+ (* x 2))) list)))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3059'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3059
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/18 00:14 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">整数を与えられた基数の桁値のリストにする\r\ntoDigits とか その逆のfromDigits
    とかは\r\nほとんでidiomですねぇ。\r\n\r\nでもプレリュードにはないんですよねぇ。\r\n\r\n\r\n</pre>\n\t"
  :code: |
    bitrevs k = take (2^k) $ map (revbit k) [0..]
    bitrev  k = fromDigits 2 . reverse . toDigits k 2

    toDigits k base n
     = reverse $ map snd $ take k $ iterate ((`divMod` base) . fst) $ n `divMod` base
    fromDigits base ds
     = foldl ((+) . (base*)) 0 ds

    {-
    *Main&gt; bitrevs 4
    [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3060'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3060
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/18 00:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">toDigit でreverseしてから、またそのまま、reverse するのはちょっとねぇ。\r\nと思うプチブルの方にはここだけ展開改良したコードをどうぞ。
    :)</pre>\n\t"
  :code: |
    bitrevs k = take (2^k) $ map (bitrev k) [0..]
    bitrev  k = fromDigits . map snd . take k . iterate ((`divMod` 2) . fst) . (`divMod` 2)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3061'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3061
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/18 00:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Preludeのimport を明示して、(&gt;&gt;)をhiding すれば\r\n(&gt;&gt;)をシフト演算子として使えます。</pre>\n\t"
  :code: "import Data.Word\nimport Data.Bits\nimport Control.Applicative\nimport Prelude
    hiding ((&gt;&gt;))\n\n(&gt;&gt;),(&lt;&lt;) :: Bits a =&gt; a -&gt; Int -&gt;
    a\n(&gt;&gt;) = shiftR\n(&lt;&lt;) = shiftL\n\nrevbit :: Int -&gt; [Word32]\nrevbit
    n = (flip shiftR (32-n)).revword &lt;$&gt; [0..(2^n - 1)] \n    where\n    revword
    = (\\x -&gt; (x .&amp;. 0x55555555) &lt;&lt;  1 .|. (x .&amp;. 0xAAAAAAAA) &gt;&gt;
    \ 1)\n            . (\\x -&gt; (x .&amp;. 0x33333333) &lt;&lt;  2 .|. (x .&amp;.
    0xCCCCCCCC) &gt;&gt;  2)\n            . (\\x -&gt; (x .&amp;. 0x0F0F0F0F) &lt;&lt;
    \ 4 .|. (x .&amp;. 0xF0F0F0F0) &gt;&gt;  4)\n            . (\\x -&gt; (x .&amp;.
    0x00FF00FF) &lt;&lt;  8 .|. (x .&amp;. 0xFF00FF00) &gt;&gt;  8)\n            .
    (\\x -&gt; x &lt;&lt; 16 .|. x &gt;&gt; 16)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3062'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3062
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: 
  :time: 2007/09/18 00:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">おっと一箇所わすれた。\r\nrevbit n = (&gt;&gt; (32-n)).revword
    &lt;$&gt; [0..(2^n - 1)] </pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3064'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3064
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/18 01:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Control.Applicative は使わずに(といいつつ、starlingなぞを定義してますが。。。)\r\nrevword
    の定義に \\x -&gt; がならんでいるのはちょっとあれなので。。。</pre>\n\t"
  :code: "import Data.Word\nimport Data.Bits\nimport Prelude hiding ((&gt;&gt;))\n\nstarling
    :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)\nstarling f g x = (f
    x) (g x)\n\n(&gt;&gt;),(&lt;&lt;) :: Bits a =&gt; a -&gt; Int -&gt; a\n(&gt;&gt;)
    = shiftR\n(&lt;&lt;) = shiftL\n\nrevbit :: Int -&gt; [Word32]\nrevbit n = map
    ((&gt;&gt; (32-n)) . revword) [0..(2^n - 1)] \n\nrevword \n = starling ((.|.)
    . (&lt;&lt;  1) . (.&amp;. 0x55555555)) ((&gt;&gt;  1) . (.&amp;. 0xAAAAAAAA))\n
    . starling ((.|.) . (&lt;&lt;  2) . (.&amp;. 0x33333333)) ((&gt;&gt;  2) . (.&amp;.
    0xCCCCCCCC))\n . starling ((.|.) . (&lt;&lt;  4) . (.&amp;. 0x0F0F0F0F)) ((&gt;&gt;
    \ 4) . (.&amp;. 0xF0F0F0F0))\n . starling ((.|.) . (&lt;&lt;  8) . (.&amp;. 0x00FF00FF))
    ((&gt;&gt;  8) . (.&amp;. 0xFF00FF00))\n . starling ((.|.) . (&lt;&lt; 16)) ((&gt;&gt;
    16))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3065'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3065
  :user_name: nobsun
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/09/18 03:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Control.Applicative をつかってさらにリファクタリング\r\n</pre>\n\t"
  :code: "import Control.Applicative\nimport Data.Word\nimport Data.Bits\nimport Prelude
    hiding ((&gt;&gt;))\n\n(&gt;&gt;),(&lt;&lt;) :: Bits a =&gt; a -&gt; Int -&gt;
    a\n(&gt;&gt;) = shiftR\n(&lt;&lt;) = shiftL\n\nrevbit :: Int -&gt; [Word32]\nrevbit
    n = (&gt;&gt; (32-n)) . revword &lt;$&gt; [0..(2^n - 1)] \n\nrevword :: Word32
    -&gt; Word32\nrevword = foldr (.) id $ map step [0..4]\n\nstep :: Int -&gt; Word32
    -&gt; Word32\nstep i = (.|.) . (&lt;&lt; i2) . (.&amp;. pat) &lt;*&gt; (&gt;&gt;
    i2) . (.&amp;. complement pat)\n  where i2 = 2^i\n        pat = pats !! i\n\npats
    :: [Word32]\npats = [0x55555555,0x33333333,0x0f0f0f0f,0x00ff00ff,0x0000ffff]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3066'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3066
  :user_name: jz5
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/344/
  :language: VB
  :time: 2007/09/18 03:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">BitArrayが微妙に使いにくいですね。</pre>\n\t"
  :code: |
    Function GetReversedBit(ByVal n As Integer) As List(Of UInteger)
        Dim list As New List(Of UInteger)
        For i As UInteger = 0 To CUInt(2 ^ n - 1)
            Dim bitAry As New BitArray(BitConverter.GetBytes(i))
            Dim revAry As New BitArray(bitAry.Count)
            For j As Integer = 0 To n - 1
                revAry(j) = bitAry(n - 1 - j)
            Next
            Dim b(n - 1) As Byte
            revAry.CopyTo(b, 0)
            list.Add(BitConverter.ToUInt32(b, 0))
            If i = UInteger.MaxValue Then Exit For
        Next
        Return list
    End Function
  :tags:
  - VB8.0
  :references:
    :url: 
    :title: 
- :id: '3067'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3067
  :user_name: ocean
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/177/
  :language: C
  :time: 2007/09/18 04:42 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  C++のstd::bitsetを使って。ただし、nはコンパイル時に解決されるので、動的に指定することはできない。また、std::bitset#to_stringまわりでコンパイラによって色々違いがあるみたいで、結構苦労した。（特にg++）\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    #include &lt;bitset&gt;

    #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1200) // VC++6 メンバテンプレートが使えない
    # define to_string(bs) bs.to_string()
    #elif defined(__GNUC__) // g++ のバグ？ http://ml.tietew.jp/cppll/cppll/thread_articles/8828 で回避
    # define to_string(bs) bs.template to_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;()
    #else // 一般的にはこちら
    # define to_string(bs) bs.to_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;()
    #endif

    template &lt;size_t n&gt;
    std::vector&lt;unsigned long&gt; list_flipped()
    {
        std::vector&lt;unsigned long&gt; v(size_t(1) &lt;&lt; n);

        for (size_t i = 0; i &lt; v.size(); ++i)
        {
            std::string s = to_string(std::bitset&lt;n&gt;(i));

            std::reverse(s.begin(), s.end());

            v[i] = std::bitset&lt;n&gt;(s).to_ulong();
        }

        return v;
    }

    int main()
    {
        std::vector&lt;unsigned long&gt; v = list_flipped&lt;4&gt;();

        std::copy(v.begin(), v.end(), std::ostream_iterator&lt;unsigned long&gt;(std::cout, " "));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3068'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3068
  :user_name: はやみず
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/440/
  :language: Scheme
  :time: 2007/09/18 08:55 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  論理演算(ash, logand) はR5RSにはないようです。Gaucheには組み込み関数として用意されています。\n\t"
  :code: "(define (bit-inversed-list n)\n  (define (inverse-num width num)\n    (let
    loop((ret 0) (num num) (width width))\n      (if (= 0 width)\n\t  ret\n\t  (loop
    (+ (* ret 2) (logand num 1))\n\t\t(remainder (ash num -1) (expt 2 width))\n\t\t(-
    width 1)))))\n  (let loop((ret ()) (num (- (expt 2 n) 1)))\n    (if (&lt; num
    0)\n\tret\n\t(loop (cons (inverse-num n num) ret)\n\t      (- num 1)))))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3073'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3073
  :user_name: mc
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/405/
  :language: 
  :time: 2007/09/18 17:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">すいません。元になった自分のプログラムが間違ってました^^;\r\nformatの\"~V\"は便利ですね。とても勉強になりました!</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3074'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3074
  :user_name: kkobayashi
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/09/18 18:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Rのビット列演算は文字との変換を目的としているようで、バイト単位の扱いしかできないという癖があります。\r\n（32bit
    = 1byte * 4 として扱う）\r\n\r\n&gt; reverse.bits.list(4)\r\n [1]  0  8  4 12  2 10
    \ 6 14  1  9  5 13  3 11  7 15\r\n</pre>\n\t"
  :code: |
    reverse.bits.list &lt;- function(n){
        sapply(0:(2**n-1), function(x)
               as.integer(packBits(c(rev(head(intToBits(as.integer(x)), n)), raw(32-n)))) %*% (256**c(0:3)))
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3075'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3075
  :user_name: yohei
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/415/
  :language: C
  :time: 2007/09/18 21:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">n &lt;= 30まで（メモリが足りれば動くはず）。</pre>\n\t"
  :code: |
    using System;
    class Program {
        static int[] reverse_list(int n) {
            int[] list = new int[1 &lt;&lt; n];
            int k = 1;
            list[0] = 0;
            for (int on = 1 &lt;&lt; (n - 1); on &gt; 0; on &gt;&gt;= 1) {
                for (int i = 0; i &lt; k; i++)
                    list[k + i] = list[i] | on;
                k &lt;&lt;= 1;
            }
            return list;
        }
        static void Main(string[] args) {
            foreach (int i in reverse_list(4))
                Console.WriteLine(i);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3076'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3076
  :user_name: shiro
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/41/
  :language: 
  :time: 2007/09/18 21:57 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  整数のビット演算に関してはR5RS実装の間では、 (ash, logand, logior...) 系統と (arithmetic-shift, bitwise-and, bitwise-ior, ...) 系統で分かれていました。一度srfiが提出されたんですがwithdrawnになりました。というのは、ビット演算を定義するためには数値の内部表現を露にせざるを得ず、Schemeの数値モデルとの抽象化の差が問題になったからです。\r<br><br>r6rsではライブラリにbitwise-arithmetic-shift, bitwise-and, bitwise-ior,...が入りました。\"bitwise-arithmetic-shift\" はちょっと名前が長すぎると思うんですが…\r<br><br>"
  :code: ''
  :tags: []
  :references:
    :url: /web/20090610213337/http://practical-scheme.net/wiliki/schemexref.cgi?bitwise-ior
    :title: bitwise-ior
- :id: '3077'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3077
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/09/19 02:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    def f(n, debug=False):
      r = []
      for i in range(2**n):
        b = ''.join([i &amp; (1 &lt;&lt; j) and '1' or '0' for j in range(n)])
        if debug:
          print '%s %d' % (b, int(b, 2))
        r.append(int(b, 2))
      return r

    print f(4, True)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3107'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3107
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Scheme
  :time: 2007/09/19 14:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">あれ？string-&gt;numberが強調されません。R5RSだと思いますが。</pre>\n\t"
  :code: |
    (use srfi-13)
    (define (rev n i) (string-&gt;number (string-reverse (string-pad (number-&gt;string i 2) n #\0)) 2))
    (dotimes (i 16) (print (rev 4 i)))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '3111'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3111
  :user_name: nori
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/59/
  :language: Python
  :time: 2007/09/19 14:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">妙なこだわりのコード。</pre>\n\t"
  :code: "def succ(i, n, r=None):\n  assert(i &gt; -1)\n  assert(n &gt; 0)\n  if n
    == 1:\n    if i == 0:\n      v = 1\n      c = False\n      mod = 0\n    else:\n
    \     v = 0\n      c = True\n      mod = 1\n  else:\n    mod = i%2\n    div =
    i/2\n    s, c = succ(div, n-1, True)\n    if ( mod == 1 or c ) and not ( c and
    mod ==1 ):\n      v = s*2 + 1\n    else:\n      v = s*2\n  if r is None:\n    return
    v\n  else:\n    return (v, c and mod == 1)\n  \ndef reversedbits(n):\n  x = 0\n
    \ for i in range(0, 2**n):\n    yield x\n    x = succ(x, n)\n\ndef gen(n):\n  return
    list(reversedbits(n))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3119'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3119
  :user_name: TGBT
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/167/
  :language: Other
  :time: 2007/09/19 19:50 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">CUDAを用いて実装。\r\nCUDA特有の二段階並列実行による超並列処理（？）をやろうと思ったけど、振り分けがめんどくさい（いっそテーブルを作るのが吉なんだが）ので適当に投稿。\r\n\r\nメモリ最適化とか投げまくり。</pre>\n\t"
  :code: |
    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;math.h&gt;
    #include &lt;unistd.h&gt;

    #include &lt;cutil.h&gt;

    // GPUの処理（blockを利用した並列処理）
    __global__ void gpu(int *answer, int n)
    {
      int k;
      int id = blockIdx.x;
      int ans = 0;
      for(k=0; k&lt;n; k++){
        ans &lt;&lt;= 1;
        ans += answer[id]&amp;1;
        answer[id] &gt;&gt;= 1;
      }
      answer[id] = ans;
    }

    // 関数呼び出し
    int reverse_bit(int n)
    {
      int i;
      int nn;
      CUT_DEVICE_INIT();

      nn = (int)pow(2.0f, (float)n);

      int *h_mem;
      int *d_mem;
      CUDA_SAFE_CALL(cudaMallocHost((void**)&amp;h_mem, sizeof(int)*nn));
      CUDA_SAFE_CALL(cudaMalloc((void**)&amp;d_mem, sizeof(int)*nn));
      for(i=0; i&lt;nn; i++){
        h_mem[i] = i;
      }

      CUDA_SAFE_CALL(cudaMemcpy(d_mem, h_mem, sizeof(int)*nn, cudaMemcpyHostToDevice));
      dim3 threads(1, 1, 1);
      dim3 grid(nn,1,1);
      gpu&lt;&lt;&lt; grid, threads &gt;&gt;&gt;(d_mem, n);
      CUDA_SAFE_CALL( cudaThreadSynchronize() );
      CUT_CHECK_ERROR("Kernel execution failed");
      CUDA_SAFE_CALL(cudaMemcpy(h_mem, d_mem, sizeof(int)*nn, cudaMemcpyDeviceToHost));

      // 回答表示
      for(i=0; i&lt;nn; i++){
        printf(" %d", h_mem[i]);
      }
      printf("\n");

      CUDA_SAFE_CALL(cudaFree(d_mem));
      CUDA_SAFE_CALL(cudaFreeHost(h_mem));
      return 0;
    }

    int main(int argc, char** argv)
    {
      if(argc!=2){
        printf("args: %s n\n", argv[0]);
        return -1;
      }
      int n = atoi(argv[1]);
      reverse_bit(n);
      return 0;
    }
  :tags:
  - CUDA
  :references:
    :url: 
    :title: 
- :id: '3122'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3122
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: PHP
  :time: 2007/09/20 07:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">迂闊に32bitを指定したら大変な事に。</pre>\n\t"
  :code: "&lt;?php\nfunction reversebit($n) {\n\t$max = pow(2,$n);\n\t$len = strlen(decbin($max
    - 1));\n\tfor ( $i = 0; $i &lt; $max; $i++ ) {\n\t\t$rtn[] = bindec(strrev(str_pad(decbin($i),$len,\"0\",STR_PAD_LEFT)));\n\t}\n\treturn
    $rtn;\n}\n\nprint_r(reversebit(4));\n?&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3191'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3191
  :user_name: naranja
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/448/
  :language: D
  :time: 2007/09/28 12:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">単純な方法。</pre>\n\t"
  :code: |
    import std.stdio;
    import std.string;

    uint[] reversedBitsList(int n){
        uint[] retList;
        for(uint i = 0; i &lt; (1L &lt;&lt; n); i++){
            uint toUintRadix2(string s){
                uint ret;
                foreach(index, digit; s){
                    ret += (digit - '0') * (1 &lt;&lt; (s.length - index - 1));
                }
                return ret;
            }
            retList ~= toUintRadix2(format("%0*b", n, i).reverse);
        }
        return retList;
    }

    void main(){
        writefln(reversedBitsList(4));  //=&gt; [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3201'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3201
  :user_name: niha
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/160/
  :language: Ruby
  :time: 2007/09/30 16:28 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">適当</pre>\n\t"
  :code: |
    def f n
    (0...2&lt;&lt;~-n).map{|x|("%0#{n}b"%x).reverse.to_i 2}end
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3315'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3315
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2007/10/13 10:58 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    bitReverseLists = map snd $ iterate f (1, [0]) where
      f (m, xs) = (2*m, xs &gt;&gt;= (\x -&gt; [x, x+m]))

    {-
    *Main&gt; bitReverseLists !! 4
    [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3316'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3316
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/304/
  :language: 
  :time: 2007/10/13 11:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">投稿した後に気づいたのですが #3038 の xsdさんのと同じ漸化式（関係？）使ってました。\r\niterate使って書いたとこが
    Haskellらしいかと。\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3587'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3587
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2007/10/30 06:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">&gt; foo(4)\r\n [1]  0  8  4 12  2 10  6 14
    \ 1  9  5 13  3 11  7 15\r\n</pre>\n\t"
  :code: |
    foo &lt;- function(n) {
        x &lt;- numeric(n)
        sapply (0:(2^n-1), function(i) {
        for (j in 1:n) {
            x[j] &lt;- i%%2
            i &lt;- i%/%2
        }
        sum(x*2^((n-1):0))
        })
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3588'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3588
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: R
  :time: 2007/10/30 06:38 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">&gt; foo(4)\r\n [1]  0  8  4 12  2 10  6 14
    \ 1  9  5 13  3 11  7 15\r\n</pre>\n\t"
  :code: |
    foo &lt;- function(n) {
        x &lt;- numeric(n)
        sapply (0:(2^n-1), function(i) {
        for (j in 1:n) {
            x[j] &lt;- i%%2
            i &lt;- i%/%2
        }
        sum(x*2^((n-1):0))
        })
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3633'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3633
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: awk
  :time: 2007/10/31 14:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">スクリプト中の変数 n に値を送り込むのは，-v オプションで，以下のようにする\r\n\r\nawk
    -f p3417.awk -v n=3\r\n0\r\n4\r\n2\r\n6\r\n1\r\n5\r\n3\r\n7\r\n</pre>\n\t"
  :code: |
    BEGIN {
        for (i = 0; i &lt; 2^n; i++) {
            print foo(n, i)
        }
    }

    function foo(n, i,     sum, j, x) {
        sum = 0
        for (j = 0; j &lt; n; j++) {
            x = i%2
            i = int(i/2)
            sum += x*2^(n-j-1)
        }
        return sum
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3678'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3678
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Scheme
  :time: 2007/11/02 20:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    (define (reverse-bits-list n)
      (let loop ((i 0)
                 (ret '(0)))
        (if (= i n)
          ret
          (let* ((even-lst (map (cut * 2 &lt;&gt;) ret))
                 (odd-lst (map (cut + 1 &lt;&gt;) even-lst)))
            (loop (+ i 1) (append even-lst odd-lst))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3683'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3683
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/11/03 01:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">数値をビットの文字列に変換する方法を応用して作りました。</pre>\n\t"
  :code: |
    #include &lt;stdio.h&gt;

    unsigned int reverse_bit(unsigned int n, int bit_size)
    {
        unsigned int result = 0, lsb;

        while (n) {
            lsb = n &amp; 1;
            result += lsb &lt;&lt; (bit_size - 1);
            n &gt;&gt;= 1;
            bit_size--;
        }

        return result;
    }

    void reverse_bit_list(int input)
    {
        unsigned int i, size;

        size = 1 &lt;&lt; input;

        for (i = 0; i &lt; size; i++) {
            printf("%u\n", reverse_bit(i, input));
        }
    }

    int main(void)
    {
        int input;

        printf("n = ");
        scanf("%d", &amp;input);

        if (!(input &lt;= 32)) {
            fprintf(stderr, "Error!\n");
            return (-1);
        }

        reverse_bit_list(input);

        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3702'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3702
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/11/04 14:53 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>reverse 関数で「ビット的に逆転した値を求める処理」を行っています。問題文に「32以下の正の整数n」とあったので、n&lt;=32
    を前提として作成しました。\r</p>\n<p>\r</p>\n<p>reverse 関数の内部 (return 以外の部分) では以下の処理を行っています：\r</p>\n<p>\r</p>\n<ol>\n<li>\n
    x の上位 16-bit と下位 16-bit を交換する。\r\n</li>\n<li>\n それぞれの 16-bit 値について、上位 8-bit と下位8-bit
    を交換する。\r\n</li>\n<li>\n それぞれの 8-bit 値について、上位 4-bit と下位 4-bit を交換する。\r\n</li>\n<li>\n
    それぞれの 4-bit 値について、上位 2-bit と下位 2-bit を交換する。\r\n</li>\n<li> それぞれの 2-bit 値について、上位
    1-bit と下位 1-bit を交換する。\r</li>\n</ol>\n<p>\r</p>\n<p>これによって、32-bit 値の x が「ビット的に反転」されます。\r</p>\n<p>最後の
    return の行では、x の上位 n-bit が下位 n-bit の位置に来るように移動しています。\r</p>\n</div>\n\t"
  :code: |
    #include &lt;cmath&gt;
    #include &lt;iostream&gt;

    // 32-bit 符号無し整数.
    typedef unsigned int uint32;

    // x の下位 n ビットを反転する.
    // Ex. x=3 (2進数で0011), n=4 の場合の戻り値は 12 (2進数で1100).
    uint32 reverse(uint32 x, uint32 n)
    {
        x = ((x &lt;&lt; 16 &amp; 0xFFFF0000)) | ((x &gt;&gt; 16) &amp; 0x0000FFFF);
        x = ((x &lt;&lt;  8 &amp; 0xFF00FF00)) | ((x &gt;&gt;  8) &amp; 0x00FF00FF);
        x = ((x &lt;&lt;  4 &amp; 0xF0F0F0F0)) | ((x &gt;&gt;  4) &amp; 0x0F0F0F0F);
        x = ((x &lt;&lt;  2 &amp; 0xCCCCCCCC)) | ((x &gt;&gt;  2) &amp; 0x33333333);
        x = ((x &lt;&lt;  1 &amp; 0xAAAAAAAA)) | ((x &gt;&gt;  1) &amp; 0x55555555);

        return x &gt;&gt; (32 - n);
    }

    void generate(uint32 n)
    {
        const char *delimiter = "";

        for(uint32 x = 0; x &lt; std::pow(2, n); x++)
        {
            std::cout &lt;&lt; delimiter;
            std::cout &lt;&lt; reverse(x, n);
            delimiter = ", ";
        }
        std::cout &lt;&lt; std::endl;
    }

    int main()
    {
        generate(4);
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3705'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3705
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/11/04 22:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>すみません。reverse 関数の中で括弧の付け方を間違えていました（優先順位を明示するためにつけたので、動作には問題ありませんが・・）。</p>\n</div>\n\t"
  :code: |
    // x の下位 n ビットを反転する.
    // Ex. x=3 (2進数で0011), n=4 の場合の戻り値は 12 (2進数で1100).
    uint32 reverse(uint32 x, uint32 n)
    {
        x = ((x &lt;&lt; 16) &amp; 0xFFFF0000) | ((x &gt;&gt; 16) &amp; 0x0000FFFF);
        x = ((x &lt;&lt;  8) &amp; 0xFF00FF00) | ((x &gt;&gt;  8) &amp; 0x00FF00FF);
        x = ((x &lt;&lt;  4) &amp; 0xF0F0F0F0) | ((x &gt;&gt;  4) &amp; 0x0F0F0F0F);
        x = ((x &lt;&lt;  2) &amp; 0xCCCCCCCC) | ((x &gt;&gt;  2) &amp; 0x33333333);
        x = ((x &lt;&lt;  1) &amp; 0xAAAAAAAA) | ((x &gt;&gt;  1) &amp; 0x55555555);

        return x &gt;&gt; (32 - n);
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3872'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3872
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/11/11 17:24 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  泥臭いですが\n\t"
  :code: |
    表示(reverse_list(4))
    ●reverse_list(n)
    　　sとは整数;bとは文字列;rとは整数;lとは配列
    　　もし(n&gt;32)ならば;戻("")
    　　sを0から((2^n)-1)まで繰り返す
    　　　　b="";もし(s=0)ならば;b="0";違えば;(s&lt;&gt;0)間;b=b&amp;(s%2);s=INT(s/2)
    　　　　(n-文字数(b))回;b=b&amp;"0"
    　　　　r=0;文字列分解(b)で反復;r=r+(対象*2^(文字数(b)-回数))
    　　　　l=l&amp;r&amp;改行
    　　戻(l)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3880'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/3880
  :user_name: dankogai
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/26/
  :language: Perl
  :time: 2007/11/11 23:04 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">黒魔術一つ入りマース\r\nDan the One-Liner Monger</pre>\n\t"
  :code: |
    % perl -le '$b=shift;for(0..2**$b-1){print eval("0b".reverse substr(unpack("B32",pack"N",$_),32-$b,$b))}' 4
    0
    8
    4
    12
    2
    10
    6
    14
    1
    9
    5
    13
    3
    11
    7
    15
  :tags:
  - oneliner
  :references:
    :url: 
    :title: 
- :id: '4497'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/4497
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: Bash
  :time: 2007/11/30 06:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>シェルで配列を扱う練習のために書いてみました。</p>\n\n\t"
  :code: |
    #!/bin/bash

    declare -a result
    declare -i rsize

    rev_list_inner(){
      local n i s
      n=$1
      i=$2
      s=$3
      if [[ $n -eq 0 ]]; then
        result[$((rsize++))]=$s
      else
        rev_list_inner $(($n-1)) $(($i*2)) $s
        rev_list_inner $(($n-1)) $(($i*2)) $(($i+$s))
      fi
    }

    rev_list(){
      local n
      n=$1
      rsize=0
      result=()
      rev_list_inner $n 1 0
    }

    # test
    rev_list 4
    echo ${result[@]}
    rev_list 10
    echo ${result[@]}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4755'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/4755
  :user_name: pooq
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2007/12/11 13:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">2^n個の要素のリストを作ってしまうので,\r\n大きなnは無理だと思いましたが、要素の数だけ\r\n返すようにしてやってみるとこんな具合でした。\r\n\r\n
    \  rev_bit 4\r\n0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15\r\n\r\n   #rev_bit 20\r\n1048576\r\n\r\n
    \  #rev_bit 22\r\n4194304\r\n\r\n   #rev_bit 24\r\n|out of memory: rev_bit\r\n|
    \  #.|.\"1    #:i.2^y\r\n</pre>\n\t"
  :code: |
    rev_bit=.3 :'#.|."1#:i.2^y'
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4847'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/4847
  :user_name: vtwntmtn
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/380/
  :language: Erlang
  :time: 2007/12/16 15:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">色々整理してるうちにこうなってしまった…見づらいですね。\r\n\r\n1&gt; c(reverse_bits).\r\n{ok,reverse_bits}\r\n2&gt;
    reverse_bits:reverse_bits(4).\r\n[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]\r\n</pre>\n\t"
  :code: |
    -module(reverse_bits).
    -import(lists, [map/2, seq/2, sum/1, zip/2]).
    -export([reverse_bits/1]).

    reverse_bits(Col) -&gt; [sum(map(fun({A, B}) -&gt; A bsl B end, zip(X, seq(0, length(X) - 1)))) || X &lt;- [[(Y bsr (Col - X)) rem 2 || X &lt;- seq(1, Col)] || Y &lt;- seq(0, (1 bsl Col) - 1)]].
  :tags:
  - ErlangOTP_R10B-10
  :references:
    :url: 
    :title: 
- :id: '5268'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/5268
  :user_name: susu
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/218/
  :language: OCaml
  :time: 2008/01/12 01:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>List.initはExtLibにあります。自作も簡単ですが。</p>\n\n\t"
  :code: "(*がんばった版*)\nlet rec rev  res w n =\n  if w&lt;1 then res else\n  rev ((res
    lsl 1) lor (n land 1)) (w-1) (n lsr 1);;\n  \nlet make n = Array.init (1 lsl n)
    (rev 0 n);;\n\n\n(*まねっこ版*)\nopen Int32;;\nlet rev32 width n =\n  let f x m1 m2
    b =\n    logor\n      (shift_right_logical (logand x m1)  b)\n      (shift_left
    (logand x m2) b) in\n  \n  let x = (f(f(f(f n\n    0xAAAAAAAAl 0x55555555l  1)\n
    \   0xCCCCCCCCl 0x33333333l  2)\n    0xF0F0F0F0l 0x0F0F0F0Fl  4)\n    0xFF00FF00l
    0x00FF00FFl  8) in\n    \n  shift_right_logical\n    (logor\n      (shift_right_logical
    x 16)\n      (shift_left x 16) )\n    (Sys.word_size-width);;\n    \nlet make32
    n =\n  Array.init (1 lsl n) (fun i -&gt; rev32 n (Int32.of_int i));;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5284'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/5284
  :user_name: szktty
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/648/
  :language: Other
  :time: 2008/01/12 16:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Mac OS X (PowerPC 32bit) アセンブリで。</p>\n\n\t"
  :code: "        .machine ppc\n        .globl _reverse_bits\n\n;; void reverse_bits(unsigned
    int *result, unsigned int n);\n\nMASK1 = 0xaaaaaaaa\nMASK2 = 0x55555555\nMASK3
    = 0xcccccccc\nMASK4 = 0x33333333\nMASK5 = 0xf0f0f0f0\nMASK6 = 0x0f0f0f0f\nMASK7
    = 0xff00ff00\nMASK8 = 0x00ff00ff\n\n;; r3: ビットを逆転した数値を入れる配列\n;; r4: 32以下の正の整数
    n\n;; r5: n の二乗\n;; r6: カウント\n;; r7: ビットを逆転させる数\n;; r8-10: ビット演算の作業用\n;; r11-:
    ビットマスク\n_reverse_bits:\n        mullw   r5, r4, r4      ; n2 = n * n;\n        li
    \     r6, 0           ; i = 0;\n        lis     r11, hi16(MASK1)\n        addi
    \   r11, r11, lo16(MASK1)\n        lis     r12, hi16(MASK2)\n        addi    r12,
    r12, lo16(MASK2)\n        lis     r13, hi16(MASK3)\n        addi    r13, r13,
    lo16(MASK3)\n        lis     r14, hi16(MASK4)\n        addi    r14, r14, lo16(MASK4)\n
    \       lis     r15, hi16(MASK5)\n        addi    r15, r15, lo16(MASK5)\n        lis
    \    r16, hi16(MASK6)\n        addi    r16, r16, lo16(MASK6)\n        lis     r17,
    hi16(MASK7)\n        addi    r17, r17, lo16(MASK7)\n        lis     r18, hi16(MASK8)\n
    \       addi    r18, r18, lo16(MASK8)\n\n        \nloop:\n        mr      r7,
    r6          ; x = i;\n\n        ;; x = (x &amp; 0xaaaaaaaa) &gt;&gt; 1 | (x &amp;
    0x55555555) &lt;&lt; 1;\n        and     r8, r7, r11\n        srwi    r8, r8,
    1\n        and     r9, r7, r12\n        slwi    r9, r9, 1\n        or      r10,
    r8, r9\n\n        ;; x = (x &amp; 0xcccccccc) &gt;&gt; 2 | (x &amp; 0x33333333)
    &lt;&lt; 2;\n        and     r8, r10, r13\n        srwi    r8, r8, 2\n        and
    \    r9, r10, r14\n        slwi    r9, r9, 2\n        or      r10, r8, r9\n\n
    \       ;; x = (x &amp; 0xf0f0f0f0) &gt;&gt; 4 | (x &amp; 0x0f0f0f0f) &lt;&lt;
    4;\n        and     r8, r10, r15\n        srwi    r8, r8, 4\n        and     r9,
    r10, r16\n        slwi    r9, r9, 4\n        or      r10, r8, r9\n\n        ;;
    x = (x &amp; 0xff00ff00) &gt;&gt; 8 | (x &amp; 0x00ff00ff) &lt;&lt; 8;\n        and
    \    r8, r10, r17\n        srwi    r8, r8, 8\n        and     r9, r10, r18\n        slwi
    \   r9, r9, 8\n        or      r10, r8, r9\n\n        ;; x = x &gt;&gt; 16 | x
    &lt;&lt; 16;\n        srwi    r8, r10, 16\n        slwi    r9, r10, 16\n        or
    \     r10, r8, r9\n\n        ;; x = x &gt;&gt; (32 - n)\n        li      r8, 32\n
    \       sub     r9, r8, r4\n        srw     r10, r10, r9\n        \n        ;;
    結果を代入\n        stw     r10, 0(r3)      ; *result = x;\n        addi    r3, r3,
    4       ; result++;\n        \n        ;; 繰り返し\n        addi    r6, r6, 1       ;
    i++;\n        cmpl    cr7, r5, r6     ; n2 &gt; i\n        bgt     cr7, loop\n\n
    \       ;; 終了\n        li      r3, 0           ; return 0;\n        blr\n"
  :tags:
  - Assembly
  - MacOSX
  - PowerPC
  :references:
    :url: 
    :title: 
- :id: '6149'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6149
  :user_name: horiuchi
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/570/
  :language: Other
  :time: 2008/04/07 08:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  4 REV_BITS_LIST で n=4の場合が実行できます。\n\t"
  :code: |
    : REV_BITS ( n size -- m , m is reverse bits of n )
    0 -ROT
    BEGIN
      OVER 0 &gt;
    WHILE
      1 - OVER 1 AND
      OVER LSHIFT -ROT
      2SWAP + -ROT
      SWAP 1 RSHIFT SWAP
    REPEAT
    2DROP ;

    : REV_BITS_LIST ( n -- , the reverse bits number list 0 to 2^n-1 )
    1 OVER LSHIFT 0  DO I OVER REV_BITS . LOOP ;
  :tags:
  - Forth
  :references:
    :url: 
    :title: 
- :id: '6150'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6150
  :user_name: JDO
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/257/
  :language: Perl
  :time: 2008/04/07 12:49 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">おなじみの再帰でかきましたぁ～\r\n\r\n2進法の数字列を文字の列のパターンとして考えたみたんだ。\r\n
    ようは左側の文字列の右側にもうひとつ文字をくっつけるってことだね。\r\n\r\nたとえば、N=1 なら\r\n\r\n0\r\n1\r\n\r\nだけど、N=2
    なら、この N=1 の結果に対して、\r\n右側に 0 をつけたバージョンと、\r\n右側に 1 をつけたバージョンを\r\nつくって、つなげたものってことになる。\r\n\r\n00\r\n10\r\n\r\n01\r\n11\r\n\r\nN
    がどんな数でも N-1 のときの結果の右側に 0 をつけたバージョンと\r\n1 をつけたバージョン をつくって、つなげるだけでいい。\r\n\r\nただし、文字列として
    0 を\"つける\" とか 1 を \"つける\" っていうのは、\r\n数でいえば 左側の数字を1桁繰り上げるたものに 0 を \"たす\" とか\r\n1
    を \"たす\" っていうことなんだ。\"つける\" ⇔ \"たす\" ってこと。\r\n左側の数が $g だったら、$g*2 + 0 とか $g*2 +
    1 っていうことになるんだ。</pre>\n\t"
  :code: |
    sub generate
      {
      return (0) if $_[0] ==0 ; # 数 0 ひとつだけのリスト。これが種になるんだ。

      my (@gs) = &amp;generate ($_[0] - 1) ; #  左側の数字を先につくる

      my (@r) = () ;
      foreach my $g (@gs) {push (@r, $g*2 + 0) ;} # 右側に 0 をつけたバージョン
      foreach my $g (@gs) {push (@r, $g*2 + 1) ;} # 右側に 1 をつけたバージョン
      return @r ;
      }

    my (@gs) = &amp;generate (4) ;

    foreach my $g (@gs) {print "$g\n" ;}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6151'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6151
  :user_name: JDO
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/257/
  :language: XSLT
  :time: 2008/04/07 13:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Perl で書いたやつを XSLT にしましたぁ～\r\nってか、ほんとは XSLT
    で最初から書きたかったから、 \r\nPerl はプロトタイプとしてかいただけなんだけどね...\r\n\r\nPerl バージョンを読んでない人のために、説明文もそのまま流用しまぁ～す\r\n\r\n──────────────────────────────\r\n\r\n2進法の数字列を文字の列のパターンとして考えたみたんだ。\r\n
    ようは左側の文字列の右側にもうひとつ文字をくっつけるってことだね。\r\n\r\nたとえば、N=1 なら\r\n\r\n0\r\n1\r\n\r\nだけど、N=2
    なら、この N=1 の結果に対して、\r\n右側に 0 をつけたバージョンと、\r\n右側に 1 をつけたバージョンを\r\nつくって、つなげたものってことになる。\r\n\r\n00\r\n10\r\n\r\n01\r\n11\r\n\r\nN
    がどんな数でも N-1 のときの結果の右側に 0 をつけたバージョンと\r\n1 をつけたバージョン をつくって、つなげるだけでいい。\r\n\r\nただし、文字列として
    0 を\"つける\" とか 1 を \"つける\" っていうのは、\r\n数でいえば 左側の数字を1桁繰り上げるたものに 0 を \"たす\" とか\r\n1
    を \"たす\" っていうことなんだ。\"つける\" ⇔ \"たす\" ってこと。\r\n左側の数が number (.) だったら、number (.)
    * 2 + 0 とか\r\nnumber (.) * 2 + 1 っていうことになるんだ。</pre>\n\t"
  :code: |
    &lt;?xml version="1.0" encoding="Shift_JIS" ?&gt;
    &lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

    &lt;xsl:template match="/"&gt;
      &lt;xsl:call-template name="generate"&gt;
        &lt;xsl:with-param name="column" select="4" /&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template name="generate"&gt;
      &lt;xsl:param name="column" /&gt;

      &lt;xsl:choose&gt;
        &lt;!-- 数 0 ひとつだけのリスト。これが種になるんだ。 --&gt;
        &lt;!-- リストのタグ名はなんでもいいので、HTML の ol と li を使うことにした --&gt;
        &lt;xsl:when test="$column = 0"&gt;
          &lt;ol&gt;&lt;li&gt;0&lt;/li&gt;&lt;/ol&gt;
        &lt;/xsl:when&gt;

        &lt;xsl:otherwise&gt;
          &lt;!-- 左側の数字を先につくる --&gt;
          &lt;xsl:variable name="gse"&gt;
            &lt;xsl:call-template name="generate"&gt;
              &lt;xsl:with-param name="column" select="$column - 1" /&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:variable&gt;
          &lt;xsl:variable name="gs" select="$gse" /&gt;

          &lt;ol&gt;
            &lt;!-- 右側に 0 をつけたバージョン --&gt;
            &lt;xsl:for-each select="$gs/ol/li/text ()"&gt;
              &lt;li&gt;&lt;xsl:value-of select="number (.) * 2 + 0" /&gt;&lt;/li&gt;
            &lt;/xsl:for-each&gt;

            &lt;!-- 右側に 1 をつけたバージョン --&gt;
            &lt;xsl:for-each select="$gs/ol/li/text ()"&gt;
              &lt;li&gt;&lt;xsl:value-of select="number (.) * 2 + 1" /&gt;&lt;/li&gt;
            &lt;/xsl:for-each&gt;
          &lt;/ol&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6152'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6152
  :user_name: JDO
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/257/
  :language: Java
  :time: 2008/04/07 15:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ビットの反転操作を 2つのスタック間の ビットの移動 というふうに考えてみたんだ。\r\n「ハノイの塔」
    をご存知でしょうか。\"ビット移動\" のイメージはあんなかんじなんだ。\r\n\r\n右と左の 2つのスタックがある。\r\n左は空で、右には3ビットのビット列がある。たとえば、それが
    001 がだったとする。\r\n\r\n　　　　　　　　　0\r\n　　　　　　　　　0\r\n　　　　　　　　　1\r\n　　　─────────\r\n　　　　左　　　　右\r\n\r\nこれを
    1 ビットずつ 右のスタックから左のスタックに移しかえるんだ。\r\n\r\n★移動1回目\r\n\r\n　　　　　　　　　0\r\n　　　　0 　　　　1\r\n　　　─────────\r\n　　　　左　　　　右\r\n\r\n★移動2回目\r\n\r\n　　　　0\r\n　　　　0
    　　　　1\r\n　　　─────────\r\n　　　　左　　　　右\r\n\r\n★移動3回目\r\n\r\n　　　　1\r\n　　　　0\r\n　　　　0\r\n　　　─────────\r\n　　　　左　　　　右\r\n\r\n3
    ビットだから、3回移動すれば終わり。\r\n\r\nこれを 0,1,2,...,7 のそれぞれですれば、ほしい数列ができるってわけさ。\r\n\r\n整数型
    の変数で 単純にやればいいだけなんだけど、この考え方を強調する意味で、\r\nオブジェクトとして定義してみたんだ。それが BitStack さ。だもんで Java
    になった。\r\n大げさに見えるかもねぇ。</pre>\n\t"
  :code: |
    class BitStack
      {
      private long bits = 0 ;

      BitStack (long bits)
        {this.bits = bits ;}

      void push (int bit)
        {this.bits = (this.bits &lt;&lt; 1) + bit ;}

      int pop ()
        {
        int bit = (int) (this.bits &amp; 1L) ;
        this.bits = (this.bits &gt;&gt;&gt; 1) ;
        return bit ;
        }

      long getValue ()
        {return this.bits ;}
      }


    public class Main
      {
      static int N = 4 ;

      public static void main (String [] args)
        {
        long max = (1 &lt;&lt; N) ;

        for (long 右値=0; 右値&lt;max; ++右値)
          {
          BitStack 右スタック = new BitStack (右値) ;
          BitStack 左スタック = new BitStack (0) ;

          for (int i=0; i&lt;N; ++i)
            { 左スタック .push (右スタック .pop ()) ;}

          long 左値 = 左スタック .getValue () ;

          System.out .println (左値) ;
          }
        }
      }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6159'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6159
  :user_name: cappuccino
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/549/
  :language: C
  :time: 2008/04/09 02:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>シフト演算を使わずに書いてみました。</p>\n\n\t"
  :code: "class Program\n{\n    static void Main(string[] args)\n    {\n        ReverseBitOrder(4).ForEach(Console.WriteLine);\n
    \   }\n\n    static List&lt;uint&gt; ReverseBitOrder(int bit)\n    {\n        List&lt;uint&gt;
    reverseList = new List&lt;uint&gt;();\n        uint[] table =\n        { 0x00000001,
    0x00000002, 0x00000004, 0x00000008,\n          0x00000010, 0x00000020, 0x00000040,
    0x00000080, \n          0x00000100, 0x00000200, 0x00000400, 0x00000800, \n          0x00001000,
    0x00002000, 0x00004000, 0x00008000, \n          0x00010000, 0x00020000, 0x00040000,
    0x00080000, \n          0x00100000, 0x00200000, 0x00400000, 0x00800000, \n          0x01000000,
    0x02000000, 0x04000000, 0x08000000, \n          0x10000000, 0x20000000, 0x40000000,
    0x80000000};\n\n        for (int num = 0; num &lt; Math.Pow(2, bit); num++)\n
    \       {\n            uint x = 0;\n\n            for (int i = 0; i &lt; bit;
    i++)\n            {\n                if ((num &amp; table[i]) != 0)\n                {\n
    \                   x |= table[(bit - 1) - i];\n                }\n            }\n
    \           reverseList.Add(x);\n        }\n\n        return reverseList;\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6535'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6535
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2008/06/18 03:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>1から32まで全部やると結構時間かかりますが・・・</p>\n\n\t"
  :code: |2
            public static void 逆転したビット列()
            {
                foreach (var n in Enumerable.Range(1, 32))
                {
                    Console.WriteLine("value:{0}", n);
                    foreach (var s in Enumerable.Range(0, (int)Math.Pow(2, n)).Select(x =&gt; new string(Convert.ToString(x, 2).PadLeft(n, '0').Reverse().ToArray())))
                    {
                        Console.WriteLine("{0} {1}", s, Convert.ToInt32(s, 2));
                    }
                }

            }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '6536'
  :parent_id: '61'
  :url: http://ja.doukaku.org/comment/6536
  :user_name: 匿名
  :user_url: /web/20090610213337/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2008/06/18 08:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>intでは駄目でした。\nlongでないと・・・。</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
