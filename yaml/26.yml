---
:id: '26'
:title: 議席数をドント方式で
:comments:
- :id: '3382'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/3382
  :user_name: cats
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/172/
  :language: 
  :time: 2007/07/20 13:51 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\r\n\t  定数(議席の総数)と各政党の得票数のリストが与えられた時に、各政党の議席数をドント方式で計算するコードを書いてください。\r\n<a
    href=\"/web/20100421170215/http://www.google.co.jp/search?q=%e3%83%89%e3%83%b3%e3%83%88%e6%96%b9%e5%bc%8f\">ドント方式についてGoogleで検索</a>。\r\n<p>\r\n例えば、定数が100で、4つの党の得票数がそれぞれ123,
    4, 56, 78の場合、\r\n</p>\n<pre>\r\n int 定数 = 100;\r\n int[] 得票数 = { 123, 4, 56, 78
    };\r\n</pre>\r\n配分すべき議席数は下のようになります。\r\n<pre>\r\n 48, 1, 21, 30\r\n</pre>\r\nこのお題はcatsさんの投稿を元に作成しました。ご投稿ありがとうございます。\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1169'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1169
  :user_name: morchin
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/78/
  :language: Python
  :time: 2007/07/20 14:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  素直に書いてみました…。\n\t"
  :code: "from __future__ import division\n\ndef haibun(seki, hyou):\n\tL = []\n\tfor
    w in range(1, seki+1):\n\t\tfor i, h in enumerate(hyou):\n\t\t\tL.append((h/w,
    i))\n\tL.sort(reverse=True)\n\tL = L[:100]\n\tres = [0] * len(hyou)\n\tfor v in
    L:\n\t\tres[v[1]] += 1\n\treturn res\n\t\nprint haibun(100, [123, 4, 56, 78])\n#
    [48, 1, 21, 30]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1170'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1170
  :user_name: sumim
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/20 14:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Squeak Smalltalk で。\n\t"
  :code: |
    | 政党名 獲得票数 割った数 定数 議席 |
    定数 := 100.
    政党名 := #(A党 B党 C党 D党).
    獲得票数 := #(123 4 56 78).
    割った数 := OrderedCollection new.
    (1 to: 獲得票数 max / (獲得票数 min / (定数 / 獲得票数 size))) do: [:割る数 |
       割った数 addAll: (獲得票数 / 割る数 with: 政党名 collect: [:票 :名 | 票 -&gt; 名])].
    議席 := 割った数 asSortedArray last: 定数.
    ^(議席 collect: [:assoc | assoc value]) asBag sortedElements asArray

    "=&gt; {#A党-&gt;48 . #B党-&gt;1 . #C党-&gt;21 . #D党-&gt;30}"
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '1173'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1173
  :user_name: 匿名
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/07/20 15:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ちょうど定数人目で比較する値が一緒になったら\r\nどうするんだろう。\r\n</pre>\n\t"
  :code: |
    l = [123,4,56,78]
    n = 100
    a = [0] * len(l)
    b = list(l)
    i = 1
    while i &lt;= n:
     idx = b.index(max(b))
     a[idx] += 1
     b[idx] = l[idx] / (a[idx] + 1.0)
     i += 1
    print a
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1174'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1174
  :user_name: cats
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/172/
  :language: C
  :time: 2007/07/20 15:32 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    using System;
    class Program
    {
      static void Main()
      {
        int 定数 = 100;
        int[] 得票数 = { 123, 4, 56, 78 };
        foreach (int i in ドント方式(定数, 得票数)) Console.WriteLine(i);
      }
      static int[] ドント方式(int 定数, int[] 得票数)
      {
        int[] d = new int[得票数.Length];
        while (--定数 &gt;= 0)
        {
          int k = -1;
          double m = double.MinValue;
          for (int i = 0; i &lt; d.Length; ++i)
          {
            double v = 得票数[i] / (d[i] + 1.0);
            if (v &gt; m) { m = v; k = i; }
          }
          ++d[k];
        }
        return d;
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1175'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1175
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Ruby
  :time: 2007/07/20 15:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Array#flattenにflattenするレベルを指定できればな…</pre>\n\t"
  :code: |
    require 'enumerator'
    def dont(n, v)
      ret = Array.new(v.length) { 0 }
      v.enum_for(:each_with_index).map do |vv, i|
        (1..n).map{|j| [vv.to_f/j, i] }
      end.inject([]){|a,b| a+b}.sort[-n..-1].each do |_, a|
        ret[a] += 1
      end
      ret
    end
    dont(100, [123, 4, 56, 78])     # =&gt; [48, 1, 21, 30]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1177'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1177
  :user_name: nori
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/59/
  :language: Python
  :time: 2007/07/20 15:58 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  SQL向きな問題に見えます。あとでチャレンジする予定。\n\t"
  :code: |
    """
    &gt;&gt;&gt; dont(1, [1])
    [1]
    &gt;&gt;&gt; dont(8, [1000, 700, 600, 280])
    [3, 2, 2, 1]
    &gt;&gt;&gt; dont(7, [3000, 1800, 1440])
    [4, 2, 1]
    &gt;&gt;&gt; dont(5, [7000, 3000, 2500])
    [3, 1, 1]
    &gt;&gt;&gt; dont(100, [123, 4, 56, 78])
    [48, 1, 21, 30]
    &gt;&gt;&gt; dont(2, [300, 300, 300])
    [1, 1, 0]
    """

    def dont(seats, votes=[]):
      assert(seats &gt; 0)
      assert(votes)
      assert(isinstance(votes[0], int))
      rs = [[0,None]]
      for d in range(seats):
        for j, v in enumerate(votes):
          x = v * 1.0/(d+1)
          for i, pair in enumerate(rs): # find right place to insert
            if x &gt; pair[0]:
              rs.insert(i, list([x, j]))
              break
      r = [0] * len(votes)
      for i in range(seats):
        r[rs[i][1]] +=1
      return r

    import doctest
    doctest.testmod()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1178'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1178
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/20 16:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  RubyのEnumerable#each_with_indexに相当するものってなんだろうね…\n\t"
  :code: |
    (defun mapcan-with-index (func list)
      (let ((i -1))
        (mapcan (lambda (x)
                  (incf i)
                  (funcall func x i))
                list)))

    (defun dont (n v)
      (let ((ret (make-array (length v) :initial-element 0)))
        (loop for (_ . a) in
             (last (sort (mapcan-with-index
                          (lambda (vv i) (loop for j from 1 to n collect (cons (/ vv j) i)))
                          v) #'&lt;
                         :key #'car)
                   n)
           do
             (incf (elt ret a)))
        ret))

    (dont 100 '(123 4 56 78))               ; =&gt; #(48 1 21 30)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1179'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1179
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Java
  :time: 2007/07/20 16:03 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  Java です。 リンクリストで実装しました。リンクリストの要素追加メソッド add には、並べ替えの機能がついています。順に追加していって、出力
    print メソッド呼びだすだけ。考え方自体は単純。\n\t"
  :code: |
    class DHondt
      {
      String 政党名 ; double 得票数 ; // ← これ、データ。
      DHondt next ; // ← リンクリスト構造です。

      DHondt (String 政党名, double 得票数)
        {this.政党名 = 政党名 ; this.得票数 = 得票数;}

      // add は 並べ替え機能つきの 要素の追加機能です。
      void add (DHondt another)
        {
        if (next==null) {next = another ;}
        else if (another.得票数 &lt; next.得票数) {next .add (another) ;}
        else {another.next = next ; next = another ;}
        }

      // 得票順に定数分だけ print します。
      void print (int 定数)
        {
        if (0 &lt; 定数)
          {
          System.out .println (政党名+" ("+得票数+")")  ;
          if (next!=null) next .print (定数 - 1) ;
          }
        }

      // お試しコード
      public static void main (String [] _)
        {
        String [] 政党名 = {"A党", "B党", "C党", "D党"} ;
        int [] 得票数 = {123, 4, 56, 78} ;

        int 定数 = 10 ;
        int 党数 = 4 ;
        int 割り算する回数 = (int) Math.ceil ((double) 定数 / 党数) ;

        DHondt dummy = new DHondt ("", 0) ;

        for (int i=0; i&lt;党数; ++i)
          for (int j=1; j&lt;=割り算する回数; ++j)
            dummy .add
               (new DHondt (政党名[i], (double) 得票数 [i] / j)) ;

        dummy.next .print (定数) ;
        }
      }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1180'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1180
  :user_name: ココサブ
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/24/
  :language: C
  :time: 2007/07/20 16:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "#include &lt;stdio.h&gt;\n\n#define VOTE_NUM 4\n\ntypedef struct {\n    int
    \   original;   /* 元の投票数 */ \n    int    divided;    /* 割る数     */\n    double
    value;      /* 割った数   */\n    int    parliament; /* 議席数     */\n} calc_data;\n\nint
    main()\n{\n    int       constant        = 100;              /* 定数 */\n    int
    \      votes[VOTE_NUM] = {123, 4, 56, 78}; /* 投票数 */\n    calc_data datas[VOTE_NUM];\n
    \   int       i, j;\n    int       max_index;\n\n    /* 初期化 */\n    for (i = 0;
    i &lt; VOTE_NUM; i++) {\n        datas[i].original   = votes[i];\n        datas[i].divided
    \   = 1;\n        datas[i].value      = votes[i];\n        datas[i].parliament
    = 0;\n    }\n\n    for (i = 0; i &lt; constant; i++) {\n        /* 大きい値を探す */\n
    \       max_index = 0;\n        for (j = 1; j &lt; VOTE_NUM; j++) {\n            if
    (datas[max_index].value &lt; datas[j].value) {\n                max_index = j;\n
    \           }\n        }\n\n        /* 更新 */\n        datas[max_index].parliament++;\n
    \       datas[max_index].divided++;\n        datas[max_index].value =  (double)datas[max_index].original\n
    \                               / datas[max_index].divided;\n    }\n\n    /* 結果の表示
    */\n    for (i = 0; i &lt; VOTE_NUM; i++) {\n        printf(\"%d\\n\", datas[i].parliament);\n
    \   }\n\n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1181'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1181
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/20 16:15 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  loopでできるじゃん。retとincfは取り除けないものかな…\n\t"
  :code: |
    (defun dont (n v)
      (let ((ret (make-array (length v) :initial-element 0)))
        (loop for (_ . a) in
             (last (sort (loop for vv in v
                               for i from 0
                            nconcing
                              (loop for j from 1 to n collect (cons (/ vv j) i)))
                         #'&lt; :key #'car)
                   n)
           do
             (incf (elt ret a)))
        ret))
    (dont 100 '(123 4 56 78))               ; =&gt; #(48 1 21 30)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1182'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1182
  :user_name: sukesam
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/204/
  :language: JavaScript
  :time: 2007/07/20 16:22 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  素直に実装してみました。\r\nどうやったらスマートにかけるんでしょうか？\n\t"
  :code: |
    alert((function execute(seki, hyo) {
            var r = [0, 0, 0, 0];
            for (var i = 0; i &lt; seki; i++) {
                    var index = 0;
                    for (var max = 0, j = 0; j &lt; hyo.length; j++) {
                            var e = hyo[j] / (r[j] + 1);
                            if (max &lt; e) {
                                    max = e;
                                    index = j;
                            }
                    }
                    r[index]++;
            }
            return r;
    })(100, [123,4,56,78]));
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1183'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1183
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Scheme
  :time: 2007/07/20 16:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  SLIMEがgaucheに使えれば…\r\n\r\n*-ecってCommon Lispのloopみたいなやつだね。\r\n\n\t"
  :code: |
    (use gauche.array)
    (use srfi-42)
    (use srfi-1)
    (define (dont n v)
      (define ret (make-array (shape 0 (length v)) 0))
      (do-ec (: pair
                (take (sort (append-ec
                             (: vv (index i) v)
                             (list-ec (: j 1 n) (cons (/ vv j) i)))
                            (lambda (a b) (&gt; (car a) (car b))))
                      n))
             (let ((a (cdr pair)))
               (array-set! ret a (+ 1 (array-ref ret a)))))
      (array-&gt;list ret))
    (print (dont 100 '(123 4 56 78)))       ; =&gt; (48 1 21 30)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1184'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1184
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Java
  :time: 2007/07/20 16:47 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  すみません、出題の意図の読み間違えと、バグ修正です。\n\t"
  :code: |
    import java.util.Hashtable ;

    class DHondt
      {
      String 政党名 ; double 得票数 ; // ← これ、データ。
      DHondt next ; // ← リンクリスト構造です。

      DHondt (String 政党名, double 得票数)
        {this.政党名 = 政党名 ; this.得票数 = 得票数;}

      // add は 並べ替え機能つきの 要素の追加機能です。
      void add (DHondt another)
        {
        if (next==null) {next = another ;}
        else if (another.得票数 &lt; next.得票数) {next .add (another) ;}
        else {another.next = next ; next = another ;}
        }


      int 議席数 (int 定数, String 政党名)
        {
        if (0 &lt; 定数)
          {return (this.政党名 .equals (政党名) ? 1 : 0)
                + (next==null ? 0 : next.議席数 (定数-1, 政党名)) ;}
        return 0 ;
        }

      // お試しコード
      public static void main (String [] _)
        {
        String [] 政党名 = {"A党", "B党", "C党", "D党"} ;
        int [] 得票数 = {123, 4, 56, 78} ;

        int 定数 = 100 ;
        int 党数 = 4 ;

        DHondt dummy = new DHondt ("", 0) ;

        for (int i=0; i&lt;党数; ++i)
          for (int j=1; j&lt;=定数; ++j)
            dummy .add
               (new DHondt (政党名[i], (double) 得票数 [i] / j)) ;

        for (int i=0; i&lt;党数; ++i)
          System.out .println
            (政党名[i] + "=&gt;" + dummy.next.議席数 (定数, 政党名[i])) ;
        }
      }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1186'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1186
  :user_name: anekos
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/170/
  :language: Haskell
  :time: 2007/07/20 16:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "import Data.List\nimport Ratio\n\ndhondt hyosu limit = [1 .. length hyosu]
    &gt;&gt;= (return . count table')\n    where table                           =
    do d &lt;- [1..limit] \n                                               map (\\(i,
    h) -&gt;  (i, h % d)) (zip [1..] hyosu)\n          table'                          =
    take limit $ sortBy comp $ table\n          comp (_, h1) (_, h2)            =
    compare h2 h1 \n          count []           v            = 0\n          count
    ((x,_):xs) v | x == v     = 1 + count xs v\n                             | otherwise
    \ = 0 + count xs v\n\n\nmain = print $ dhondt [123, 4, 56, 78] 100\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1187'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1187
  :user_name: fkmn
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/190/
  :language: SQL
  :time: 2007/07/20 16:59 GMT
  :vote_count: '5'
  :vote_score: '5'
  :body: "\n\t  MySQL限定。議席数が1000を越えると対応できません・・・\n\t"
  :code: "DROP TABLE IF EXISTS digits;\nCREATE TABLE digits(n INTEGER);\nINSERT INTO
    digits\nVALUES(0), (1), (2), (3), (4),\n(5), (6), (7), (8), (9);\n\nDROP TABLE
    IF EXISTS seats;\nCREATE TABLE seats(n INTEGER);\nINSERT INTO seats VALUES(100);\n\nDROP
    TABLE IF EXISTS votes;\nCREATE TABLE votes(vote integer);\nINSERT INTO votes VALUES(123),
    (4), (56), (78);\n\nDROP TABLE IF EXISTS divisors;\nCREATE TABLE divisors AS\nSELECT
    a.n + (b.n * 10) + (c.n * 100) + 1 AS divisor \n  FROM digits a, digits b, digits
    c;\n\nSET @r = 0;\nSELECT vote, COUNT(*) AS gained_seats\n  FROM ( SELECT v.vote,
    v.vote / d.divisor AS point, (@r := @r + 1) AS row\n           FROM votes v, divisors
    d\n       ORDER BY point DESC ) s\n WHERE row &lt;= (SELECT MAX(n) FROM seats)\nGROUP
    BY vote;\n"
  :tags:
  - MySQL
  :references:
    :url: 
    :title: 
- :id: '1188'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1188
  :user_name: yuin
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/20 17:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">とりあえず普通に。</pre>\n\t"
  :code: "import scala.collection.mutable.ListBuffer\nimport scala.util.Sorting\n\ndef
    dont(total:int, votes:Array[int]):Array[int] = {\n  val seats = Array.make(votes.length,
    0)\n  val sorted = (1 to total).foldLeft(new ListBuffer[(double,int)]) { (r, i)
    =&gt; \n    (0 to votes.size-1).foreach(j =&gt; r += (votes(j).toDouble/i, j));r\n
    \ }.toArray\n  Sorting.stableSort(sorted)\n  sorted.reverse.slice(0,100).foreach(x
    =&gt; seats(x._2) = seats(x._2) + 1)\n  seats\n}\n\ndont(100, Array(123, 4, 56,
    78))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1189'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1189
  :user_name: yuin
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/20 17:18 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">すみません、1行ミスってました。</pre>\n\t"
  :code: "import scala.collection.mutable.ListBuffer\nimport scala.util.Sorting\n\ndef
    dont(total:int, votes:Array[int]):Array[int] = {\n  val seats = Array.make(votes.length,
    0)\n  val sorted = (1 to total).foldLeft(new ListBuffer[(double,int)]) { (r, i)
    =&gt; \n    (0 to votes.size-1).foreach(j =&gt; r += (votes(j).toDouble/i, j));r\n
    \ }.toArray\n  Sorting.stableSort(sorted)\n  sorted.reverse.slice(0,total).foreach(x
    =&gt; seats(x._2) = seats(x._2) + 1)\n  seats\n}\n\ndont(10, Array(15000, 8000,
    6500, 2500, 1000, 500)).foreach(println(_))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1191'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1191
  :user_name: ytakenaka
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/35/
  :language: Common
  :time: 2007/07/20 17:48 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">素直にやる事は多くの人がやってるのでひねくれた方法をする。ずばりソートを使わなくても出来る方法。\r\nhttp://homepage2.nifty.com/PAF00305/math/apportionment/node4.html\r\n\r\nこちらの最後に書かれている２次元平面を考えて得票数と定数の関係が合うようなkを探すという事をやっています。\r\n\r\n初期値のkは最大得票政党の得票値で定数議席になるものの半分にしています。</pre>\n\t"
  :code: "; http://homepage2.nifty.com/PAF00305/math/apportionment/node4.html\n\n(defun
    calc-seats (k votes)\n  (floor (* k votes)))\n\n(defun total-seats (k list)\n
    \ (mapcar #'(lambda (x)(calc-seats k x)) list))\n\n(defun find-k (k delta-t c-seats
    list)\n  (let* ((seats (total-seats k list))\n\t (t-seats (apply #'+ seats)))\n
    \   (cond\n      ((equal t-seats c-seats)\n       seats)\n      ((&lt; t-seats
    c-seats)\n       (find-k (+ k delta-t) (/ delta-t 2) c-seats list))\n      (t\n
    \      (find-k (- k delta-t) (/ delta-t 2) c-seats list)))))\n       \n(defun
    max-votes (list)\n  (apply #'max list))\n\n(defun dont (list c-seats)\n  (find-k\n
    \  (/ (* (max-votes list) c-seats) 2) (/ (* (max-votes list) c-seats) 2)\n   c-seats
    list))\n\n; CL-USER&gt; (dont '(123 4 56 78) 100)\n; (48 1 21 30)\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1192'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1192
  :user_name: ytakenaka
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/35/
  :language: Common
  :time: 2007/07/20 17:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  訂正\n\t"
  :code: "(defun dont (list c-seats)\n  (let* ((init-delta-t (* (max-votes list) c-seats))\n\t
    (init-k (/ init-delta-t 2)))\n    (find-k init-k init-delta-t c-seats list)))\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1193'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1193
  :user_name: nkmrtks
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/155/
  :language: Common
  :time: 2007/07/20 18:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">投票数から求まる値が他と同値になった時の処理とか考えてません:p\r\n(dont 100
    '(123 4 56 78))\r\n =&gt; (48 1 21 30)</pre>\n\t"
  :code: |
    (defun dont (seats votes)
      (if (and (integerp seats) (listp votes))
          (let ((acc (mapcar #'(lambda (x) (cons x 1)) votes))
                (s seats))
            (loop
              (let ((m (apply #'max (mapcar #'(lambda (c) (/ (car c) (cdr c))) acc))))
                (setq acc
                      (mapcar #'(lambda (c)
                                  (if (= m (/ (car c) (cdr c)))
                                      (prog1
                                          (cons (car c) (1+ (cdr c)))
                                        (decf s))
                                    c))
                              acc))
                (if (&lt;= s 0) (return (mapcar #'1- (mapcar #'cdr acc)))))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1194'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1194
  :user_name: nkmrtks
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/155/
  :language: 
  :time: 2007/07/20 18:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">説明補足\r\nやってることは、\r\n１．まず、全ての党の獲得座席数を０とする\r\n２．投票数/(獲得座席数+1)が最大の党の獲得座席数を＋１する\r\nで、２．を繰り返してるだけです。\r\n（内部的には(獲得座席数+1)が面倒で獲得座席数１から始めて最後に一律－１してるけど:p）\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1195'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1195
  :user_name: nkmrtks
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/155/
  :language: Common
  :time: 2007/07/20 19:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">後半部分弄ってリスト二つ返すようにしてみた。\r\n一つ目のリストは確定獲得座席数。\r\n二つ目は不確定獲得座席数（とか適当に言葉を作ってみる）。\r\n\r\n\r\n(dont
    100 '(123 4 56 78))\r\n =&gt; (48 1 21 30)\r\n =&gt; (nil nil nil nil)\r\n\r\n(dont
    102 '(100 100 100 99))\r\n =&gt; (25 25 25 25)\r\n =&gt; (2 2 2 nil)\r\n\r\n\r\n一つ目のパターンは座席をきれいに分け切れた場合。\r\n\r\n二つ目は投票数（正確には(投票数/既獲得座席数+1)）が同じ党が残り座席数以上出てきちゃう場合。\r\n(25
    25 25 25)ってのが各党の確定獲得座席数。\r\n(2 2 2 nil)ってのが不確定獲得座席数を表していて、\r\nこの場合は、2が残りの座席数で、nilじゃない３つの党で“なんとかして”分けてもらう、と:p</pre>\n\t"
  :code: |
    (defun dont (seats votes)
      (if (and (integerp seats) (listp votes))
          (let ((acc (mapcar #'(lambda (x) (cons x 1)) votes))
                (s seats))
            (loop
              (let ((m (apply #'max (mapcar #'(lambda (c) (/ (car c) (cdr c))) acc)))
                    (old acc))
                (setq acc
                      (mapcar #'(lambda (c)
                                  (if (= m (/ (car c) (cdr c)))
                                      (prog1
                                          (cons (car c) (1+ (cdr c)))
                                        (decf s))
                                    c))
                              acc))
                (if (&lt;= s 0)
                    (if (= s 0)
                        (return (values (mapcar #'1- (mapcar #'cdr acc))
                                        (make-list (length acc))))
                      (return (values (mapcar #'1- (mapcar #'cdr old))
                                      (mapcar #'(lambda (x y)
                                                  (and (&gt; x y)
                                                       (+ s
                                                          (count t
                                                                 (mapcar #'(lambda (x y)
                                                                             (&gt; x y))
                                                                         (mapcar #'cdr acc)
                                                                         (mapcar #'cdr old))))))
                                              (mapcar #'cdr acc)
                                              (mapcar #'cdr old)))))))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1196'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1196
  :user_name: kkobayashi
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/20 23:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "teisu &lt;- 100\nhyosu &lt;- c(a=123, b=4, c=56, d=78);\nn &lt;- sort(rep(hyosu,
    length=teisu*length(hyosu))/rep(1:teisu, length=teisu*length(hyosu), \n          each=length(hyosu)),
    dec=TRUE)[1:teisu]\nfor(i in names(hyosu)) cat(paste(i, \":\", length(names(n)[names(n)==i])),
    sep=\"\\n\")\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1198'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1198
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Bash
  :time: 2007/07/21 00:23 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  exprは小数計算できないのでbcで。\n\t"
  :code: |
    function dont() {
        cd /tmp
        n=$1
        shift
        i=0
        while [ "$1" != "" ];do
            echo $1 &gt; d.v.$i
            echo 0  &gt; d.ret.$i
            shift
            i=`expr $i + 1`
        done
        len=$i

        i=0
        while [ -f d.v.$i ]; do
            vv=`cat d.v.$i`
            for ((j=1; j&lt;=n; j++)); do
                echo `echo $vv / $j | bc -l` $i &gt; d.d.$i.$j
            done
            i=`expr $i + 1`
        done

        find -name 'd.d.*' | xargs cat | sort -n | tail -$n &gt; d.sum
        for ((i=0; i&lt;len; i++)); do
            egrep " $i"$ d.sum | wc -l &gt; d.ret.$i
            cat d.ret.$i
        done

        find -name 'd.ret.*' -o -name 'd.v.*' -o -name 'd.d.*' -o -name 'd.sum'| xargs rm
    }
    dont 100   123 4 56 78
    # 48
    # 1
    # 21
    # 30
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1199'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1199
  :user_name: rubikitch
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/105/
  :language: Perl
  :time: 2007/07/21 01:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  あー抽象化できなくてイライラする＞＜\n\t"
  :code: |
    sub dont {
        my $n = shift @_;
        my @v = @_;
        my $i, $j, @ret, @d, %e, $xx;
        foreach (@v) {
            push(@ret, 0);
        }
        $i=0;
        foreach $vv (@v) {
            for ($j=1; $j&lt;=$n; $j++) {
                $xx=$vv/$j;
                push(@d, [$xx, $i]);
            }
            $i++;
        }
        @d = sort { ${$a}[0] &lt;=&gt; ${$b}[0] } @d;
        my $lend=@d;
        for ($j=$lend-$n; $j&lt;$lend; $j++) {
            $ret[${$d[$j]}[1]] += 1;
        }
        return @ret;
    }
    print(join(' ', dont(100,123,4,56,78)));    # =&gt; [48, 1, 21, 30]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1209'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1209
  :user_name: shiro
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/41/
  :language: Haskell
  :time: 2007/07/21 03:07 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  得票数vに対して [v, v/2, v/3, v/4, ...] という無限リストが目に浮かんだので、Haskellで初挑戦。\n\t"
  :code: |
    import Data.List

    dhondt seats votes = map length $ group $ sort $ take seats $ pick $ pvs
      where pvs = zip [0..] $ map (\ v -&gt; map (v/) [1..]) votes

    pick pvs = p:(pick pvs'')
      where (p,v:vs):pvs' = sortBy (\ (p1,v1:v1s) (p2,v2:v2s) -&gt; compare v2 v1) pvs
            pvs''    = (p,vs):pvs'

    -- dhondt 100 [123,4,56,78] =&gt; [48,1,21,30]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1214'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1214
  :user_name: にしお
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/07/21 03:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">&gt;素直にやる事は多くの人がやってるのでひねくれた方法をする。\r\n&gt;ずばりソートを使わなくても出来る方法。\r\n\r\n多くの人が思いつく「素直な書き方」ってソートを使うものなんですかね？？\r\n他の人の解答を見てもソートを使っているものが多いみたいですけども…\r\n\r\n僕なりに素直に書くと下のようにソートを使わないコードになります。\r\n０：投票数をスコアにする\r\n１：スコアの一番高い政党を選ぶ\r\n２：その政党の「分母」を+1\r\n３：その政党のスコアを投票数÷分母にする\r\n４：その政党の「議席獲得数」を+1\r\n５：１～４を議席数だけ繰り返す\r\n\r\n7行目のtop
    = ...の後にprint topと挟むと、\r\nドント式の説明の通りの順番で座席を振っていっているのがわかります。</pre>\n\t"
  :code: |
    def dont(votes, num_seats):
        N = len(votes)
        result = [0] * N
        denom = [1.0] * N
        score = votes[:] # copy of list
        for i in range(num_seats):
            top = score.index(max(score))
            denom[top] += 1
            score[top] = votes[top] / denom[top]
            result[top] += 1

        return result

    print dont([1000, 700, 600, 280], 8)
    print dont([123, 4, 56, 78], 100)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1216'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1216
  :user_name: ocean
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/07/21 03:53 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  すでに類似の解答が出てますが・・・。max()をkeyパラメータと使うのが独自といえば独自か。（Python2.5以降）\n\t"
  :code: |
    def solve(sheet_count, votes):
        parties = [[vote, 0] for vote in votes] # list of [vote, sheet]
        for _ in xrange(sheet_count):
            party = max(parties, key=lambda party: float(party[0]) / (party[1] + 1))
            party[1] += 1
        return [party[1] for party in parties]

    def main():
        print solve(100, [123, 4, 56, 78])

    if __name__ == '__main__':
        main()
  :tags:
  - Python2.5
  :references:
    :url: 
    :title: 
- :id: '1238'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1238
  :user_name: ytakenaka
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/35/
  :language: 
  :time: 2007/07/21 05:48 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  どうなんでしょうね。正直なところわかりません。^^;ソートを使う方法を使ってるのが多いから、そちらが素直なのかなと思ってね。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1258'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1258
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Prolog
  :time: 2007/07/21 08:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Prolog です。とーても、長いコードなりました。要点まとめると、各政党ごとにドント方式の数列 (ドント数列) を生成して、全部を結合、並べ替え
    (sort)、最後に、各政党ごとの議席数をカウントする、というものです。もっとシンプルにかけないのかな～?\n\t"
  :code: |
    ★  ひとつ政党についてドント数列を生成します。
          new_dHondtSequence(dHondt('A',120), 5, [], DS).
        とすると、次の数列が生成されます。
           DS = [dHondt('A', 120), dHondt('A', 60),
                 dHondt('A', 40), dHondt('A', 30),
                 dHondt('A', 24)] ;

    new_dHondtSequence(D,0,DS,DS) :- !.
    new_dHondtSequence(dHondt(P,V),N, DS0, DS)
      :- N_ is N - 1,
         V_ is V / N,
         new_dHondtSequence(dHondt(P,V),N_, [dHondt(P,V_)|DS0], DS).


    ★ 各政党ごとのドント数列を生成し、全部をそのまま append します。
       ここで生成されるデータは、並び替えされていません。

    dHondtSequence_append([],N, DS0, DS0).
    dHondtSequence_append([D|Ds],N, DS0, DS_appended)
      :- new_dHondtSequence(D,N, [], NewDS),
         append(NewDS, DS0, DS1),
         dHondtSequence_append(Ds,N, DS1, DS_appended).


    ★ 各政党ごとのドント数列を append したものを、
       並び替えて、最終的な ドント数列を生成します。

    dHondtSequence(Ds,N,DHondtSequence)
      :- dHondtSequence_append(Ds,N,[],DS_appended),
         dHondtSequence_sort(DS_appended,[],DS_sorted),
         take(N, DS_sorted, DHondtSequence).

    ★ 並び替えられていないドント数列を
       得票数が大きい順番にならび変えます。
       (マージソートです。)

    dHondtSequence_sort([],DS0,DS0).
    dHondtSequence_sort([D|Ds],DS0,DS_sorted)
      :- dHondtSequence_sort_add(D,DS0,DS1),
         dHondtSequence_sort(Ds,DS1,DS_sorted).

    dHondtSequence_sort_add(D,[],[D]).
    dHondtSequence_sort_add(dHondt(P,V), [dHondt(Pmax,Vmax)|Ds],
      [dHondt(P,V)|[dHondt(Pmax,Vmax)|Ds]])
      :- V &gt; Vmax, !.
    dHondtSequence_sort_add(D,[Dmax|Ds],[Dmax|Ds_added])
      :- dHondtSequence_sort_add(D,Ds,Ds_added).


    ★ 与えられたリストの最初のN個の要素のみ切り出します。
       (N には 「定数」を与えます。)

    take(0,Xs,[]) :- !.
    take(N,[],[]) :- !.
    take(N_,[Item|Xs],[Item|Ys]) :- succ(N,N_), take(N,Xs,Ys).


    ★ 最終的なドント数列の中から、ある政党 P がどれだけ
       議席を獲得したかを数えます。

    dHondt_seat_for(P,[],S0,S0).
    dHondt_seat_for(P,[dHondt(P,V)|DS],S0, Seat)
      :- S1 is S0 + 1,
         dHondt_seat_for(P,DS,S1, Seat),
         !.
    dHondt_seat_for(P,[dHondt(P_,V)|DS], S0, Seat)
      :- dHondt_seat_for(P,DS,S0, Seat).


    ★ 各政党について、獲得した議席の数を調べ、
       リストにまとめます。

    dHondt_seat([],DS,Ss,Ss).
    dHondt_seat([dHondt(P,V)|DHondts], DS, Ss, Seats)
      :- dHondt_seat_for(P,DS,0,S),
         dHondt_seat(DHondts, DS, [seat(P,S)|Ss], Seats).


    ★ 得票数のデータ、「定数」、から各党の議席数を求めます。

    dHondt(DHondts, N, Seats)
      :- dHondtSequence(DHondts, N, DS),
         dHondt_seat(DHondts, DS, [], Seats).

    ☆☆ お試しコード ☆☆

    ?- dHondt(
           [dHondt('A',123), dHondt('B', 4), dHondt('C', 56), dHondt('D', 78)],
           100,
           Seats),
         writeln(Seats).

    ～結果～

    [seat(D, 30), seat(C, 21), seat(B, 1), seat(A, 48)]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1263'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1263
  :user_name: kacchi
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/145/
  :language: Scheme
  :time: 2007/07/21 10:36 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">1. 各政党の獲得議席数リストを0にセット。正数リストを1にセット。\r\n2. 各党の得票数を正数で割っていく。\r\n3.
    獲得議席数と正数リストを、商が最大の政党のところで+1する。\r\n4. 2,3を繰り返し、定足数に達したら獲得議席数リストを返す。\r\nと、考えてやってみました。\r\n\r\n(dhondt
    100 '(123 4 56 78))\r\n=&gt;(48 1 21 30)\r\n</pre>\n\t"
  :code: |
    (define (dhondt seats votes)
      (define (max1+ l s d)
        (let1 m (apply max l)
          (do ((l l (cdr l)) (s s (cdr s)) (d d (cdr d))
               (a '() (if (= (car l) m) (cons (+ (car s) 1) a) (cons (car s) a)))
               (b '() (if (= (car l) m) (cons (+ (car d) 1) b) (cons (car d) b))))
              ((null? l) (cons (reverse! a) (reverse! b))))))
      (let1 len (length votes)
        (let loop ((score (make-list len 0))
                   (denom (make-list len 1)))
          (if (&gt;= (apply + score) seats)
              score
              (let1 s&amp;d (max1+ (map (cut / &lt;&gt; &lt;&gt;) votes denom) score denom)
                (loop (car s&amp;d) (cdr s&amp;d)))))))
  :tags:
  - gauche
  :references:
    :url: 
    :title: 
- :id: '1270'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1270
  :user_name: kacchi
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/145/
  :language: Emacs
  :time: 2007/07/21 11:23 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">同じくEmacs Lispで。\r\n(dhondt 100 '(123 4 56 78))\r\n=&gt;(48
    1 21 30)\r\n</pre>\n\t"
  :code: |
    (require 'cl)
    (defun dhondt (seats votes)
      (let ((max1+ (lambda (l s d)
                     (let ((m (apply #'max l)))
                       (do ((l l (cdr l)) (i 0 (+ i 1)))
                           ((null l) (cons s d))
                         (when (= (car l) m)
                           (incf (car (nthcdr i s)))
                           (incf (car (nthcdr i d))))))))
            (len (length votes)))
        (do ((score (make-list len 0))
             (denom (make-list len 1)))
            ((&gt;= (apply #'+ score) seats) score)
          (let ((s&amp;d (funcall max1+ (map 'list #'(lambda (a b) (/ (* a 1.0) b))
                                         votes denom)
                              score denom)))
            (setq score (car s&amp;d)
                  denom (cdr s&amp;d))))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1275'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1275
  :user_name: katsu
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/117/
  :language: Prolog
  :time: 2007/07/21 12:12 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">こんな感じでも書けますよ。\r\npredsortがremove duplicateなのでちょっと残念ですが。\r\n</pre>\n\t"
  :code: |
    votes_sort(L,R) :- predsort(votes_compare, L, R).

    votes_compare(K,(_,A,Ca),(_,B,Cb)) :-Va is float(A) / Ca, Vb is float(B) / Cb, compare(K0,Vb,Va),(K0=='='-&gt;compare(K,Ca,Cb);K0=K).

    dhondt(0,_,R,R).
    dhondt(I,L,H,R):-votes_sort(L,[(N,V,C)|Ls]),succ(I1,I),succ(C,C1),count(N,H,Hs),dhondt(I1, [(N,V,C1)|Ls],Hs,R).

    count(X,[(X,N)|Hs],[(X,N1)|Hs]):-succ(N,N1).
    count(X,[H|Hs],[H|Rs]) :- count(X,Hs,Rs).
    count(X,[],[(X,1)]).

    :-dhondt(100, [(a,123,1), (b,4,1), (c,56,1), (d,78,1)], [], R), writeln(R).
  :tags:
  - SWI-prolog
  :references:
    :url: 
    :title: 
- :id: '1292'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1292
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: 
  :time: 2007/07/21 14:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  まぁ。なんと短い。predsort なんていう便利な述語があるんですねぇ。これに、述語 count でハッシュテーブルですね。なにより、d'Hondt方式のアルゴリズムとして、無駄のない計算になってますよね。私のように、無駄なリストだらだら生成したりしない。。。私のような
    Prolog ズブの初心者からすると、とても、勉強になるコードでした。ありがとうございました。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1312'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1312
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Java
  :time: 2007/07/21 16:46 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  Java です。katsu さんの Prolog プログラムを Java で焼き直ししてみました。(なんだか見た目、長いですね。。。)\n\t"
  :code: "import java.lang.Comparable ;\nimport java.util.Arrays ;\n\nclass dHondtMethod\n
    \ {\n  static class Vote implements Comparable\n    {\n    String 政党名 ; int 得票数
    ; int 既得の議席数 ;\n    Vote (String 名, int 票, int 席)\n      {政党名 = 名 ; 得票数 = 票 ;
    既得の議席数 = 席 ;} \n\n    public int compareTo (Object another_)\n      {\n      Vote
    another = (Vote) another_ ;\n\n      Double thisValue\n        = new Double (this.得票数
    / (this.既得の議席数 + 1.)) ;\n      Double anotherValue\n        = new Double (another.得票数
    / (another.既得の議席数 + 1.)) ;\n\n      int cmp = thisValue .compareTo (anotherValue)
    ;\n      return cmp!=0 ? cmp : this.得票数 - another.得票数 ;\n      }\n\n    public
    String toString ()\n      {return \"(政党名=\"+政党名+\", 得票数=\"+得票数\n              +\",
    既得の議席数=\"+既得の議席数+\")\" ;}\n    }\n\n  public static void main (String [] _)\n
    \   {\n    int 定数 = 100 ;\n\n    Vote [] votes = \n      {new Vote (\"A党\", 123,
    0), new Vote (\"B党\",   4, 0),\n       new Vote (\"C党\",  56, 0), new Vote (\"D党\",
    \ 78, 0)} ;\n\n    while (0&lt; 定数)\n      {\n      Arrays.sort (votes) ;\n      Vote
    last = votes [votes.length - 1] ; // 最大のもの\n      ++last.既得の議席数 ;\n      --定数
    ;\n      }\n\n    for (int i=0; i&lt;votes.length; ++i)\n      {System.out .println
    (votes [i]) ;}\n    }\n  }\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1327'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1327
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Scheme
  :time: 2007/07/22 05:02 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Scheme です。 Java で書いてみて分かったのですが、議席数の計算のつど、[A,B,C,D] 全体で sort する必要はないですよね。全体で
    sort が必要なのは最初の1回だけで、次回以降は、その時 議席を獲得した党の順位が入れ替わるだけ。たとえば、議席計算の最初の第1回目では全体で sort
    すると A党(=123), D党(=78), C党(=56), B党(=4) の順になり A党 が議席獲得ですが、次回は、A党の数値のみが変わる(123→66.5)だけなので、A党の順位のみを気にすればいいだけ。こう考えると、マージソートにすれば、最適化を図れるわけですよね。つまり、残りの
    [D, C, B]  に対して、大きい順で マージ (追加) する処理をすれば、最小限の sort 処理になります。実際、今の例ですと、D党(=78) と入れ替わるだけで、すみます。。。。ということで、長くなりましたが、マージ方式のアルゴリズムで書いてみました。時々は、気分を変えて、Scheme
    で書いてみました。(Scheme らしからぬ書き方ですが。。。)\n\t"
  :code: |
    ; Vote オブジェクトの定義

    (define (new_Vote party-name vote-count seat-count)
      (list party-name vote-count seat-count))
    (define (Vote_getPartyName this) (car this))
    (define (Vote_getVoteCount this) (cadr this))
    (define (Vote_getSeatCount this) (caddr this))

    (define (Vote_increaseSeatCount this)
      (new_Vote
        (Vote_getPartyName this)
        (Vote_getVoteCount this)
        (+ (Vote_getSeatCount this) 1)
      )
    )

    (define (Vote_isLessThan this another)
      (let
        (
        (thisValue (/ (Vote_getVoteCount this) (+ (Vote_getSeatCount this) 1)))
        (anotherValue (/ (Vote_getVoteCount another) (+ (Vote_getSeatCount another)1)))
        )

        (if (= thisValue anotherValue)
          (&lt; (Vote_getVoteCount this) (Vote_getVoteCount another))
          (&lt; thisValue anotherValue)
        )
      )
    )

    (define (Vote_display this)
      (display "party-name: ") (display (Vote_getPartyName this)) (display ", ")
      (display "vote-count: ") (display (Vote_getVoteCount this)) (display ", ")
      (display "seat-count: ") (display (Vote_getSeatCount this)) (newline)
    )

    ; d'Hondt 方式の要

      ; 新しい Vote オブジェクトを大きい順で追加する

      (define (dHondt_add this vote)
        (if (null? this)
          (list vote)
        (if (Vote_isLessThan (car this) vote)
          (cons vote this)
          (cons (car this) (VoteList_add (cdr this) vote)) ; .... ?
        ))
      )


    ; ここが d'Hondt の処理

    (define (dHondt total-seat-count sorted-vote-list)
      (do () ((= 0 total-seat-count))
        ; 次回の 今回議席を獲得した党 (car) の議席数を
        ; 1増やして (increaseSeatCount)、
        ; 残りの党たちのリスト (cdr) に add する
        ; (このアルゴリズムのポイント)
        (set! sorted-vote-list
          (dHondt_add
            (cdr sorted-vote-list)
            (Vote_increaseSeatCount (car sorted-vote-list))
          )
        )
        (set! total-seat-count (- total-seat-count 1))
      )
      sorted-vote-list
    )

    ; お試しコード ------------------------------------------------------------

    (define otameshi-list ())
    (set! otameshi-list (dHondt_add otameshi-list (new_Vote "A" 123 0)))
    (set! otameshi-list (dHondt_add otameshi-list (new_Vote "B"   4 0)))
    (set! otameshi-list (dHondt_add otameshi-list (new_Vote "C"  56 0)))
    (set! otameshi-list (dHondt_add otameshi-list (new_Vote "D"  78 0)))

    (set! otameshi-list (dHondt 100 otameshi-list))

    (Vote_display (car otameshi-list))
    (Vote_display (cadr otameshi-list))
    (Vote_display (caddr otameshi-list))
    (Vote_display (cadddr otameshi-list))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1328'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1328
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Scheme
  :time: 2007/07/22 05:08 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  おっとっと。46行目、書き間違いです。(Upの直前に名前変更したもので、、、)すみません。\n\t"
  :code: |
    誤: (cons (car this) (VoteList_add (cdr this) vote))

    正: (cons (car this) (dHondt_add (cdr this) vote))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1329'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1329
  :user_name: ether
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/96/
  :language: Perl
  :time: 2007/07/22 05:32 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  政党ごとに x/1, x/2, x/3 ... という無限数列を作って先頭から大きい順に籠に放り込んでいくアプローチです。\n\t"
  :code: |
    use List::Util qw(max);
    use List::MoreUtils qw(indexes);
    use HOP::Stream qw(upfrom transform head tail);

    sub max_index { my @xs = @_; (indexes { $_ == max(@xs) } @xs)[0] }

    my $num_seats = shift;
    my @votes = @ARGV;

    my @seqs;
    foreach my $party (0..$#votes) {
      my $votes = $votes[$party];
      $seqs[$party] = transform { $votes / $_[0] } upfrom(1);
    }

    my @seat = ();
    foreach my $i (1..$num_seats) {
      my $party = max_index(map { head($_) } @seqs);
      $seat[$party]++;
      $seqs[$party] = tail($seqs[$party]);
    }

    print join(" ", @seat), "\n";
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1346'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1346
  :user_name: hirataka
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/233/
  :language: JavaScript
  :time: 2007/07/22 10:50 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">JavaScript1.6でArrayに実装されたmap()とindexOf()を使ってます。\r\nFirefox2.0.0.5で動作の確認をしました。\r\n</pre>\n\t"
  :code: "Array.prototype.max = function(){\n  return Math.max.apply(null, this)\n}\n\nfunction
    dont(teisu, hyo){\n  var temp = Array.apply(null, hyo);\n  var giseki = Array.map(hyo,
    function(){ return 0; });\n\t\n  while(teisu-- &gt; 0){\n    var index = temp.indexOf(temp.max());\n
    \   temp[index] = hyo[index]/ (++giseki[index]+ 1);\n  }\n\n  return giseki;\n}\n\nalert(dont(100,
    [123, 4, 56, 78]));\n"
  :tags:
  - JavaScript1.6
  - JavaScript1.7
  :references:
    :url: 
    :title: 
- :id: '1359'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1359
  :user_name: JDO
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/257/
  :language: Perl
  :time: 2007/07/23 03:03 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  Perl です。既出の回答に対して、新規性ありません。(僕のコードってどういうわけか、長くなるんですよね～)\n\t"
  :code: |
    sub dHondt
      {
      local ($totalSeatCount) = shift (@_) ;
      local (@voteCounts) = @_ ;
      local ($seatCounts) = [] ;

      local ($voteCount) ;
      foreach $voteCount (@voteCounts)
        {push (@{$seatCounts}, 0) ;}

      # 「定数」回だけ繰り返す
      while (0&lt; $totalSeatCount)
        {
        local ($max, $maxIndex) = (0, undef) ;
        # 最大の党を探す
        local ($i) ;
        for ($i=0 ; $i&lt;@voteCounts; ++$i)
          {
          if ($max &lt; $voteCounts[$i]/($seatCounts-&gt;[$i] + 1.0))
            {
            $max = $voteCounts[$i]/($seatCounts-&gt;[$i] + 1.0) ;
            $maxIndex = $i ;
            }
          }

        # 最大の党の議席を1増やす
        ++$seatCounts-&gt;[$maxIndex] ;
        }
      continue
        {--$totalSeatCount ;}

      return $seatCounts ;
      }

    # お試しコード

    local (@seats) = @{&amp;dHondt (100,  123,4,56,78)} ;
    local ($i) ;
    for ($i=0; $i&lt;@seats; ++$i)
      {print "$seats[$i], " ;}
    print "\n" ;
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1369'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1369
  :user_name: smeghead
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/31/
  :language: Common
  :time: 2007/07/23 15:00 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  (dhondt 100 '(123 4 56 78))\n\t"
  :code: "(defstruct party vote (seat 0))\n\n(defun max-index (lst)\n  (let ((max
    0) (max-index 0))\n    (loop for x in lst for i from 0\n          when (&lt; max
    x) \n          do (setf max-index i) \n             (setf max x))\n    max-index))\n\n(defun
    selection (parties)\n  (let* ((selected (max-index \n                     (mapcar
    #'(lambda (x)\n                                 (/ (party-vote x) (1+ (party-seat
    x)))) \n                             parties)))\n         (selected-party (nth
    selected parties)))\n    (setf (party-seat selected-party) (1+ (party-seat selected-party)))\n
    \   (loop for p in parties for i from 0\n          collect (if (eql i selected)
    selected-party p))))\n\n(defun dhondt (n votes)\n  (labels ((rec (n ps)\n                (if
    (zerop n)\n                  ps\n                  (rec (1- n) (selection ps)))))\n
    \   (mapcar #'party-seat \n            (rec n (mapcar #'(lambda (v) (make-party
    :vote v))\n                           votes)))))\n"
  :tags:
  - clisp
  :references:
    :url: 
    :title: 
- :id: '1439'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1439
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2007/07/24 18:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#1214 のにしおさんの方法をヒープモジュールの挿入、最小値取り出しを使って書きました。\r\n</pre>\n\t"
  :code: |
    import Data.Graph.Inductive.Internal.Heap (build, insert, splitMin)
    import List (unfoldr, group, sort)
    import Ratio

    dhondt n xs = map (length.tail) $ group $ sort $ (ps++)
      $ take n $ unfoldr f
      $ build $ zipWith (\p x -&gt; (-x%1, (1, p))) ps xs
      where
        ps = [1..length xs]
        f heap = Just (p, heap'') where
          (a, (i, p), heap') = splitMin heap
          heap'' = insert (a*i/(i+1), (i+1, p)) heap'

    -- dhondt 100 [123, 4, 56, 78]
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1500'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1500
  :user_name: susu
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/218/
  :language: Python
  :time: 2007/07/27 07:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  結構こんがらがったので頭の整理用の代入がいくつかあります。\n\t"
  :code: "def dont(votes=[123, 4, 56, 78],constant=100):\n\tseat\t= [0]*len(votes)\n\tvotes\t=
    map(lambda x:x*constant, votes)\t#小数の代わり\n\ttable\t= []\n\t[table.extend( map(lambda
    x:x/i,votes)) for i in xrange(1,constant+1)]\n\tfence\t= len(votes)\n\t\n\tfor
    i in range(constant):\n\t\tmaxValue = max( table[:fence] ) \n\t\tmaxValueIndx
    = table.index(maxValue)\n\t\ttable[maxValueIndx] = 0\n\t\t\n\t\tseatIndx = (maxValueIndx
    +1) % len(votes) -1\n\t\tseat[seatIndx] += 1\n\t\t\n\t\tif\tfence &lt;= maxValueIndx
    + len(votes) :\t#検索範囲拡大\n\t\t\tfence += len(votes)\n\t\t\t\n\treturn seat\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1502'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1502
  :user_name: にしお
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/27 09:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  maxにもkeyパラメータがあったとは知らなかったです。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1533'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1533
  :user_name: 沢渡 みかげ
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/101/
  :language: Mathematica
  :time: 2007/07/28 04:33 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">ytakenakaさんのコメントの\r\nhttp://homepage2.nifty.com/PAF00305/math/apportionment/node4.html\r\nを参考に書いてみました．\r\n\r\nFloor[定数k×得票数]
    の合計 == 議席数\r\n\r\nを満たす最大のkを求めます．\r\n\r\n実行例：\r\nIn[2]:=\r\n  seki = 100;\r\n  hyou
    = {123, 4, 56, 78};\r\n  don[seki, hyou]\r\nOut[2]:= {48, 1, 21, 30}\r\n</pre>\n\t"
  :code: |
    don[seki_, hyou_] := Module[{k},
       k = NMaximize[{
           k, Total[Floor[k hyou]] == seki
           }, k][[1]];
       Floor[k hyou]
       ];
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1561'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1561
  :user_name: ocean
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/177/
  :language: 
  :time: 2007/07/29 06:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  ええ、本当はall()とany()にも欲しいんですけどね(^^; （トランプのお題では自前で定義）\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1625'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1625
  :user_name: Mistfeal
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/153/
  :language: PHP
  :time: 2007/07/31 09:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  あんまり綺麗じゃないけど、取りあえず。\n\t"
  :code: "&lt;?php\n\tfunction DHondt($A,$B) {\n\t\tforeach ( $B as $key =&gt; $val
    ) {\n\t\t\t$i = 1;\n\t\t\twhile ( $val / $i &gt;= 1 ) {\n\t\t\t\t$party[$key][$i]
    = $val / $i;\n\t\t\t\t$all[]           = $val / $i;\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\t$rtn[]
    = 0;\n\t\t}\n\t\trsort($all);\n\t\tfor ( $j = 0; $j &lt; $A; $j++ ) {\n\t\t\tfor
    ( $k = 0; $k &lt; count($party); $k++ ) {\n\t\t\t\tif ( in_array($all[$j],$party[$k])
    ) {\n\t\t\t\t\t$rtn[$k]++;\n\t\t\t\t\tarray_shift($party[$k]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn
    $rtn;\n\t}\n\n\t$A = 100;\n\t$B = array(123,4,56,78);\n\tprint_r(DHondt($A,$B));\n?&gt;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1675'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1675
  :user_name: nobsun
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/98/
  :language: Haskell
  :time: 2007/08/02 00:16 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">議席が獲得できない場合ちゃんと 0 を表示するようにした。</pre>\n\t"
  :code: "import Data.List\n\nbinapp b f g x y = f x `b` g y\nbinapp' b f g x = f
    x `b` g x\ncmpapp :: Ord b =&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; Ordering\ncmpapp
    f x y = f x `compare` f y\n\ndhondt seats = map snd\n             . fillup 0 [0..]\n
    \            . map (binapp' (,) head length)\n             . group \n             .
    sort\n             . take seats\n             . map fst\n             . merge
    (cmpapp (snd . head))\n             . zipWith zip (map repeat [0..])\n             .
    map (zipWith (flip (/)) [1..] . repeat)\n\nmerge :: ([a] -&gt; [a] -&gt; Ordering)
    -&gt; [[a]] -&gt; [a]\nmerge cmp xss = case pickupMax cmp xss of\n     ((y:ys),zss)
    -&gt; y : merge cmp (ys:zss)\n\npickupMax :: (a -&gt; a -&gt; Ordering) -&gt;
    [a] -&gt; (a,[a])\npickupMax cmp (x:xs) = pm (x,[]) xs\n  where pm acc [] = acc\n
    \       pm (x,xs) (y:ys)\n          = case x `cmp` y of\n              LT -&gt;
    pm (y,x:xs) ys\n              _  -&gt; pm (x,y:xs) ys\n\nfillup :: a -&gt; [Int]
    -&gt; [(Int,a)] -&gt; [(Int,a)]\nfillup _ _ [] = []\nfillup z (i:is) xxs@(x@(j,_):xs)\n
    \ | i &lt; j     = (i,z) : fillup z is xxs\n  | otherwise = x : fillup z is xs\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1689'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1689
  :user_name: 匿名
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/4/
  :language: JavaScript
  :time: 2007/08/02 06:46 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  まとめてArrayにつっこんでsortして前から定数分取り出すという\n\t"
  :code: "function dont(teisu,hyous){\n\ttmp=[],giseki=[];\n\tfor(seitou=0;seitou&lt;hyous.length;seitou++){\n\t\tfor(i=0;i&lt;teisu;i++){\n\t\t\ttmp.push({c:hyous[seitou]/(i+1),seitou:seitou});\n\t\t}\n\t}\n\ttmp.sort(function(x,y){return
    y.c-x.c});\n\tfor(i=0;i&lt;teisu;i++){\n\t\tgiseki[tmp[i].seitou] = ++giseki[tmp[i].seitou]
    || 1;\n\t}\n\treturn giseki;\n}\ndont(100,[123, 4, 56, 78])\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1694'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1694
  :user_name: ocean
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/177/
  :language: C
  :time: 2007/08/02 10:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  上のコードをC++(STL)に移植しました。（カバレッジ稼ぎ）\n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    #include &lt;vector&gt;

    class party
    {
    public:
        party(size_t vote) : _vote(vote), _sheet(0) {}

        friend bool operator&lt;(const party&amp; lhs, const party&amp; rhs)
        {
            return lhs.key() &lt; rhs.key();
        }

        size_t sheet() const { return _sheet; }

        void add_sheet() { ++_sheet; }

    private:
        size_t _vote, _sheet;

        double key() const
        {
            return static_cast&lt;double&gt;(_vote) / (_sheet + 1);
        }
    };

    void solve(size_t sheet_count, size_t* beg, size_t* end)
    {
        if (beg == end) return;

        std::vector&lt;party&gt; parties;

        std::copy(beg, end, std::back_inserter(parties));

        for (size_t i = 0; i &lt; sheet_count; ++i)
        {
            std::max_element(parties.begin(), parties.end())-&gt;add_sheet();
        }

        std::transform(parties.begin(), parties.end(), beg, std::mem_fun_ref(&amp;party::sheet));
    }

    int main()
    {
        size_t datas[] = {123, 4, 56, 78};

        size_t* beg = datas;

        size_t* end = datas + sizeof(datas) / sizeof(*datas);

        solve(100, beg, end);

        std::copy(beg, end, std::ostream_iterator&lt;size_t&gt;(std::cout, " "));
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1719'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1719
  :user_name: tomatsu
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/323/
  :language: Pnuts
  :time: 2007/08/02 12:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    function dont(n, v){
      votes = list(project(v, {i-&gt;{"t"=&gt;i, "k"=&gt;0}}))
      i=0; for (v : votes) v.idx = i++
      for (j : 1..n) {
        m = sort(votes, {x-&gt;double(x.t)/(x.k+1)})[-1]
        m.k = m.k + 1
      }
      project(sort(votes, {v-&gt;v.idx}),{v-&gt;v.k})
    }

    println(dont(100, [123, 4, 56, 78]))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1998'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/1998
  :user_name: naoya_t
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/348/
  :language: awk
  :time: 2007/08/07 19:20 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">% awk -f dont.awk 100 288 245 172 149 111 82\r\n総議席数:
    100\r\n　各党の得票数: 288 245 172 149 111 82 \r\n　各党の得票議席数: 28 24 16 14 10 8 \r\n\r\n%
    awk -f dont.awk 100 123 4 56 78\r\n総議席数: 100\r\n　各党の得票数: 123 4 56 78 \r\n　各党の得票議席数:
    48 1 21 30 \r\n※二つ（またはそれ以上）の商が同一の数値になります。\r\n※公職選挙法第95条3項2号の規定により、このケースではどの党が獲得するかくじ引きで決める議席が発生します。\r\n※従って、上記の結果は実際の結果と異なる場合があります。\r\n</pre>\n\t"
  :code: "BEGIN {\n\ttotal_seats = ARGV[1]\n\t\n\tparty_count = ARGC - 2\n\tfor (i=1;
    i&lt;=party_count; i++) votes[i] = ARGV[1+i];\n\n\t# 複数の商が同一の数値になり、くじ引きが必要になる回数\n\tlottery
    = 0\n\n\tfor (i=1; i&lt;=NF; i++) votes[i] = $i\n\n\tfor (p=1; p&lt;=party_count;
    p++) { # p = 党番号 (1〜)\n\t\tseats_for[p] = 0;\n\t\tdenom[p] = 1;\n\t\tquotient[p]
    = votes[p] # votes[p] / denom[p] = votes[p] / 1 = votes[p]\n\t}\n\n\tfor (i=total_seats;
    i&gt;0; i--) {\n\t\tp = max_at(quotient, party_count)\n\n\t\tseats_for[p]++\n\t\tdenom[p]++\n\t\tquotient[p]
    = votes[p] / denom[p]\n\t}\n\n\tprintf(\"総議席数: %d¥n\", total_seats)\n\tprintf(\"　各党の得票数:
    \")\n\tfor (i=1; i&lt;=party_count; i++) printf(\"%d \", votes[i]); printf \"¥n\"\n\n\tprintf(\"　各党の得票議席数:
    \")\n\tfor (p=1; p&lt;=party_count; p++) printf(\"%d \", seats_for[p]);\n\tprintf
    \"¥n\"\n\n\tif (lottery &gt; 0) {\n\t\tprint \"※二つ（またはそれ以上）の商が同一の数値になります。\"\n\t\tprint
    \"※公職選挙法第95条3項2号の規定により、このケースではどの党が獲得するかくじ引きで決める議席が発生します。\"\n\t\tprint \"※従って、上記の結果は実際の結果と異なる場合があります。\"\n\t}\n\n}\n\nfunction
    max_at(ar,cnt, at,max,check_again,i,max_count)\n{\n\tat = 0\n\tmax = -1\n\n\tcheck_again
    = 0 # 最大値をとる党が複数ある可能性があるか\n\n\tfor (i=1; i&lt;=cnt; i++) {\n\t\tif (ar[i] &gt;
    max) { at = i; max = ar[i]; }\n\t\telse if (ar[i] == max) check_again = 1\n\t}\n\n\tif
    (check_again) {\n\t\tmax_count = 0\n\t\tfor (i=1; i&lt;=cnt; i++) if (ar[i] ==
    max) max_count++\n\t\tif (max_count &gt; 0) lottery++;\n\t}\n\n\treturn at\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2001'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2001
  :user_name: yattom
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/335/
  :language: awk
  :time: 2007/08/08 01:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">ex)\r\n&gt;gawk -f dhondt.awk\r\n100 123 4
    56 78 ←入力\r\n48 1 21 30 ←出力\r\n\r\nfunction dhondt(seats, input) に、\r\nseats(議席数)と、\r\ninput(各党の得票数)を、\r\nわたします。\r\ninput
    は配列ではなく、スペース(FS)区切りの文字列です。\r\n結果も、スペース区切りの文字列で得られます。\r\n\r\nアルゴリズムは、テーブルを作らずに順次割りながら比較しています。</pre>\n\t"
  :code: "unction max(a,  i, mval, midx) {\n\tmval = 0\n\tfor(i in a) {\n\t\tif(mval
    &lt; a[i]) {\n\t\t\tmval = a[i]\n\t\t\tmidx = i\n\t\t}\n\t}\n\treturn midx\n}\n\nfunction
    dhondt(seats, input,     result, i, str) {\n\tnum = split(input, votes)\n\tfor(i
    in votes) {\n\t\tdiv[i] = 1\n\t\tresult[i] = 0\n\t}\n\n\twhile(seats &gt; 0) {\n\t\tfor(i
    in votes) {\n\t\t\tcurrent[i] = votes[i] / div[i]\n\t\t}\n\n\t\tmax_idx = max(current)\n\t\tresult[max_idx]++\n\t\tdiv[max_idx]++\n\t\tseats--\n\t}\n\tfor(i
    = 1; i &lt;= num; i++) {\n\t\tstr = str result[i] \" \"\n\t}\n\treturn str\n\n}\n\n{\n\tseats
    = $1\n\t$1 = \"\"\n\tprint dhondt(seats, $0)\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2067'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2067
  :user_name: nskj77
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/375/
  :language: Haskell
  :time: 2007/08/11 02:55 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  たまには合成モナドをつかって。\n\t"
  :code: |
    import Data.List
    import Control.Monad.State
    import Control.Monad.Writer

    data Vote = V {idx::Int, num::Double, poll::Double} deriving Show
    type Votes = [Vote]
    type Proc a = StateT Votes (Writer [Int]) a

    runProc :: Proc () -&gt; Votes -&gt; [Int]
    runProc proc vs = fmt $ group $ sort $ snd $ runWriter $ evalStateT proc vs
      where fmt  = map length . fmt' 1 . map (\x -&gt; (head x, x))
            fmt' _ [] = []
            fmt' n ((x,y):xs) = if n == x then y:fmt' (n + 1) xs else []:fmt' (n + 1) ((x,y):xs)

    mkProc :: Int -&gt; Proc ()
    mkProc seats = if seats == 0 then return ()
                   else do vs &lt;- get
                           let (V i n p:ts) = sortBy (\x y -&gt; f y `compare` f x) vs
                             in tell [i] &gt;&gt; put ((V i (n + 1) p):ts) &gt;&gt; mkProc (seats - 1)
      where f x = poll x / (num x + 1)

    f x xs = runProc (mkProc x) (zipWith (\x y -&gt; V x 0 y) [1..(length xs)] xs)
  :tags:
  - Haskell
  :references:
    :url: 
    :title: 
- :id: '2090'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2090
  :user_name: iwk
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/49/
  :language: OCaml
  :time: 2007/08/13 00:07 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  scan_leftを使ってみました。\n\t"
  :code: |
    #light
    open List
    let rec take n xs =
        match n,xs with
        | n,_ when n &lt;= 0 -&gt; []
        | _,[] -&gt; []
        | n,(x::xs') -&gt; x::(take (n-1) xs')

    let dhont seat vs =
        let vs' = map float vs
        let mkTable v =
            scan_left (fun w n -&gt; ((n - 1.0)*w/n)) v [2.0 .. (float seat)]
        let size = length vs -1
        map mkTable vs'
        |&gt; mapi (fun n xs -&gt; map (fun x -&gt; (x,n)) xs)
        |&gt; concat
        |&gt; sort (fun x y -&gt; compare y x)
        |&gt; take seat
        |&gt; split
        |&gt; snd
        |&gt; (fun xs -&gt; map (fun n -&gt; (length (filter ((=) n) xs))) [0 .. size])

    do print_any (dhont 100 [123;4;56;78])
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '2143'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2143
  :user_name: drop
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/388/
  :language: Haskell
  :time: 2007/08/14 06:14 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">議席数0でも表示。くじ引きが発生するような場合は確定議席だけ。</pre>\n\t"
  :code: |
    import Data.List

    dhondt seats votes = map (length . filter (&lt; b)) xs
     where
      xs = [map (negate . (v/)) [1..fromIntegral seats] | v&lt;-votes]
      b = sort (concat xs) !! seats
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2144'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2144
  :user_name: drop
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/388/
  :language: Haskell
  :time: 2007/08/14 06:17 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">Data.List が merge らへんを export してくれてりゃ、無限リストでこう書くんだけどなー。</pre>\n\t"
  :code: |
    import Data.List

    dhondt seats votes = map (length . filter (&gt; b)) xs
     where
      xs = [map (v/) [1..] | v&lt;-votes]
      b = mergesort' (flip compare) xs !! seats
  :tags: []
  :references:
    :url: /web/20100421170215/http://darcs.haskell.org/ghc-6.6/packages/base/Data/List.hs
    :title: Data.List
- :id: '2894'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/2894
  :user_name: 130R
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/409/
  :language: PowerShell
  :time: 2007/09/04 07:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">48\r\n1\r\n21\r\n30</pre>\n\t"
  :code: |
    function create-party($id,$votes)
    {
         $p = add-member -in $id --passthru NoteProperty votes $votes
         add-member -in $p NoteProperty level 1
         add-member -in $p ScriptMethod rate { $this.votes / $this.level; $this.level++}
         $p
    }

    filter max {
        begin{$m = 0; $i = 0; $r = 0}
        process{if($m -lt $_) {$m=$_; $r=$i} $i++}
        end{$r}
    }

    $const = 100
    $votes = 123, 4, 56, 78
    $parties = $votes | %{$i=0}{create-party $i $_; $i++}
    $result = 1..$const
    $rates = $parties | %{$_.rate()}
    for ($i = 0; $i -lt $const; ++$i) {
         $id = $rates | max
         $result[$i] = $id
         $rates[$id] = $parties[$id].rate()
    }
    foreach ($id in $parties) {@($result | where-object {$_ -eq $id}).length}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3451'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/3451
  :user_name: idesaku
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/470/
  :language: Ruby
  :time: 2007/10/18 06:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>なるべく読みやすく書こう、とStructを使ってみましたが、このサイズだと別にうれしくないですね。\r</p>\n<p>計算に無駄が多いのは気にしない。</p>\n</div>\n\t"
  :code: |
    # 合計得票数, 獲得議席数
    PartyData = Struct.new(:vote, :seat)

    def dont(giseki, votes)
      data = votes.map { |v| PartyData.new(v.to_f, 0) }

      giseki.times {
        counter = data.map { |party| [ party, party.vote / (party.seat + 1) ] }

        counter.sort { |a,b|
          b[1] &lt;=&gt; a[1]
        }[0][0].seat += 1
      }

      data.map { |d| d.seat }
    end

    p dont(100, [123, 4, 56, 78])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '4135'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/4135
  :user_name: greentea
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/573/
  :language: Python
  :time: 2007/11/17 03:30 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  初投稿です。\r\n\r\nとりあえず書いてみたけど、あんまりスマートじゃないですねorz\r\nmaxにkeyつけるとかできたのか・・・・\n\t"
  :code: |
    def dont(giseki, votes):
      giseki = giseki
      table = []
      for x in votes:
        table.append({"vote": int(x), "atari": 0, "warizan": float(x)})
      for i in range(giseki):
        tousen = table[0]
        for cursor in table[1:]:
          if tousen["warizan"] &lt; cursor["warizan"]: tousen = cursor
        tousen["atari"] += 1
        tousen["warizan"] = tousen["vote"]/(tousen["atari"]+1.0)
      return [x["atari"] for x in table]

    print dont(100, [123, 4, 56, 78])
    print dont(8, [1000, 700, 600, 280])
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5085'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5085
  :user_name: vtwntmtn
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/380/
  :language: Erlang
  :time: 2008/01/01 11:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>一つ席を確定しては、その党を割算して、その中から一つ席を確定して…と繰り返します。\n答えはちゃんと出るけど、書きづらかったので、戦略的に良くないのかも。</p>\n<pre
    class=\"literal-block\">\n1&gt; c(dont).\n{ok,dont}\n2&gt; dont:dont([123, 4,
    56, 78], 100).\n[48,1,21,30]\n</pre>\n\n\t"
  :code: |
    -module(dont).
    -export([dont/2]).

    search(Fun, List) -&gt; search(Fun, List, length(List), length(List) - 1).

    search(_, _, Max, 0) -&gt; Max;
    search(Fun, List, Max, Idx) -&gt;
        case Fun(lists:nth(Max, List), lists:nth(Idx, List)) of
            true-&gt; search(Fun, List, Idx, Idx - 1);
            false -&gt; search(Fun, List, Max, Idx - 1)
        end.

    replace(List, Idx, Ele) -&gt; lists:sublist(List, 1, Idx - 1) ++ [Ele] ++ lists:sublist(List, Idx + 1, length(List)).

    dont(Vote, Quorum) -&gt; dont([{X, 1, X} || X &lt;- Vote], lists:duplicate(length(Vote), 0), Quorum).

    dont(_, Seat, 0) -&gt; Seat;
    dont(Vote, Seat, Quorum) -&gt;
        Max = search(fun({X, _, _}, {Y, _, _}) -&gt; X &lt; Y end, Vote),
        {_, B, C} = lists:nth(Max, Vote),
        NewVote = replace(Vote, Max, {C / (B + 1), B + 1, C}),
        NewSeat = replace(Seat, Max, lists:nth(Max, Seat) + 1),
        dont(NewVote, NewSeat, Quorum - 1).
  :tags:
  - ErlangOTP_R10B-10
  :references:
    :url: 
    :title: 
- :id: '5148'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5148
  :user_name: saws
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/642/
  :language: ActionScript
  :time: 2008/01/03 14:33 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ハッシュを利用しました.</p>\n\n\t"
  :code: "VOTE_ARY = [123, 4, 56, 78]\nN = 100\nclass Hash\n  def gen_vote(ary)\n
    \   key = 'a'\n    ary.each{|x| self[key.succ!] = x}\n  end\n  def gen_vote_list\n
    \   keys.each{|key|\n      2.upto(N){|i| self[\"#{key}#{i}\"] = self[key].quo(i)}\n
    \   }  \n  end\nend\nvotes, counter = Hash.new, Hash.new\nvotes.gen_vote(VOTE_ARY)\nvotes.gen_vote_list\nvotes.keys.sort{|a,
    b| -1*(votes[a] &lt;=&gt; votes[b])}.\n  map{|x| x.match(/^([a-zA-Z]+)/)[0]}[0..N-1].\n
    \ each{|key| eval(\"counter[key]#{counter.has_key?(key) ? '+' : ''}=1\")}\np counter.values\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5225'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5225
  :user_name: kh
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/654/
  :language: D
  :time: 2008/01/08 09:25 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    private import std.stdio;

    uint[] dhondt(uint[] votes, uint limit) {
        auto seats = new uint[votes.length];
        foreach(_; 0 .. limit) {
            auto quotients = new real[votes.length];
            foreach(i, ref e; quotients) {
                e = votes[i] / (seats[i] + 1.0);
            }
            find_largest: foreach(i, e; quotients) {
                foreach(f; quotients[i .. $]) {
                    if(f &gt; e) continue find_largest;
                }
                seats[i]++;
                break;
            }
        }
        return seats;
    }

    void main() {
        writeln([123, 4, 56, 78].dhondt(100)); // [48 1 21 30]
    }
  :tags:
  - D_2.0
  :references:
    :url: 
    :title: 
- :id: '5233'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5233
  :user_name: saws
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/642/
  :language: Ruby
  :time: 2008/01/08 15:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ハッシュを利用しました</p>\n\n\t"
  :code: "VOTE_ARY = [123, 4, 56, 78]\nN = 100\nclass Hash\n  def gen_vote(ary)\n
    \   key = 'a'\n    ary.each{|x| self[key.succ!] = x}\n  end\n  def gen_vote_list\n
    \   keys.each{|key|\n      2.upto(N){|i| self[\"#{key}#{i}\"] = self[key].quo(i)}\n
    \   }  \n  end\nend\nvotes, counter = Hash.new, Hash.new\nvotes.gen_vote(VOTE_ARY)\nvotes.gen_vote_list\nvotes.keys.sort{|a,
    b| -1*(votes[a] &lt;=&gt; votes[b])}.\n  map{|x| x.match(/^([a-zA-Z]+)/)[0]}[0..N-1].\n
    \ each{|key| eval(\"counter[key]#{counter.has_key?(key) ? '+' : ''}=1\")}\np counter.values\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5854'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5854
  :user_name: 匿名
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/4/
  :language: Erlang
  :time: 2008/02/27 04:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">計算結果をタプルのリストに入れ、ソートして前から定数分取り出すという素直な実装のつもり。\r\n\r\n1&gt;
    doukaku26:dont(100, [123, 4, 56, 78]).\r\n[48,1,21,30]</pre>\n\t"
  :code: |
    -module(doukaku26).
    -author('cooldaemon@gmail.com').

    -export([dont/2]).

    dont(Quorum, Votes) -&gt;
      count(calc(Quorum, Votes), lists:duplicate(length(Votes), 0)).

    calc(Quorum, Votes) -&gt;
      {Tuples, _VoutesLength} = lists:mapfoldl(fun (Vote, Index) -&gt;
        {
          lists:map(fun (Count) -&gt;
            {Index, Vote / Count}
          end, lists:seq(1, Quorum)),
          Index + 1
        }
      end, 0, Votes),
      {Results, _Tails} = lists:split(
        Quorum,
        lists:reverse(lists:keysort(2, lists:flatten(Tuples)))
      ),
      Results.

    count([{Index, _CalcResult} | Tuples], Results) -&gt;
      {Heads, _Tails} = lists:split(Index, Results),
      count(
        Tuples,
        lists:flatten([
          Heads,
          lists:nth(Index + 1, Results) + 1,
          lists:nthtail(Index + 1, Results)
        ])
      );
    count([], Results) -&gt; Results.
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5939'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5939
  :user_name: まさぽん
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/711/
  :language: Arc
  :time: 2008/03/05 08:27 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">実行例:\r\narc&gt; (donto 100 '(123 4 56 78))\r\n(48
    1 21 30)\r\n\r\n2 行目の (let x ...) は scheme でいう (make-list ...)\r\nの代替。</pre>\n\t"
  :code: |
    (def donto (pool votes)
      (with (ls (let x nil (repeat (len votes) (push 0 x)) x)
              v (copy votes))
        ((rfn lp (p)
           (if (is 0 p)
               ls
               (let i (pos (apply max v) v)
                 (= (v i) (/ (votes i) (+ 1 (++ (ls i)))))
                 (lp (- p 1)))))
         pool)))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '5949'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/5949
  :user_name: まさぽん
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/711/
  :language: Arc
  :time: 2008/03/05 13:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ちょっと手直し。</p>\n\n\t"
  :code: |
    (def donto (pool votes)
      (with (ls (let x nil (repeat (len votes) (push 0 x)) x)
              v (copy votes))
        (repeat pool
          (let i (pos (apply max v) v)
            (= (v i) (/ (votes i) (+ 1 (++ (ls i)))))))
        ls))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '7216'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/7216
  :user_name: genzou
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/793/
  :language: Groovy
  :time: 2008/08/19 12:59 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>wikipediaの数式を元に作成しました。\n変数v、sもそのままです。</p>\n<p><a class=\"reference\"
    href=\"/web/20100421170215/http://ja.wikipedia.org/wiki/%E3%83%89%E3%83%B3%E3%83%88%E5%BC%8F\">http://ja.wikipedia.org/wiki/%E3%83%89%E3%83%B3%E3%83%88%E5%BC%8F</a></p>\n\n\t"
  :code: "println dont([ 123, 4, 56, 78 ], 100)\n\ndef dont( vlist, countOfSheet ){\n
    \   def groups = vlist.collect{ [ v:it, s:0 ] }\n\n    countOfSheet.times{\n        def
    map = groups.max{ it.v/(it.s + 1) }\n        map.s++\n    }\n    \n    groups.collect{
    it.s }\n}\n"
  :tags:
  - groovy
  :references:
    :url: 
    :title: 
- :id: '8044'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/8044
  :user_name: 99yen
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/591/
  :language: 
  :time: 2008/11/16 01:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ソートで。</p>\n\n\t"
  :code: |
    定数=100
    得票数="123,4,56,78"を","で区切る
    定数で得票数をドント分配して表示

    ●ドント分配(定数で得票数を)
        TMPとは配列
        Iとは整数。Jとは整数
        RESULTとは配列
        (得票数の要素数)回、RESULT[回数-1]=0
        Iで1から定数まで繰り返す
            得票数を反復
                J=TMPの要素数
                TMP[J][0]=回数-1
                TMP[J][1]=対象/I
        TMPの1を表数値ソート
        IでJから(J+1-定数)まで繰り返す
            RESULT[TMP[I][0]]に1を直接足す
        RESULTで戻る
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '8151'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/8151
  :user_name: taninsw
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/973/
  :language: Haskell
  :time: 2008/12/13 06:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>小数点以下を切り捨てたら結果がちょっと違ってしまいました</p>\n\n\t"
  :code: "import List\n\nteisu  = 100\ntokuhyo = [123,4,56,78]\n\nzaseki = sort $
    map fst $ take teisu $ sortBy (\\a b -&gt; compare (snd b) (snd a)) $ \n        zip
    (cycle [1..4]) $ concat [map (\\x-&gt;div x  d) tokuhyo | d &lt;- [1..teisu]]\n
    \       \n\nzasekiCount = map (\\x-&gt;length $ filter(==x) zaseki) [1..length
    tokuhyo] \n--[41,2,28,29]\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '9836'
  :parent_id: '26'
  :url: http://ja.doukaku.org/comment/9836
  :user_name: taka_2
  :user_url: /web/20100421170215/http://ja.doukaku.org/user/1132/
  :language: Other
  :time: 2010/01/19 02:34 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: "Option Explicit\n\ndim seatNum, i, votes, v, maxIndexes, dontedArray, result\n\n'
    計算する条件(100席、得票数はそれぞれ、123, 4, 56, 78)\nseatNum = 100\nvotes = Array(123, 4, 56,
    78)\n\n' メイン\n' 獲得議席数(0で初期化)\nDim seats()\nReDim seats(UBound(votes))\n\nFor i=0
    to UBound(seats)\n    seats(i) = 0\nNext\n\n' ドント方式の計算を行う\nDo\n    If seatNum
    &lt;= 0 Then\n        Exit Do\n    End If\n\n    dontedArray = getDont(votes,
    seats)\n    maxIndexes = getMaxIndexes(dontedArray)\n    For Each v In maxIndexes\n
    \       seats(v) = seats(v) + 1\n        seatNum = seatNum - 1\n    Next\nLoop\n\n'
    結果を表示\nresult = \"\"\nFor Each v In seats\n    If result &lt;&gt; \"\" Then\n
    \       result = result &amp; \",\"\n    End If\n    result = result &amp; v\nNext\nWScript.Echo
    result\n\n' 配分を計算する(得票数 / (獲得議席数 + 1))\nFunction getDont(votes, seats)\n    Dim
    aaa(), i\n    ReDim aaa(UBound(votes))\n\n    For i=0 to UBound(aaa)\n        aaa(i)
    = votes(i) / (seats(i) + 1)\n    Next\n\n    getDont = aaa\nEnd Function\n\n'
    配分のうち最も大きいものを抽出する(同点の場合は複数抽出される場合もあり)\nFunction getMaxIndexes(arr)\n    Dim max,
    i, maxIndexes()\n\n    max = -1\n    \n    For i=0 to UBound(arr)\n        If
    arr(i) &gt; max Then\n            max = arr(i)\n            ReDim maxIndexes(0)\n
    \           maxIndexes(0) = i\n        ElseIf arr(i) = max Then\n            ReDim
    Preserve maxIndexes(UBound(maxIndexes) + 1)\n            maxIndexes(UBound(maxIndexes))
    = i\n        End If\n    Next\n\n    getMaxIndexes = maxIndexes\nEnd Function\n"
  :tags:
  - VBScript
  :references:
    :url: 
    :title: 
