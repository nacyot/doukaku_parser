---
:id: '291'
:title: 文字列で＋を表示する
:comments:
- :id: '10078'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10078
  :user_name: pooq
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/606/
  :language: 
  :time: 2010/01/31 12:32 GMT
  :vote_count: '5'
  :vote_score: '5'
  :body: "\r\n\t  <pre class=\"compact\">与えられた文字列で＋のかたちを表示するプログラムをかいてください。\r\nサンプル入力：\r\ndoukaku\r\n\r\nサンプル出力：\r\n
    \      doukakud\r\n       u      o\r\n       k      u\r\n       a      k\r\n       k
    \     a\r\n       u      k\r\n       o      u\r\ndoukakud      doukakud\r\nu                    o\r\nk
    \                   u\r\na                    k\r\nk                    a\r\nu
    \                   k\r\no                    u\r\ndukakuod      dukakuod\r\n
    \      u      o\r\n       k      u\r\n       a      k\r\n       k      a\r\n       u
    \     k\r\n       o      u\r\n       dukakuod\r\n</pre>\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10080'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10080
  :user_name: あにす
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/504/
  :language: C
  :time: 2010/02/01 12:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>こういうことかしら？</p>\n\n\t"
  :code: |
    using System;
    using System.Linq;

    class Program {
        static void Main(string[] args) {
            string loop = args[0] + args[0][0];
            string reverse = new string(loop.ToCharArray().Reverse().ToArray());

            Console.WriteLine(new string(' ', args[0].Length) + loop);

            hoge(args[0]);

            Console.WriteLine(loop + new string(' ', args[0].Length - 1) + loop);

            for(int i = 0; i &lt; args[0].Length - 1; i++) {
                Console.WriteLine(args[0][args[0].Length - (i + 1)] + new string(' ', args[0].Length * 3 - 1) + args[0][i + 1]);
            }

            Console.WriteLine(reverse + new string(' ', args[0].Length - 1) + reverse);

            hoge(args[0]);

            Console.WriteLine(new string(' ', args[0].Length) + reverse);
        }

        private static void hoge(string arg) {
            for(int i = 0; i &lt; arg.Length - 1; i++) {
                Console.WriteLine(new string(' ', arg.Length) + arg[arg.Length - (i + 1)] + new string(' ', arg.Length - 1) + arg[i + 1]);
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10081'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10081
  :user_name: mikiT
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1140/
  :language: awk
  :time: 2010/02/01 09:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>めっちゃベタに書いてしまった。\n長さ1の文字列を与えられた時の例外処理もしてません。</p>\n\n\t"
  :code: |
    {
        j = 1;
        rev = "";
        l = length($0);
        for(i = 1; i &lt;= l; i++){
            ch[i] = substr($0, i, 1);
        }
        for(i = l; i &gt; 0; i--){
            rev = rev ch[i];
        }
        line[j++] = sprintf("%*s%s%c", l, " ", $0, ch[1]);
        for(i = 2; i &lt;= l; i++){
            line[j++] = sprintf("%*s%c%*s%c", l, " ", ch[l - i + 2], l - 1, " ", ch[i]);
        }
        line[j++] = sprintf("%s%c%*s%s%c", $0, ch[1], l - 1, " ", $0, ch[1]);
        for(i = 2; i &lt;= l; i++){
            line[j++] = sprintf("%c%*s%c", ch[l - i + 2], l * 3 - 1, " ", ch[i]);
        }
        line[j++] = sprintf("%c%s%*s%c%s", ch[1], rev, l - 1, " ", ch[1], rev);
        for(i = 2; i &lt;= l; i++){
            line[j++] = sprintf("%*s%c%*s%c", l, " ", ch[l - i + 2], l - 1, " ", ch[i]);
        }
        line[j++] = sprintf("%*s%c%s", l, " ", ch[1], rev);
        for(i = 1; i &lt; j; i++){
            print line[i];
        }
    }
  :tags:
  - awk
  :references:
    :url: 
    :title: 
- :id: '10082'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10082
  :user_name: turugina
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/760/
  :language: Perl
  :time: 2010/02/01 10:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  座標計算めんどくさいです\n\t"
  :code: "use strict;\nuse warnings;\n\nif (!@ARGV || length($ARGV[0]) &lt; 2) {\n
    \   print \"usage: $0 &lt;any word(more than 2-chars)&gt;\\n\";\n    exit 0;\n}\n\nmy
    $w = shift;\nmy $l = length($w);\nmy $ll = $l * 3 + 1;\nmy $c = (' ' x $ll . \"\\n\")
    x $ll;\n\nmy @w = split //, $w;\nfor my $i (0 .. $l-1) {\n    substr($c, $l+$i,
    1) =\n    substr($c, ($ll+1)*$l+$i, 1) =\n    substr($c, ($ll+1)*$l+($l*2)+$i,
    1) =\n    substr($c, ($ll+1)*$l*2+$l-$i, 1) =\n    substr($c, ($ll+1)*$l*2+($l*3)-$i,
    1) =\n    substr($c, -2 - $l - $i, 1) =\n    substr($c, ($ll+1)*$i+$l*2, 1) =\n
    \   substr($c, ($ll+1)*($l+$i)+$l*3, 1) =\n    substr($c, ($ll+1)*($l*2+$i)+$l*2,
    1) = \n    substr($c, ($ll+1)*($l*3-$i)+$l, 1 ) = \n    substr($c, ($ll+1)*($l*2-$i),
    1) = \n    substr($c, ($ll+1)*($l-$i)+$l, 1) = $w[$i];\n}\n\nprint $c;\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10083'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10083
  :user_name: T_GYOUTEN
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1107/
  :language: Other
  :time: 2010/02/02 07:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>LOGO風に</p>\n\n\t"
  :code: "type NextTurnDirection =\n    |Right\n    |Left\nlet cdr (dx,dy) = ((-1)*dy,dx)
    //cdrはchangeDirectionRightの略\nlet cdl (dx,dy) = (dy,(-1)*dx) //cdlはchangeDirectionLeftの略\n\nlet
    doWork (s:string) =\n    let len = s.Length\n    let canvasArr = Array2D.create
    (3*len + 1) (3*len + 1) ' ' \n    let startPos = (len,0)\n    let getNextTrunDirection
    turnN = \n        if turnN % 3 = 1 then Left else Right //3回に1回左折\n    let rec
    drawCanvas stepNum turnNum (x,y) (dx,dy) cbfvosp =\n       // cbfvospはcanBeFirstVisitOnStartPointの略\n
    \      if (x,y) = startPos &amp;&amp; cbfvosp = false then\n            ()\n       else\n
    \         canvasArr.[x,y] &lt;- s.[stepNum] \n          match (stepNum,turnNum)
    with\n          |(sn,tn)  when sn = len - 1 &amp;&amp; (getNextTrunDirection tn)
    = Right\n                -&gt;  drawCanvas 0 (tn + 1) (x+dx,y+dy) (cdr (dx,dy))
    false\n          |(sn,tn)  when sn = len - 1 &amp;&amp; (getNextTrunDirection
    tn) = Left\n                -&gt;  drawCanvas 0 (tn + 1) (x+dx,y+dy) (cdl (dx,dy))
    false   \n          |(sn,tn)\n                -&gt;  drawCanvas (stepNum+1) tn
    (x+dx,y+dy) (dx,dy) false\n    drawCanvas 0 0  startPos (1,0) true  \n    for
    i in 0 .. 3*len do\n        printfn \"\"\n        for j in 0 .. 3*len do\n            printf
    \"%c\" canvasArr.[j,i]\n\nopen System\n\n[&lt;STAThread()&gt;] \n[&lt;EntryPoint&gt;]
    \nlet main(args) = \n    if (args.Length = 0 || args.[0].Length &lt;2) then\n
    \       printf \"引数が不正です。\"\n    else\n        doWork args.[0]\n    0\n"
  :tags:
  - F#
  - NtMsGmnqGsFIhtPTlp
  - PgSABVbMVKcItBUXOtR
  :references:
    :url: 
    :title: 
- :id: '10084'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10084
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2010/02/02 09:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>表示範囲毎に条件式をまとめました．\n条件式をまとめることのできる部分はまとめようと頑張りましたが，途中で諦めてしまいました．ですのでこんなに条件文が長いwww</p>\n\n\t"
  :code: "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint
    main( int argc, char *argv[] )\n{\n    if( argc != 2 ) {\n        fprintf( stderr,
    \"usage: %s string\\n\", argv[0] );\n        exit( EXIT_FAILURE );\n    }\n\n
    \   int length = strlen( argv[1] );  /* get length of input string */\n    int
    i, j;\n    for( j = 0; j &lt;= length * 3; j++ ) {\n        for( i = 0; i &lt;=
    length * 3; i++ ) {\n            /* region A */\n            if( j == 0 &amp;&amp;
    \n                length &lt;= i &amp;&amp; i &lt;= length * 2 - 1 ) \n                printf(
    \"%c\", argv[1][ i - length  ] );\n            /* region B, region F */\n            else
    if( i == length * 2 &amp;&amp;\n                     ( ( 0 &lt;= j &amp;&amp;
    j &lt;= length - 1 ) || ( length * 2 &lt;= j &amp;&amp; j &lt;= length * 3 - 1
    ) ) )\n                printf( \"%c\", argv[1][j - ( j / ( length * 2 ) ) * length
    * 2] );\n            /* region C */\n            else if( j == length &amp;&amp;\n
    \                    length * 2 &lt;= i &amp;&amp; i &lt;= length * 3 - 1 )\n
    \               printf( \"%c\", argv[1][i - length * 2] );\n            /* region
    D */\n            else if( i == length * 3 &amp;&amp;\n                     length
    &lt;= j &amp;&amp; j &lt;= length * 2 - 1 )\n                printf( \"%c\", argv[1][j
    - length] );\n            /* region E */\n            else if( j == length * 2
    &amp;&amp;\n                     length * 2 + 1 &lt;= i &amp;&amp; i &lt;= length
    * 3 )\n                printf( \"%c\", argv[1][length * 3 - i ] );\n            /*
    region G */\n            else if( j == length * 3 &amp;&amp;\n                     length
    + 1 &lt;= i &amp;&amp; i &lt;= length * 2 )\n                printf( \"%c\", argv[1][
    length * 2 - i] );\n            /* region H */\n            else if( i == length
    &amp;&amp;\n                     length * 2 + 1 &lt;= j &amp;&amp; j &lt;= length
    * length * 3 )\n                printf( \"%c\", argv[1][ length * 3 - j ] );\n
    \           /* region I */\n            else if( j == length * 2 &amp;&amp;\n
    \                    1 &lt;= i &amp;&amp; i &lt;= length )\n                printf(
    \"%c\", argv[1][length - i] );\n            /* region J */\n            else if(
    i == 0 &amp;&amp;\n                     length + 1 &lt;= j &amp;&amp; j &lt;=
    length * 2 )\n                printf( \"%c\", argv[1][length * 2 - j] );\n            /*
    region K */\n            else if( j == length &amp;&amp;\n                     0
    &lt;= i &amp;&amp; i &lt;= length - 1 )\n                printf( \"%c\", argv[1][i]
    );\n            /* region L */\n            else if( i == length &amp;&amp;\n
    \                    1 &lt;= j &amp;&amp; j &lt;= length )\n                printf(
    \"%c\", argv[1][length - j ] );\n            else\n                printf( \"
    \" );\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10085'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10085
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2010/02/02 13:01 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: "public class Doukaku {\n    public static void main(String[] args) {\n        String
    s = \"doukaku\";\n        int len = s.length();\n        for (int r = 0; r &lt;=
    len * 3; r++) {\n            for (int c = 0; c &lt;= len * 3; c++) {\n                System.out.print(getChar(r,
    c, s));\n            }\n            System.out.println();\n        }\n    }\n
    \   \n    static char getChar(int r, int c, String s) {\n        int l0 = 0, l1
    = s.length(), l2 = l1 * 2, l3 = l1 * 3;\n        boolean cc = c &gt; l1 &amp;&amp;
    c &lt; l2, rr = r &gt; l1 &amp;&amp; r &lt; l2;\n        return r == l0 &amp;&amp;
    \ cc || r == l1 &amp;&amp; !cc ? charAt(s, c, false)\n             : r == l2 &amp;&amp;
    !cc || r == l3 &amp;&amp;  cc ? charAt(s, c, true)\n             : c == l0 &amp;&amp;
    \ rr || c == l1 &amp;&amp; !rr ? charAt(s, r, true)\n             : c == l2 &amp;&amp;
    !rr || c == l3 &amp;&amp;  rr ? charAt(s, r, false)\n             : ' ';\n    }\n
    \   \n    static char charAt(String s, int i, boolean rev) {\n        return s.charAt((rev
    ? s.length() * 3 - i : i) % s.length());\n    }\n\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10086'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10086
  :user_name: hoge
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1111/
  :language: C
  :time: 2010/02/02 15:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Cらしく、ポインタテーブルで...</p>\n\n\t"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;

    void outputs(char *input_word)
    {
        int unit = strlen(input_word);
        int rows = unit * 3 + 1, cols = unit * 3 + 2;
        int table_size = rows * cols;
        char ** const table = malloc(sizeof(char*) * rows + sizeof(char) * table_size);
        int ptr_table_size = (unit * 3) * 4;
        char ** const ptr_table = malloc(sizeof(char*) * ptr_table_size);
        int index = 0;
        int i, j;

        for(i = 0; i &lt; rows; i++) /* 初期化 */
            table[i] = (char*)(table + rows) + i * cols;

        for(i = 0; i &lt; rows; table[i][j] = '\0' ,i++)
            for(j = 0; j &lt; cols - 1; j++)
                table[i][j] = ' ';

    #define SLIDE_IF_ODD_(x)        ((x) / unit % 2 ? unit : 0)
        for(i = 0; i &lt; rows - 1; index++, i++){ /* 下準備 */
            ptr_table[index]                      = &amp;table[i    ][unit * 2 + SLIDE_IF_ODD_(i)];
            ptr_table[ptr_table_size - 1 - index] = &amp;table[i + 1][unit     - SLIDE_IF_ODD_(i)];
        }

        for(j = 0; j &lt; cols - 2; index++, j++){
            ptr_table[index]                      = &amp;table[unit     - SLIDE_IF_ODD_(j)][j    ];
            ptr_table[ptr_table_size - 1 - index] = &amp;table[unit * 2 + SLIDE_IF_ODD_(j)][j + 1];
        }
    #undef SLIDE_IF_ODD_

        for(i = 0; i &lt; ptr_table_size; i++) /* 書き込み */
            *ptr_table[i] = *(input_word + i % unit);

        for(i = 0; i &lt; rows; i++) /* 出力 */
            puts(table[i]);

        free(table);
        free(ptr_table);
    }

    int main(int argc, char **argv)
    {
        char buf[BUFSIZ];

        puts("Input a word:");

        if(fgets(buf, _countof(buf), stdin)){
            int length = strlen(buf);

            if(buf[length - 1] == '\n'){
                buf[length - 1] = '\0';
                outputs(buf);
            }
        }

        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10088'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10088
  :user_name: sumim
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2010/02/03 02:09 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Squeak Smalltalk で。</p>\n\n\t"
  :code: |
    | str map up down left right pos |
    str := 'doukaku'.

    up := (down := 1 @ 0) negated.
    left := (right := 0 @ 1) negated.
    map := Matrix new: str size * 3 + 1 element: Character space.

    pos := 1 @ str size + right.
    {right. down. right. down. left. down. left. up. left. up. right. up} do: [:direction |
        str do: [:chr | map at: pos x at: pos y put: chr. pos := pos + direction]].

    World findATranscript: nil.
    (1 to: map rowCount) do: [:nrow |
        Transcript cr; show: ('', (map atRow: nrow)) withoutTrailingBlanks]
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '10090'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10090
  :user_name: tktc
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1141/
  :language: Scala
  :time: 2010/02/03 03:07 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  もっとFunctionalに書きたいのですが…。\r\n\n\t"
  :code: "class Cross(val src: String) {\n\n  // 角の凹みの数\n  val dent = 1\n\n  // 格子の数\n
    \ val grid = dent * 2 + 1\n\n  // 一辺の長さ\n  val side = src.length * grid + 1\n\n
    \ // 描画エリア\n  val area:Array[Array[char]] = \n    for (row &lt;- ((\" \" * side
    +\"\\n\") * side).split(\"\\n\"))\n      yield row.toCharArray\n\n  // 水平描画が右向き:true/左向き:false\n
    \ var hAhead = true\n\n  // 垂直描画が下向き:true/上向き:false\n  var vAhead = true\n\n  //
    描画開始位置と描画方向を表現するクラス。\n  case class Direction(val posX: Int, val posY: Int, val
    heading: Int)\n\n  // 最初の描画位置、上段、中央の格子から、水平：右向きに描画する。\n  val start = Direction(grid
    / 2, 0, Cross.HeadingRight)\n\n  // 描画開始\n  write(start)\n\n  // 描画メソッド\n  def
    write(d: Direction) :Unit = {\n    val x = d.posX * src.length\n    val y = d.posY
    * src.length\n    \n    d.heading match {\n      case Cross.HeadingRight =&gt;\n
    \      for (i &lt;- x to x + src.length -1) {\n         area(y)(i) = src.charAt(i
    - x)\n       }\n      case Cross.HeadingBottom =&gt;\n       for (i &lt;- y to
    y + src.length -1) {\n         area(i)(x) = src.charAt(i - y)\n       }\n      case
    Cross.HeadingLeft =&gt;\n       for (i &lt;- (x- src.length + 1 to x).reverse)
    {\n         area(y)(i) = src.charAt(x - i)\n       }\n      case Cross.HeadingTop
    =&gt;\n       for (i &lt;- (y - src.length +1 to y).reverse) {\n         area(i)(x)
    = src.charAt(y - i)\n       }\n    }\n    var next = this.next(d) \n    if (next
    != start) {\n      write(next)\n    }\n  }\n\n  // 次の描画開始位置と描画方向を返す。\n  def next(d:Direction)
    = {\n    d.heading match {\n      case Cross.HeadingRight =&gt;\n       if (d.posX
    + 2 &gt; grid)\n         hAhead = false\n       Direction(d.posX + 1, d.posY,
    if (vAhead) Cross.HeadingBottom else Cross.HeadingTop )\n      case Cross.HeadingBottom
    =&gt;\n       if (d.posY + 2 &gt; grid)\n         vAhead = false\n       Direction(d.posX,
    d.posY + 1, if (hAhead) Cross.HeadingRight else Cross.HeadingLeft)\n      case
    Cross.HeadingLeft =&gt;\n       if (d.posX - 2 &lt; 0 )\n         hAhead = true\n
    \      Direction(d.posX - 1, d.posY, if (vAhead) Cross.HeadingBottom else Cross.HeadingTop)\n
    \     case Cross.HeadingTop =&gt;\n       if (d.posY - 2 &lt; 0 )\n         vAhead
    = true\n       Direction(d.posX, d.posY - 1, if (hAhead) Cross.HeadingRight else
    Cross.HeadingLeft)\n    }\n  }\n\n  // コンソールに表示する。\n  def show {\n    for(row
    &lt;- area)\n      println(new String(row))\n  }\n}\n\n\nobject Cross {\n  val
    HeadingRight = 0 \n  val HeadingBottom = 1\n  val HeadingLeft = 2  \n  val HeadingTop
    = 3   \n}\n\nobject RunCross {\n  def main(args: Array[String]): Unit = {\n    val
    src = if (args.length &gt;= 1) args(0) else \"doukaku\"\n    val cross = new Cross(src)\n
    \   cross.show\n    \n  }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10094'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10094
  :user_name: pooq
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/606/
  :language: J
  :time: 2010/02/04 08:28 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">   f '123'\r\n   1231\r\n   3  2\r\n   2  3\r\n1231
    \ 1231\r\n3        2\r\n2        3\r\n1321  1321\r\n   3  2\r\n   2  3\r\n   1231\r\n
    \  \r\n   f 'world'\r\n     worldw\r\n     d    o\r\n     l    r\r\n     r    l\r\n
    \    o    d\r\nworldw    worldw\r\nd              o\r\nl              r\r\nr              l\r\no
    \             d\r\nwdlrow    wdlrow\r\n     d    o\r\n     l    r\r\n     r    l\r\n
    \    o    d\r\n     worldw\r\n</pre>\n\t"
  :code: |
    f=:3 :0
       P=.{.y
       TB=.,.}.y
       BT=.,.|.TB
       EL=.&lt;:#y
       SP=.' '
       a=.y,P,(EL#SP),y,P
       smoutput ((,~#y)$SP),.(y,P),BT,.((,~EL)$SP),.TB
       smoutput (a,BT,.((EL,&lt;:3*#y)$SP),.TB),|.a
       smoutput ((,~#y)$SP),.(BT,.((,~EL)$SP),.TB),y,P
    )
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10096'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10096
  :user_name: mattsan
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/833/
  :language: C
  :time: 2010/02/04 06:37 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  \n\t"
  :code: |
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    #include &lt;algorithm&gt;

    struct point
    {
        int x;
        int y;

        point&amp; operator += (const point&amp; other)
        {
            x += other.x;
            y += other.y;
            return *this;
        }
    };

    static const point vs[] =
    {
        {  1,  0 }, {  0,  1 }, {  1,  0 }, {  0,  1 },
        { -1,  0 }, {  0,  1 }, { -1,  0 }, {  0, -1 },
        { -1,  0 }, {  0, -1 }, {  1,  0 }, {  0, -1 }
    };

    void doukaku291(const std::string&amp; s)
    {
        std::vector&lt;std::string&gt; v(s.size() * 3 + 1, std::string(s.size() * 3 + 1, ' '));
        point p = { s.size(), 0 };
        for(int i = 0; i &lt; 12; ++i)
        {
            for(std::string::const_iterator it = s.begin(); it != s.end(); ++it)
            {
                v[p.y][p.x] = *it;
                p += vs[i];
            }
        }
        std::copy(v.begin(), v.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "¥n"));
    }

    int main(int argc, char* argv[])
    {
        doukaku291("doukaku");

        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10098'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10098
  :user_name: mattsan
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/833/
  :language: Haskell
  :time: 2010/02/04 14:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>ちょっと…かなり？…ブサイクかなぁ。</p>\n\n\t"
  :code: "doukaku291 s = \n  mapM_ (\\(row, cols) -&gt; putStrLn $ map (\\col -&gt;
    ch col row) cols) field\n    where\n      right = ( 1,  0)\n      left  = (-1,
    \ 0)\n      down  = ( 0,  1)\n      up    = ( 0, -1)\n\n      ds   = [ right,
    down, right, down, left, down, left, up, left, up, right, up ]\n      ss   = concat
    $ map (\\(s, d) -&gt; zip (repeat d) s) $ zip (repeat s) ds\n      line = toLine
    (length s, 0) ss\n        where\n          toLine _ [] = []\n          toLine
    (sx, sy) (((x, y), c):ds) = ((sx, sy), c):(toLine (sx + x, sy + y) ds)\n\n      field
    = zip [0..] $ replicate ((length s) * 3 + 1) $ take ((length s) * 3 + 1) [0..]\n\n
    \     ch row col = case lookup (col, row) line of\n                     Just c
    \ -&gt; c\n                     Nothing -&gt; ' '\n\nmain = doukaku291 \"doukaku\"\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10105'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10105
  :user_name: kozima
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/164/
  :language: Common
  :time: 2010/02/05 09:50 GMT
  :vote_count: '5'
  :vote_score: '5'
  :body: "\n\t  <p>最初にこんなリストを作って，</p>\n<pre class=\"literal-block\">\n(\"   abc    \"\n
    \"          \"\n \"          \"\n \"abc   abc \"\n \"          \"\n \"          \"\n
    \"          \"\n \"          \"\n \"          \"\n \"          \")\n</pre>\n<p>90°ずつ回転させたのと合わせました。</p>\n<pre
    class=\"literal-block\">\n   abca\n   c  b\n   b  c\nabca  abca\nc        b\nb
    \       c\nacba  acba\n   c  b\n   b  c\n   acba\n</pre>\n\n\t"
  :code: |
    (defun rotate (m) (apply #'map 'list #'vector (reverse m)))

    (defun merge-line (&amp;rest lines)
      (apply #'map 'string
             (lambda (&amp;rest chars)
               (or (find #\Space chars :test #'char/=)
                   #\Space))
             lines))

    (defun merge-matrix (&amp;rest matrices)
      (apply #'mapcar #'merge-line matrices))

    (defun write-cross (s)
      (let* ((m (let* ((n (length s))
                       (empty (format nil "~V@T~V@T~V@T " n n n))
                       (line1 (format nil "~V@T~A~V@T " n s n))
                       (line2 (format nil "~A~V@T~A " s n s)))
                  `(,line1 ,@(make-list (1- n) :initial-element empty)
                    ,line2 ,@(make-list (* 2 n) :initial-element empty))))
             (m1 (rotate m))
             (m2 (rotate m1))
             (m3 (rotate m2)))
        (mapc #'write-line (merge-matrix m m1 m2 m3))))
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10106'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10106
  :user_name: Lost_dog
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1129/
  :language: Haskell
  :time: 2010/02/05 12:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>Lost_dogです。この前はログインするの忘れましたが、今回は大丈夫です。</p>\n<p>この問題をあえて汎用的にするならば、コンソール画面に方向を指定してテキストを描画するっていう感じかなーということで書きました。コードは若干長くなりましたけど、やってることは単純なので。。</p>\n<p>STArrayとかの使い方は、参考ページを見ながら書きました。</p>\n<p>STArrayを使ったら、なんか型が意味不明になってきて、これにIOとかRandomとか入ってきたら、なにがなんだか。。そこは上手に分離してコーディングしろっていうことなのかな・・・</p>\n<p>配列を更新する処理は、やっぱハスケラーにとっては歯がゆいところなのかなぁ・・・</p>\n\n\t"
  :code: "module Canvas where\nimport Control.Monad.ST\nimport Data.Array.ST\nimport
    Data.Array\n\nmain = putStrLn $ unlines $ map (dropWhileR (==' ')) \n       $
    splitsAt (3*n+1) $ elems $ runST $ showPlus xs \n  where xs = \"doukaku\"\n        n
    \ = length xs\n\ndata Direction = Up | Down | Left | Right deriving Eq\n\nshowPlus
    xs = let n = length xs in do \n  a &lt;- newArray ((0,0),(3*n,3*n)) ' ' :: ST
    s (STArray s (Int,Int) Char)\n  writeText a (0,n)     Canvas.Right xs\n  writeText
    a (0,2*n)   Canvas.Down  xs\n  writeText a (n,2*n)   Canvas.Right xs\n  writeText
    a (n,3*n)   Canvas.Down  xs\n  writeText a (2*n,3*n) Canvas.Left  xs\n  writeText
    a (2*n,2*n) Canvas.Down  xs\n  writeText a (3*n,2*n) Canvas.Left  xs\n  writeText
    a (3*n,n)   Canvas.Up    xs\n  writeText a (2*n,n)   Canvas.Left  xs\n  writeText
    a (2*n,0)   Canvas.Up    xs\n  writeText a (n,0)     Canvas.Right xs\n  writeText
    a (n,n)     Canvas.Up    xs\n  freeze a\n\nwriteText _ (_,_) _ []     = return
    ()\nwriteText a (x,y) d (t:ts) = do\n  r &lt;- getBounds a\n  if inRange r (x,y)
    \n    then do writeArray a (x,y) t \n            case d of\n              Canvas.Up
    \   -&gt; writeText a (pred x,y) d ts\n              Canvas.Down  -&gt; writeText
    a (succ x,y) d ts\n              Canvas.Left  -&gt; writeText a (x,pred y) d ts\n
    \             Canvas.Right -&gt; writeText a (x,succ y) d ts\n    else return
    ()\n\ndropWhileR p = reverse.dropWhile p.reverse\n\nsplitsAt n [] = []\nsplitsAt
    n xs = ys : splitsAt n zs where (ys,zs) = splitAt n xs\n"
  :tags: []
  :references:
    :url: /web/20100525170342/http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
    :title: Haskell/Hierarchical libraries/Arrays
- :id: '10110'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10110
  :user_name: tsubo
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1106/
  :language: Scala
  :time: 2010/02/06 20:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">図形の作り方に多少汎用性を持たせてみました。\r\n\r\n結果：\r\n        dounano?d
    \       \r\n        ?       o        \r\n        o       u        \r\n        n
    \      n        \r\n        a       a        \r\n        n       n        \r\n
    \       u       o        \r\n        o       ?        \r\ndounano?d       dounano?d\r\n?
    \                      o\r\no                       u\r\nn                       n\r\na
    \                      a\r\nn                       n\r\nu                       o\r\no
    \                      ?\r\nd?onanuod       d?onanuod\r\n        ?       o        \r\n
    \       o       u        \r\n        n       n        \r\n        a       a        \r\n
    \       n       n        \r\n        u       o        \r\n        o       ?        \r\n
    \       d?onanuod        \r\n</pre>\n\t"
  :code: |
    object StringShape {
        def main(args : Array[String]) : Unit = {
             val target = "dounano?"
            val mover =
                P(1,0) ::
                P(0,1) ::
                P(1,0) ::
                P(0,1) ::
                P(-1,0) ::
                P(0,1) ::
                P(-1,0) ::
                P(0,-1) ::
                P(-1,0) ::
                P(0,-1) ::
                P(1,0) ::
                P(0,-1) ::
                Nil
            val da = new DrawingArea
            var x, y = 0
            mover.foreach { m =&gt;
                target.foreach { c =&gt;
                      da += (P(x,y),c)
                    x += m.x
                    y += m.y
                }
            }
             for (y &lt;- da.y_min to da.y_max) {
                 for (x &lt;- da.x_min to da.x_max) print(da(P(x,y)))
                 println()
             }
        }

         case class P(val x:Int, val y:Int)
        class DrawingArea {
            var x_min, y_min, x_max, y_max = 0
            private val area:scala.collection.mutable.Map[P,Char] = new scala.collection.mutable.HashMap()
            def +=(point:P, c:Char) = {
                area += ((point, c))
                x_min = x_min.min(point.x)
                y_min = y_min.min(point.y)
                x_max = x_max.max(point.x)
                y_max = y_max.max(point.y)
            }
            def apply(point:P):Char = {
                area.getOrElse(point,' ')
            }
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10113'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10113
  :user_name: horiuchi
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/570/
  :language: Python
  :time: 2010/02/08 05:56 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <div class=\"section\">\n<p>pythonがまだだったので投稿。\r</p>\n<p>\r</p>\n<p>最初に、board
    = [\" \" * max] * max とやったらshalow copyだったためにはまったのは良い思い出・・・。</p>\n</div>\n\t"
  :code: |
    import sys

    if len(sys.argv) &lt; 2 or len(sys.argv[1]) &lt; 2:
        print "Usage:doukaku291 word(more than 2-chars)"
        exit(0)

    w = sys.argv[1]
    l = len(w)
    max = l * 3 + 1
    board = [[" " for i in xrange(max)] for j in xrange(max)]

    ds = [
        (1, 0), (0, 1), (1, 0), (0, 1),
        (-1, 0), (0, 1), (-1, 0), (0, -1),
        (-1, 0), (0, -1), (1, 0), (0, -1),
    ]

    (x, y) = (l, 0)
    for d in ds:
        for s in w:
            board[y][x] = s
            (x, y) = (x + d[0], y + d[1])

    for line in board:
        print "".join(line)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10115'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10115
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Other
  :time: 2010/02/08 06:09 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <pre class=\"compact\">文字数チェックはしてないです。\r\n</pre>\n\t"
  :code: "type CyclicString(s : string) =\n  let len = s.Length\n  let mutable c =
    -1\n  member this.Item(n : int) = s.[n % len]\n  member this.Length = len\n  member
    this.get() = \n    c &lt;- if c + 1 = len then 0 else c + 1\n    this.[c]\n\ntype
    Char2d(xSize, ySize) =\n  let ch2d = Array2D.create xSize ySize ' '\n  let mutable
    _pos = (0, 0)\n  member this.pos\n    with get() = _pos\n    and  set(p) = _pos
    &lt;- p\n  member this.put ch =\n    let (x, y) = _pos\n    ch2d.[x,y] &lt;- ch\n
    \ member this.printOut() = \n    for y = 0 to ySize - 1 do\n      for x = 0 to
    xSize - 1 do\n        printf \"%c\" ch2d.[x, y]\n      printfn \"\"\n\nlet cross
    (str) =\n   let up    pos = (fst pos, snd pos - 1)\n   let down  pos = (fst pos,
    snd pos + 1)\n   let left  pos = (fst pos - 1, snd pos)\n   let right pos = (fst
    pos + 1, snd pos)\n   let command = seq [right; up; right; down; right; down;
    left; down; left; up; left; up]\n   let cs = CyclicString(str)\n   let len = cs.Length\n
    \  let ch2d = Char2d(len * 3 + 1, len * 3 + 1)\n   ch2d.pos &lt;- (0, len)\n\n
    \  let interpreter f =\n     for i = 1 to len do\n       ch2d.put &lt;| cs.get()\n
    \      ch2d.pos &lt;- f ch2d.pos\n\n   Seq.iter interpreter command\n   ch2d.printOut()\n\ndo
    cross \"doukaku\"\n"
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '10116'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10116
  :user_name: mattsan
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/833/
  :language: Haskell
  :time: 2010/02/08 06:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#10105に感銘。Haskellで再現させてみました。\r\nquarterが1/4。\r\nquarterとquarterの上下左右を入れ替えたものの合成がhalf。\r\nrot90halfがhalfを90度回転させたもの。\r\nhalfとrot90halfの合成が最終結果。</pre>\n\t"
  :code: |
    doukaku291 s = zipWith (\x y -&gt; zipWith max x y) half rot90Half
      where
        ss n      = replicate n ' '
        len       = length s
        width     = len * 3 + 1
        quartar   = [(ss len) ++ s ++ (ss len) ++ " "] ++
                    (replicate (len - 1) $ ss width)   ++
                    [s ++ (ss len) ++ s ++ " "]        ++
                    replicate (len * 2) (ss width)
        half      = zipWith max quartar $ reverse $ map (\x -&gt; reverse x) quartar
        rot90Half = reverse $ take width $ foldr rot (replicate width []) half
          where rot (c:cs) (r:rs) = (c:r):(rot cs rs)

    main = mapM_ putStrLn $ doukaku291 "doukaku"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10121'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10121
  :user_name: seri
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/641/
  :language: ActionScript
  :time: 2010/02/09 09:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">せっかくなので動きをつけてみました\r\n（BetweenAS3を使ってみたかっただけとも言う）</pre>\n\t"
  :code: "package {\n  import flash.display.Sprite;\n  import flash.text.TextField;\n
    \ import flash.text.TextFieldType;\n  import flash.text.TextFieldAutoSize;\n  import
    flash.events.MouseEvent;\n  import org.libspark.betweenas3.BetweenAS3;\n  import
    org.libspark.betweenas3.tweens.ITween;\n  import org.libspark.betweenas3.easing.Cubic;\n
    \ import org.libspark.betweenas3.events.TweenEvent;\n\n  [SWF(backgroundColor=\"#ffffff\")]\n
    \ public class Doukaku291 extends Sprite {\n    private var inputArea:TextField;\n
    \   private var button:TextField;\n    private var chars:Vector.&lt;TextField&gt;;\n\n
    \   private const DIRECTIONS:Array = [\n      { x : 1, y : 0 },\n      { x : 0,
    y : 1 },\n      { x : 1, y : 0 },\n      { x : 0, y : 1 },\n      { x : -1, y
    : 0 },\n      { x : 0, y : 1 },\n      { x : -1, y : 0 },\n      { x : 0, y :
    -1 },\n      { x : -1, y : 0 },\n      { x : 0, y : -1 },\n      { x : 1, y :
    0 },\n      { x : 0, y : -1 }\n    ];\n\n    public function Doukaku291() {\n
    \     inputArea = new TextField();\n      inputArea.border = true;\n      inputArea.multiline
    = false;\n      inputArea.type = TextFieldType.INPUT;\n      inputArea.width =
    150;\n      inputArea.height = inputArea.textHeight + 5;\n      inputArea.x =
    20;\n      inputArea.y = 10;\n      stage.addChild(inputArea);\n      \n      button
    = new TextField();\n      button.text = \"start\";\n      button.border = true;\n
    \     button.background = true;\n      button.backgroundColor = 0xffccaa;\n      button.autoSize
    = TextFieldAutoSize.CENTER;\n      button.height = inputArea.textHeight + 5;\n
    \     button.x = inputArea.x + inputArea.width + 10;\n      button.y = inputArea.y;\n
    \     stage.addChild(button);\n\n      chars = new Vector.&lt;TextField&gt;();\n
    \     button.addEventListener(MouseEvent.CLICK, function(e:MouseEvent):void {\n
    \         drawString(inputArea.text,\n            stage.stageWidth / 2, inputArea.y
    + inputArea.height + 10);\n        });\n    }\n\n    private function drawString(str:String,
    posX:int, posY:int):void {\n      var i:int, c:String;\n      var tmp:TextField;\n
    \     var strArray:Array = str.split(\"\");\n      var tween:ITween;\n      var
    tweens:Array = new Array();\n\n      for (i = 0; i &lt; chars.length; i++) {\n
    \       stage.removeChild(chars[i]);\n      }\n      chars = new Vector.&lt;TextField&gt;();\n\n
    \     for (i = 0; i &lt; 12; i++) {\n        for each (c in strArray) {\n          tmp
    = new TextField();\n          tmp.text = c;\n          tmp.height = tmp.textHeight;\n
    \         tmp.width = tmp.textWidth;\n          tmp.autoSize = TextFieldAutoSize.CENTER;\n
    \         chars.push(tmp);\n        }\n      }\n\n      chars[0].x = posX;\n      chars[0].y
    = posY;\n      stage.addChild(chars[0]);\n      for (i = 1; i &lt; chars.length;
    i++) {\n        chars[i].visible = false;\n        stage.addChild(chars[i]);\n
    \       chars[i].x = chars[i - 1].x + chars[i - 1].width * DIRECTIONS[int((i -
    1) / strArray.length)].x;\n        chars[i].y = chars[i - 1].y + chars[i - 1].height
    * DIRECTIONS[int((i - 1) / strArray.length)].y;\n\n        tween = BetweenAS3.tween(chars[i],\n
    \         { x : chars[i].x, y : chars[i].y },\n          { x : chars[i - 1].x,
    y : chars[i - 1].y },\n          0.1, Cubic.easeOut);\n\n        tween.addEventListener(TweenEvent.UPDATE,
    function(e:TweenEvent):void {\n            e.target.target.visible = true\n          });\n
    \       tweens.push(tween);\n      }\n\n      BetweenAS3.serialTweens(tweens).play();\n
    \   }\n  }\n}\n"
  :tags:
  - BetweenAS3
  :references:
    :url: /web/20100525170342/http://wonderfl.net/code/3d63d91a6ca887b98b634b95f403eb1e624d89ea
    :title: 文字列で＋を表示する | wonderfl build flash online
- :id: '10133'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10133
  :user_name: ワサビ
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1045/
  :language: Other
  :time: 2010/02/11 01:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>久しぶりに投稿します。関数型言語といえばfold。</p>\n\n\t"
  :code: |
    let printPlus = function
        | null | "" -&gt; ()
        | str -&gt;
            let len = String.length str
            let moves = [(1, 0); (0, 1); (1, 0); (0, 1); (-1, 0); (0, 1);
                         (-1, 0); (0, -1); (-1, 0); (0, -1); (1, 0); (0, -1)]
            let plot map (x, y) (dx, dy) =
                ((map, (x, y)), str) ||&gt; Seq.fold (fun (m, (x', y')) c -&gt;
                    (Map.add (x', y') c m, (x' + dx, y' + dy)))
            let plots =
                ((Map.empty, (len, 0)), moves) ||&gt; List.fold (fun (m, xy) mv -&gt; plot m xy mv)
                |&gt; fst
            [for y in 0 .. (len * 3) -&gt;
                [for x in 0 .. (len * 3) -&gt;
                    match Map.tryFind (x, y) plots with Some(c) -&gt; string c | None -&gt; " "]
                |&gt; String.concat ""]
            |&gt; List.iter (printfn "%s")

    printPlus "doukaku"
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '10229'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10229
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2010/02/13 07:54 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Python の勉強の一環として取り組んでみました。\r\n□や◇その他の形状にも柔軟に対応できる(無駄な)汎用性がウリです。</pre>\n\t"
  :code: "class Canvas:\n\n    __canvas = []\n\n    def __init__(self, width, length):\n
    \       for y in range(0, length):\n            self.__canvas.append([' '] * width)\n
    \       \n    __x = 0\n    __y = 0\n    def point(self, x, y):\n        self.__x
    = x\n        self.__y = y\n\n    def draw(self, string, direction):\n        for
    char in string:\n            self.__canvas[self.__y][self.__x] = char\n            self.__x
    += direction[0]\n            self.__y += direction[1]\n\n    def p(self):\n        for
    row in self.__canvas:\n            print ''.join(row)\n            \nclass Direction:\n
    \   north = [0, -1]\n    northEast = [1, -1]\n    east = [1, 0]\n    southEast
    = [1, 1]\n    south = [0, 1]\n    southWest = [-1, 1]\n    west = [-1, 0]\n    northWest
    = [-1, -1]\n\ndef drawCross(string):\n    canvas = Canvas(len(string)*3+1, len(string)*3+1)\n
    \   canvas.point(len(string), 0)\n\n    directions = (\n        Direction.east,\n
    \       Direction.south,\n        Direction.east,\n        Direction.south,\n
    \       Direction.west,\n        Direction.south,\n        Direction.west,\n        Direction.north,\n
    \       Direction.west,\n        Direction.north,\n        Direction.east,\n        Direction.north)\n\n
    \   for d in directions:\n        canvas.draw(string, d)\n    canvas.p()\n    \ndrawCross('doukaku')\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10263'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10263
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2010/02/14 22:23 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>批評いただければ幸いです。</p>\n\n\t"
  :code: |
    Edge = $*[0]
    Direction = [:right, :down, :right, :down, :left, :down, :left, :up, :left, :up, :right, :up]
    Screen, @x, @y = [[]], 0, 0

    def right; Edge.each_char {|c| Screen[@y][@x] = c; @x += 1} end
    def down; Edge.each_char {|c| Screen[@y][@x] = c; @y += 1; Screen[@y] ||= []} end
    def left; Edge.each_char {|c| Screen[@y][@x] = c; @x -= 1; (@x = 0; Screen.map{|l| l.unshift(nil)}) if @x == -1} end
    def up; Edge.each_char {|c| Screen[@y][@x] = c; @y -= 1; (@y = 0; Screen.unshift([])) if @y == -1} end
    Direction.each {|d| send d}
    Screen.each {|l| puts l.map {|c| c || ' '}.join}
  :tags:
  - tPmrZwnrZfi
  - xvvtdCxreTPJju
  :references:
    :url: 
    :title: 
- :id: '10273'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10273
  :user_name: '[1..100]&gt;&gt;=pen'
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/304/
  :language: Haskell
  :time: 2010/02/16 22:06 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">絶対値と割り算を使って座標値からハンドルの切り具合を計算します。</pre>\n\t"
  :code: |
    import Maybe

    putStrCross s = mapM_ putStrLn [[fromMaybe ' ' $ lookup (i,j) cs| i &lt;- rng]| j &lt;- rng] where
      (m, m3, rng) = (length s, 3*m, [0..m3])
      cs = zip (cross (m,m) (1,0)) $ concat $ replicate 12 s
      cross (x,y) (dx,dy) = (x,y): cross (x+dx',y+dy') (dx',dy') where
        (s,t) = ((abs (2*x-m3) +  abs(2*y-m3) - m3) `quot` m, 1 - abs s)
        (dx',dy') = (t*dx - s*dy, s*dx + t*dy)
    {-
    &gt; putStrCross "doukaku"
    -}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10283'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10283
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2010/02/19 19:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>方向指示を三角関数で求めるように改造。それにしても何て冗長な数式だい。</p>\n\n\t"
  :code: "import math\n\nclass Canvas:\n\n    __canvas = []\n\n    def __init__(self,
    width, length):\n        for y in range(0, length):\n            self.__canvas.append(['
    '] * width)\n        \n    __x = 0\n    __y = 0\n    def point(self, x, y):\n
    \       self.__x = x\n        self.__y = y\n\n    def draw(self, string, direction):\n
    \       for char in string:\n            self.__canvas[self.__y][self.__x] = char\n
    \           self.__x += direction[0]\n            self.__y += direction[1]\n\n
    \   def get(self):\n        return self.__canvas\n\n    def p(self):\n        for
    row in self.__canvas:\n            print ''.join(row)\n\ndef direction(i):\n    return
    (int(2 * (0.25 + 0.25 * math.sin(math.pi * (2 * i + 5) / 2)) * math.copysign(1,
    (math.sin(math.pi * (2 * i + 5) / 2 / 6)))),\n    int(2 * (0.25 + 0.25 * math.sin(math.pi
    * (2 * i - 1) / 2)) * math.copysign(1, (math.sin(math.pi * (2 * i - 1) / 2 / 6)))))\n\ndef
    drawCross(string):\n    canvas = Canvas(len(string)*3+1, len(string)*3+1)\n    canvas.point(len(string),
    0)\n    for i in range(0, 12):\n        canvas.draw(string, direction(i))\n    canvas.p()\n
    \   \ndrawCross('doukaku')\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10288'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10288
  :user_name: hoge
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1111/
  :language: Haskell
  :time: 2010/02/21 12:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">#10273を見て、ifはMaybeにすればいいのかと思い実装。考え方は#10116(#10105)。\r\nそれだけでは芸がないので、ラムダやlet,
    where節等を使わずに書くとどうなるかやってみた。</pre>\n\t"
  :code: |
    module Main where

    import Data.List
    import Data.Maybe (fromMaybe)
    import Control.Monad (mplus)
    import Control.Applicative ((&lt;*&gt;))

    genCross = map (fromMaybe ' ')
           . foldr (zipWith mplus) (repeat Nothing)
           . map (&gt;&gt;= (++ [Just '\n']))
           . take 4
           . iterate (reverse . transpose)
           . map (++ [Nothing])
           . ((++) . id &lt;*&gt; (replicate . (* 2) . pred . length &lt;*&gt; (`replicate` Nothing) . length . head))
           . foldr1 (zipWith (++))
           . ((:) . reverse &lt;*&gt; ((:) . id &lt;*&gt; (: []) . reverse))
           . ((:) . map Just &lt;*&gt; (replicate &lt;*&gt; (`replicate` Nothing)) . length)

    main = putStrLn . genCross $ "doukaku"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10292'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10292
  :user_name: rst76
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1146/
  :language: Other
  :time: 2010/02/23 11:41 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>はじめまして。\nGolfと違って高階関数を使えるのがウレシイ。\nふつうにハンドルを切ってます。</p>\n\n\t"
  :code: |
    import Data.List

    r [x,y] = [-y, x]
    l [x,y] = [ y,-x]

    ds = scanr id [0,1] [r,r,l,r,r,l,r,r,l,r,r]

    place str = snd $ mapAccumL phi [len,len] [ (d, ch) | d&lt;-ds, ch&lt;-str ]
      where phi pos (d, ch) = (zipWith (+) pos d, (pos, ch))
            len = length str

    cross str = unlines [ [ maybe ' ' id $ lookup [x,y] $ place str | y&lt;-is ] | x&lt;-is ]
      where is = [0..3*length str]

    main = putStrLn . cross =&lt;&lt; getLine
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10293'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10293
  :user_name: rst76
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1146/
  :language: Haskell
  :time: 2010/02/23 11:45 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  言語選ぶの忘れてた‥orz\r\n削除できないのかなぁ。\n\t"
  :code: |
    import Data.List

    r [x,y] = [-y, x]
    l [x,y] = [ y,-x]

    ds = scanr id [0,1] [r,r,l,r,r,l,r,r,l,r,r]

    place str = snd $ mapAccumL phi [len,len] [ (d, ch) | d&lt;-ds, ch&lt;-str ]
      where phi pos (d, ch) = (zipWith (+) pos d, (pos, ch))
            len = length str

    cross str = unlines [ [ maybe ' ' id $ lookup [x,y] $ place str | y&lt;-is ] | x&lt;-is ]
      where is = [0..3*length str]

    main = putStrLn . cross =&lt;&lt; getLine
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10296'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10296
  :user_name: zaud
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/885/
  :language: Other
  :time: 2010/02/24 12:58 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  clojure に挑戦してみました。\n\t"
  :code: |
    (defn plus [st]
      (let [len (.length st)
            line-w (inc (* len 3))
            coll (apply concat
                   (interleave
                     (partition len (range 1 line-w))
                     (list (repeat len len)(repeat len (* len 2))'())))
            coll-y (concat (repeat (inc len) 0) coll
                     (repeat (dec len) (* len 3))(reverse coll))
            coll-x (apply concat (reverse (split-at (* len 3) coll-y)))
            matrix (map (fn [x y] (vector x y)) coll-x coll-y)
            str-12 (apply concat (repeat 12 (seq st)))
            ms-map (apply hash-map (interleave matrix str-12))]
        (apply str
          (map #(apply str %)
            (interpose "\n"
              (partition (inc line-w)
                (for [y (range 0 line-w) x (range 0 (inc line-w))]
                  (format "%s" (get ms-map (vector x y) " ")))))))))

    (println (plus "doukaku"))
  :tags:
  - clojure
  :references:
    :url: 
    :title: 
- :id: '10297'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10297
  :user_name: mattsan
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/833/
  :language: Ruby
  :time: 2010/02/24 13:39 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    s = ARGV.shift || "doukaku"

    w = s.length * 3 + 1
    f = ((" " * w + "\n") * w).split("\n")
    x, y, dx, dy = s.length, 0, 0, -1
    ([:R, :R, :L].collect { |p| [p] + s.split(//) } * 4).flatten.each { |c|
      dx, dy        = -dy, dx           if c == :R
      dx, dy        = dy, -dx           if c == :L
      f[y][x], x, y = c, x + dx, y + dy if c.kind_of? String
    }
    print f.join("\n"), "\n"
  :tags:
  - ZDGhrskecZmajJnn
  :references:
    :url: 
    :title: 
- :id: '10312'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10312
  :user_name: a_san
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1149/
  :language: Scala
  :time: 2010/03/01 17:15 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">タートルグラフィックで描いてみました。\r\nちなみに、斜めに描くこともできます。(^^;\r\n
    \             d             d\r\n             u o           u o\r\n            k
    \  u         k   u\r\n           a     k       a     k\r\n          k       a
    \    k       a\r\n         u         k   u         k\r\n        o           u
    o           u\r\n       d             d             d\r\n        u                         o\r\n
    \        k                       u\r\n          a                     k\r\n           k
    \                  a\r\n            u                 k\r\n             o               u\r\n
    \             d             d\r\n             u               o\r\n            k
    \                u\r\n           a                   k\r\n          k                     a\r\n
    \        u                       k\r\n        o                         u\r\n
    \      d             d             d\r\n        u           o u           o\r\n
    \        k         u   k         u\r\n          a       k     a       k\r\n           k
    \    a       k     a\r\n            u   k         u   k\r\n             o u           o
    u\r\n              d             d</pre>\n\t"
  :code: "/** キャンバス */\nclass Canvas(val sizeX:Int, val sizeY:Int) {\n    var canvas:Array[StringBuffer]
    = \n        (for(i &lt;- 0 until sizeY) yield new StringBuffer(\" \"*sizeX)).toArray\n
    \   def set(x:Int, y:Int, ch:Char):Unit = {\n        if (0 &lt;= y &amp;&amp;
    y &lt; sizeY &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; sizeX)\n            canvas(y).setCharAt(x,
    ch)\n    }\n    override def toString():String = canvas.mkString(\"\\n\")\n}\n\n/**
    タートル・グラフィック(^^; */\nclass Turtle(c:Canvas) {\n    var canvas:Canvas = c\n    var
    x:Double = 0.0        // 左上が原点\n    var y:Double = 0.0        // 左上が原点\n    var
    th:Double = 0.0        // radian 北が0で右回りが正\n    /** 右に t[radian]向く */\n    def
    turn(t:Double):Unit = {\n        th += t\n    }\n    /** 前に進む */\n    def go(text:String):Unit
    = {\n        for (i &lt;- 0 until text.length) {\n            canvas.set(x.asInstanceOf[Int],
    y.asInstanceOf[Int], text.charAt(i))\n            x += Math.round(Math.sin(th)).asInstanceOf[Int]\n
    \           y += Math.round(-Math.cos(th)).asInstanceOf[Int]\n        }\n    }\n
    \   /** 指定位置に進む */\n    def setPos(newX:Double, newY:Double):Unit = {\n        x
    = newX\n        y = newY\n    }\n}\n\n/** 文字列で＋を表示する */\nobject Doukaku {\n    def
    main(args:Array[String]):Unit = {\n        var canvas = new Canvas(50, 50)        //
    固定。多めに取っている\n        var turtle = new Turtle(canvas)\n\n        val text = if
    (args.length &gt; 0) args(0) else \"doukaku\"\n\n        turtle.setPos(text.length,
    0)\n        turtle.turn(Math.Pi / 2)\n\n//        turtle.setPos(text.length, 10)
    \   // 斜めに表示する場合は前の2行をコメントにし、\n//        turtle.turn(Math.Pi / 3)        // この2行をコメントアウトしてください。\n\n
    \       turtle.go(text)\n        turtle.turn(Math.Pi / 2)\n        turtle.go(text)\n
    \       turtle.turn(-Math.Pi / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi
    / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi / 2)\n        turtle.go(text)\n
    \       turtle.turn(-Math.Pi / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi
    / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi / 2)\n        turtle.go(text)\n
    \       turtle.turn(-Math.Pi / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi
    / 2)\n        turtle.go(text)\n        turtle.turn(Math.Pi / 2)\n        turtle.go(text)\n
    \       turtle.turn(-Math.Pi / 2)\n        turtle.go(text)\n\n        println(canvas)\n
    \   }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10336'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10336
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: JavaScript
  :time: 2010/03/11 12:43 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>2次元配列をつくる\n→1文字ずつ埋める\n→つなげる\n→(ﾟДﾟ)ｳﾏｰ</p>\n\n\t"
  :code: |
    function plusStr (s) {
        var s = String (s) || 'doukaku', l = s.length, r = s.split ('').reverse ().join (''), a = [];
        /*下向きに埋める*/
        a.down = function ([x, y], s) {
            for (var i = 0 ; i &lt; l; i++) {
                if (! a[x + i]) a[x + i] = Array (3 * l + 1).join (' ').split ('');
                this[x + i][y] = s[i];
            }
        };
        [[0, 2 * l], [l, 3 * l], [2 * l, 2 * l]].forEach (function (v) {a.down (v, s)});
        [[1, l], [l + 1, 0], [2 * l + 1, l]].forEach (function (v) {a.down (v, r)});
        /*横向きに埋める*/
        a.right = function ([x, y], s) {
            for (var i = 0 ; i &lt; l; i++){
                this[x][y + i] = s[i];
            }
        };
        [[0, l], [l, 0], [l, 2 * l]].forEach (function (v) {a.right (v, s)});
        [[2 * l, 1], [2 * l, 2 * l + 1], [3 * l, l + 1]].forEach (function (v) {a.right (v, r)});
        /*繋げる*/
        return a.map (function (b) {return b.join ('').replace(/ +$/, '')}).join ("\n");
    }
    console.log (plusStr ('koukaku'));
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10339'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10339
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Ruby
  :time: 2010/03/13 17:37 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>#10263が興味深い方法なので、すこし変更してみました。\n・class化\n・ちょっとだけタートルグラフィックの真似（\"rrl\"部分を\"rrlrl\"とか\"rrllr\"などに変えてみて下さい）</p>\n\n\t"
  :code: "class Moji2zukei\n  def initialize(edge)\n    @Screen, @x, @y, @edge, @dx,
    @dy = [[]], 0, 0, edge, 1,0\n  end\n  \n  def r; @dx, @dy = -@dy, @dx; zset; end\n
    \ def l; @dx, @dy = @dy, -@dx; zset; end\n\n  def zset\n    @edge.each_char {|c|\n
    \     @Screen[@y][@x] = c;\n      @x += @dx; @y += @dy\n      @Screen[@y] ||=
    []\n      (@x = 0; @Screen.map{|l| l.unshift(nil)}) if @x == -1\n      (@y = 0;
    @Screen.unshift([])) if @y == -1\n    }\n  end\n\n  def scrout\n    @Screen.each
    {|l| puts l.map {|c| c || ' '}.join}\n  end\nend\n\nDirection = \"rrl\".split(\"\").map{|x|x.to_sym}*4\nm2z
    = Moji2zukei.new($*[0])\nDirection.each {|d| m2z.send d}\nm2z.scrout\n"
  :tags:
  - 1.8.7
  - BnRfaBVoQNNlpLJuog
  - ruby
  :references:
    :url: 
    :title: 
- :id: '10362'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10362
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2010/03/28 23:13 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>バッファを作りそこに文字を書き込み、その後表示させました。\nポインタをどの方向に進めるかの配列を作りプラス型を表現しました</p>\n\n\t"
  :code: |
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;stdlib.h&gt;

    int main(int argc, char *argv[]){
        char *str, *buf, *p;
        int len, i, j, size,
            dir[12][2] ={{1,0},{0,1},{1,0},{0,1},{-1,0},{0,1},
                        {-1,0},{0,-1},{-1,0},{0,-1},{1,0},{0,-1}};
        if (argc &lt; 2) return 0;
        str = argv[1];
        len = strlen(str);
        size = (len * 3 + 1);
        buf = (char*)malloc(size * size);
        memset(buf, ' ', size * size);
        p = buf + (0 * size + len);
        for(i = 0; i &lt; 12; i ++) {
            for(j = 0; j &lt; len; j ++) {
                *p = str[j];
                p += (dir[i][1] * size);
                p += (dir[i][0]);
            }
        }
        for(i = 0; i &lt; size; i ++) {
            for(j = 0; j &lt; size; j ++) {
                putchar(*(buf + (i * size + j)));
            }
            putchar('\n');
        }
        free(buf);
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10368'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10368
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Bash
  :time: 2010/03/30 08:28 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <p>Linuxのターミナルで</p>\n\n\t"
  :code: |
    wget http://ja.doukaku.org/291/ ; cat index.html |head -n 104 |tail -n 22
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10459'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10459
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2010/04/21 00:45 GMT
  :vote_count: '1'
  :vote_score: '-1'
  :body: "\n\t  <p>I had a dream to begin my own commerce, nevertheless I did not
    have got enough amount of cash to do it. Thank goodness my friend said to take
    the &lt;a href=\"<a class=\"reference\" href=\"/web/20100525170342/http://lowest-rate-loans.com/topics/mortgage-loans\">http://lowest-rate-loans.com/topics/mortgage-loans</a>\"&gt;mortgage
    loans&lt;/a&gt;. Thence I received the bank loan and realized my old dream.</p>\n\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10461'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10461
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2010/04/24 13:05 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>空白や文字列や切り出した文字などを繋げて作りました。</p>\n\n\t"
  :code: |
    S=尋ねる
    もしS=空ならば終わる
    L=Sの文字数

    結果=「 」をLだけリフレイン&amp;S&amp;MID(S,1,1)&amp;「{~}」

    (L-1)回
    　　結果=結果&amp;(「 」をLだけリフレイン)
    　　結果=結果&amp;MID(S,L-回数+1,1)
    　　結果=結果&amp;(「 」をL-1だけリフレイン)
    　　結果=結果&amp;MID(S,回数+1,1)&amp;「{~}」

    結果=結果&amp;S&amp;MID(S,1,1)&amp;(「 」をL-1だけリフレイン)&amp;S&amp;MID(S,1,1)&amp;「{~}」

    (L-1)回
    　　結果=結果&amp;MID(S,L-回数+1,1)
    　　結果=結果&amp;(「 」をL*3-1だけリフレイン)
    　　結果=結果&amp;MID(S,回数+1,1)&amp;「{~}」

    結果=結果&amp;S&amp;MID(S,1,1)&amp;(「 」をL-1だけリフレイン)&amp;S&amp;MID(S,1,1)&amp;「{~}」

    (L-1)回
    　　結果=結果&amp;(「 」をLだけリフレイン)
    　　結果=結果&amp;MID(S,L-回数+1,1)
    　　結果=結果&amp;(「 」をL-1だけリフレイン)
    　　結果=結果&amp;MID(S,回数+1,1)&amp;「{~}」

    結果=結果&amp;(「 」をLだけリフレイン)
    結果=結果&amp;S&amp;MID(S,1,1)&amp;「{~}」


    結果を表示
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10466'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10466
  :user_name: rennos
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1024/
  :language: HSP
  :time: 2010/04/25 07:46 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  全角文字も扱えるようにしたいが……。\r<br>"
  :code: "#module\n\n// 移動量を取得する\n#deffunc GetStep array step, double arg, int r\n
    \   step(0) = int( cos(arg) * r )\n    step(1) = int( sin(arg) * r )\n    return\n
    \   \n    \n// 文字マップへ文字列を書き込む\n#deffunc WriteStrToCharMap_v \\\n    var dst, int
    lenX, int lenY, var src, array pt, array step,  \\\n    local idx\n    \n    repeat
    strlen(src)\n        idx = pt(0) + (pt(1) * (lenX + 2))\n        poke dst, idx,
    peek(src, cnt)\n        pt(0) += step(0)\n        pt(1) += step(1)\n    loop\n
    \   return\n    \n    \n// 白抜き形の文字列を生成する\n#defcfunc makePlusString str src_,    \\\n
    \   local src, local len, local root, local buf,     \\\n    local arg, local
    arg_r, local pt, local stepForward, local stepRight\n    \n    src   = src_\n
    \   len   = strlen(src)\n    root  = (len * 3 + 1)\n    \n    if ( len == 0 )
    { return \"\" }\n    if ( len == 1 ) { return src }\n    \n    // 結果のマップ\n    sdim
    \  buf,       (root + 2) * root + 1\n    memset buf, 0x20, (root + 2) * root\n
    \   \n    // 文字列を書き加える\n    arg   = 0.0\n;    arg_r = 0.0\n    pt    = len, 0\n
    \   repeat 4\n        arg_r = arg + (M_PI / 2)\n        \n        GetStep stepForward,
    arg,   1\n        GetStep stepRight,   arg_r, 1\n        \n        WriteStrToCharMap_v
    buf, root, root, src, pt, stepForward\n        WriteStrToCharMap_v buf, root,
    root, src, pt, stepRight\n        WriteStrToCharMap_v buf, root, root, src, pt,
    stepForward\n        \n        arg = arg_r\n    loop\n    \n    // 改行を埋め込む\n    repeat
    root\n        wpoke buf, root + (cnt * (root + 2)), 0x0A0D\n    loop\n    \n    return
    buf\n    \n#global\n\n// test\n    mes makePlusString( \"doukaku\" )\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10501'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10501
  :user_name: uehaj
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/959/
  :language: Groovy
  :time: 2010/05/14 18:29 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>平凡に</p>\n\n\t"
  :code: |
    str = args[0]+args[0][0]

    len=str.size()-1

    [' '*len+str+' '*len,
     *(str[1..-1].collect { ' '*len+it+' '*(len-1)+it }),
     str+' '*(len-1)+str,
     *(str[1..-1].collect { it+' '*(((len)*3)-1)+it }),
     str+' '*(len-1)+str,
     *(str[1..-1].collect { ' '*len+it+' '*(len-1)+it }),
     ' '*len+str+' '*len,
    ].each {println it}
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10505'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10505
  :user_name: tfviv
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/1163/
  :language: Erlang
  :time: 2010/05/15 10:14 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">キャンバスとしてプロセス辞書を使ってみた。\r\n\r\n以下で結果表示\r\nerlc
    ans291.erl &amp;&amp; erl -noshell -s ans291 main \"doukaku\" -s init stop\r\n\r\n</pre>\n\t"
  :code: "-module(ans291).\n-export([main/1]).\n\nmain(Args) -&gt; start(lists:map(fun
    atom_to_list/1, Args)).\n\nstart([Text]) -&gt; proc(list_to_tuple(Text), length(Text));\nstart([Text,
    Size]) -&gt; {S,_} = string:to_integer(Size), proc(list_to_tuple(Text), S).\n\ngen_char(Text,
    N) when N &gt; size(Text) -&gt; gen_char(Text,1);\ngen_char(Text, N) -&gt; {element(N,
    Text), fun() -&gt; gen_char(Text, N+1) end}.\niter_char(Text) -&gt; fun() -&gt;
    gen_char(Text, 1) end.\n\nproc(Text, Size) -&gt;\n    pen({Size+1, 1}, iter_char(Text),
    [\n        {move_right(), Size}, {move_down(), Size}, {move_right(), Size}\n        ,
    {move_down(), Size}, {move_left(), Size}, {move_down(), Size}\n        , {move_left(),
    Size}, {move_up(), Size}, {move_left(), Size}\n        , {move_up(), Size}, {move_right(),
    Size}, {move_up(), Size}]),\n    draw(Size).\n\npen(_Start, _Iter, []) -&gt; ok;\npen(Start,
    Iter, [Pen|Pens]) -&gt;\n    {Point, Iter2} = pen_move(Start, Iter, Pen),\n    pen(Point,
    Iter2, Pens).\n\npen_move(Start, Iter, {_Fun, 0}) -&gt; {Start, Iter};\npen_move(Start,
    Iter, {Fun, Size}) -&gt;\n    {Ch, Iter2} = Iter(),\n    put(Start, Ch),\n    Point
    = Fun(Start),\n    pen_move(Point, Iter2, {Fun, Size-1}).\n\ndraw(Size) -&gt;
    draw(1, 1, Size*3+1).\ndraw(_X, Y, Size) when Y&gt;Size -&gt; io:format(\"~n\");\ndraw(X,
    Y, Size)  when X&gt;Size -&gt; io:format(\"~n\"),draw(1,Y+1,Size);\ndraw(X, Y,
    Size) -&gt;\n    case get({X,Y}) of \n        undefined -&gt; io:format(\" \");\n
    \       Ch        -&gt; io:format(\"~c\", [Ch])\n    end,\n    draw(X+1, Y, Size).\n\n\nmove_down()
    -&gt; fun({X,Y}) -&gt; {X, Y+1} end.\nmove_up() -&gt; fun({X,Y}) -&gt; {X, Y-1}
    end.\nmove_right() -&gt; fun({X,Y}) -&gt; {X+1, Y} end.\nmove_left() -&gt; fun({X,Y})
    -&gt; {X-1, Y} end.\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '10509'
  :parent_id: '291'
  :url: http://ja.doukaku.org/comment/10509
  :user_name: 匿名
  :user_url: /web/20100525170342/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2010/05/23 05:35 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <p>左上から時計回りに文字を入れました</p>\n\n\t"
  :code: "public class Main {\n  public static void main(String[] args) {\n    String
    s = \"doukaku\";\n    char plus[][] = new char[s.length() * 3 + 1][s.length()
    * 3 + 1]; \n    int dx[] = {1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 1, 0}; \n    int
    dy[] = {0, 1, 0, 1, 0, 1, 0, -1, 0, -1, 0, -1};\n    int px = s.length();\n    int
    py = 0;\n\n    for (int d = 0; d &lt; dx.length; d++) {\n      for (int at = 0;
    at &lt; s.length(); at++) {\n        plus[py][px] = s.charAt(at);\n        px
    += dx[d];\n        py += dy[d];\n      }   \n    }   \n\n    for (int y = 0; y
    &lt; plus.length; y++) {\n      for (int x = 0; x &lt; plus[y].length; x++) {\n
    \       System.out.print(plus[y][x] == '\\u0000' ? \" \" : plus[y][x]);\n      }
    \  \n      System.out.println();\n    }   \n  }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
