---
:id: '31'
:title: Tiny MML
:comments:
- :id: '3387'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/3387
  :user_name: にしお
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/1/
  :language: 
  :time: 2007/07/24 14:17 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\r\n\t  文字列の入力をとり、音を鳴らすプログラムを作ってください。\r\n<p>\r\n入力はcがド、dがレ、eがミ、fがファ、gがソ、aがラ、bがシ、rが休符とします。この8文字以外の文字は入力に含まれていないと仮定して構いません。おのおのの音符・休符は八分音符・八分休符とします。\r\n</p>\n<p>\r\nオクターブや音の長さの変更、同時発音などの機能は不要です。\r\n</p>\n<p>\r\nサンプル入力(カエルの歌)\r\n</p>\n<pre>\r\ncdefedcrefgagfercrcrcrcrcdefedcr\r\n</pre>\r\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1420'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1420
  :user_name: cats
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/172/
  :language: C
  :time: 2007/07/24 14:41 GMT
  :vote_count: '6'
  :vote_score: '2'
  :body: "\n\t  \n\t"
  :code: |
    using System;
    using System.Runtime.InteropServices;
    using System.Threading;

    class Program
    {
      [DllImport("kernel32.dll")]
      extern static bool Beep(uint f, uint d);
      static void Main()
      {
        Play("cdefedcrefgagfercrcrcrcrcdefedcr");
      }
      static void Play(string s)
      {
        uint[] dt = {440, 494, 262, 294, 330, 349, 392};
        foreach (char c in s)
        {
          if (c == 'r') Thread.Sleep(500);
          else Beep(dt[c - 'a'], 500);
        }
      }
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1421'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1421
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Ruby
  :time: 2007/07/24 14:50 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  ぎゃ、先越された＞＜\r\nbeepコマンドを使うのってアリ？？\n\t"
  :code: |
    require 'enumerator'
    FREQ_TABLE={ ?c=&gt;'262', ?d=&gt;'294', ?e=&gt;'330', ?f=&gt;'349', ?g=&gt;'392', ?a=&gt;'440', ?b=&gt;'494', ?r=&gt;'1'}
    def play(mmf)
      system "beep", *mmf.enum_for(:each_byte).map{|b| [ "-n", "-f", FREQ_TABLE[b] ]}.flatten
    end
    play "cdefedcrefgagfercrcrcrcrcdefedcr"
  :tags:
  - beep
  :references:
    :url: 
    :title: 
- :id: '1423'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1423
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Bash
  :time: 2007/07/24 14:59 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  \n\t"
  :code: |
    function play() {
        for ((i=1;;i++)); do
            snd=`expr substr $1 $i 1`
            case $snd in
                c) F=262;;
                d) F=294;;
                e) F=330;;
                f) F=349;;
                g) F=392;;
                a) F=440;;
                b) F=494;;
                r) F=1;;
                *) return
            esac
            beep -f $F
        done
    }
    play cdefedcrefgagfercrcrcrcrcdefedcr
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1424'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1424
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Common
  :time: 2007/07/24 15:07 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  \n\t"
  :code: |
    (require :kmrcl)
    (defparameter *freq-table*
      '(#\c "262" #\d "294" #\e "330" #\f "349" #\g "392" #\a "440" #\b "494" #\r "1"))
    (defun play (mml)
      (loop for c across mml do
           (kmrcl:run-shell-command "beep -f ~a" (getf *freq-table* c))))
    (play "cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags:
  - kmrcl
  :references:
    :url: 
    :title: 
- :id: '1425'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1425
  :user_name: yuin
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/82/
  :language: Python
  :time: 2007/07/24 15:14 GMT
  :vote_count: '3'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">とりあえずbeepで。win専用。</pre>\n\t"
  :code: |
    import winsound
    import time

    def play(mmf):
      toi = lambda x: int(ord(x))
      for n in mmf:
        if n == 'r': time.sleep(0.5)
        else : winsound.Beep(play.fq[toi(n)-toi('a')], 500)
    play.fq = [440, 494, 262, 294, 330, 349, 392]

    play("cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags:
  - winsound
  :references:
    :url: 
    :title: 
- :id: '1426'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1426
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Emacs
  :time: 2007/07/24 15:16 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  \n\t"
  :code: "(require 'cl)\n(defvar *freq-table*\n  '(?c \"262\" ?d \"294\" ?e \"330\"
    ?f \"349\" ?g \"392\" ?a \"440\" ?b \"494\" ?r \"1\"))\n(defun tinymml-play (mml)\n
    \ (loop for c across mml do\n        (call-process \"beep\" nil nil nil \n                      \"-f\"
    (plist-get *freq-table* c))))\n(tinymml-play \"cdefedcrefgagfercrcrcrcrcdefedcr\")\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1429'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1429
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Perl
  :time: 2007/07/24 15:23 GMT
  :vote_count: '3'
  :vote_score: '-3'
  :body: "\n\t  \n\t"
  :code: |
    %FREQ_TABLE=( 'c'=&gt;'262', 'd'=&gt;'294', 'e'=&gt;'330', 'f'=&gt;'349', 'g'=&gt;'392', 'a'=&gt;'440', 'b'=&gt;'494', 'r'=&gt;'1');
    sub play {
        my($mml)=@_;
        my $len=length($mml);
        for(my $i=0;$i&lt;$len;$i++) {
            system(sprintf("beep -f %s", $FREQ_TABLE{substr($mml,$i,1)}));
        }
    }
    play("cdefedcrefgagfercrcrcrcrcdefedcr");
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1431'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1431
  :user_name: rubikitch
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/105/
  :language: Scheme
  :time: 2007/07/24 15:36 GMT
  :vote_count: '2'
  :vote_score: '-2'
  :body: "\n\t  \n\t"
  :code: |
    (use srfi-13)
    (use gauche.process)
    (define *freq-table*
      '((#\c . "262") (#\d . "294") (#\e . "330") (#\f . "349") (#\g . "392") (#\a . "440") (#\b . "494") (#\r . "1")))
    (define (play mml)
      (string-map
       (lambda (c) (process-wait (run-process "beep" "-f" (cdr (assq c *freq-table*)))) c)
       mml))
    (play "cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1432'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1432
  :user_name: ocean
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/177/
  :language: C
  :time: 2007/07/24 15:47 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  MIDIマッパーを使って再生。Windows専用。\n\t"
  :code: |
    #include &lt;windows.h&gt;
    #include &lt;mmsystem.h&gt;

    #include &lt;iostream&gt;
    #include &lt;stdexcept&gt;
    #include &lt;string&gt;

    #define MIDIMSG(status, channel, data1, data2) ((DWORD)((status&lt;&lt;4) | channel | (data1&lt;&lt;8) | (data2&lt;&lt;16)))

    void check(MMRESULT result)
    {
        if (result != MMSYSERR_NOERROR)
        {
            throw std::runtime_error("mmsystem error");
        }
    }

    class midi
    {
    public:
        midi()
        {
            check(::midiOutOpen(&amp;_h, MIDI_MAPPER, 0, 0, CALLBACK_NULL));
        }

        ~midi()
        {
            check(::midiOutClose(_h));
        }

        void play(DWORD note)
        {
            check(::midiOutShortMsg(_h, MIDIMSG(0x9, 0, note, 100)));
            wait();
            check(::midiOutReset(_h));
        }

        void wait()
        {
            ::Sleep(500);
        }

    private:
        HMIDIOUT _h;
    };

    void play(const char* s)
    {
        midi m;

        for (; *s; ++s)
        {
            switch (*s)
            {
                case 'c': m.play(60); break;
                case 'd': m.play(62); break;
                case 'e': m.play(64); break;
                case 'f': m.play(65); break;
                case 'g': m.play(67); break;
                case 'a': m.play(69); break;
                case 'b': m.play(71); break;
                case 'r': m.wait(); break;
                default:
                    throw std::runtime_error("invalid note");
            }
        }
    }

    int main(int argc, char* argv[])
    {
        try
        {
            if (argc != 2)
            {
                play("cdefedcrefgagfercrcrcrcrcdefedcr");
            }
            else
            {
                play(argv[1]);
            }
        }
        catch (std::exception&amp; e)
        {
            std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
  :tags:
  - Windows
  :references:
    :url: 
    :title: 
- :id: '1433'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1433
  :user_name: kkobayashi
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/232/
  :language: R
  :time: 2007/07/24 16:10 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  <pre class=\"compact\">テンポの基準を120:八分音符は0.25秒と仮定しています。\r\n\r\n&gt;
    MML(\"cdefedcrefgagfercrcrcrcrcdefedcr\")</pre>\n\t"
  :code: "require(\"sound\")\nMML &lt;- function(score){\n    freq  &lt;- c(c=262,
    d=294, e=330, f=349, g=392, a=440, b=494, r=0)\n    play(appendSample(as.Sample(unlist(sapply(unlist(strsplit(score,
    \"\")), \n         function(s){return(Sine(freq[s], 0.25))})))))\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1434'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1434
  :user_name: ocean
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/177/
  :language: Python
  :time: 2007/07/24 16:29 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  上のと同じコードをPython+ctypesを使って記述。音の長さは他の人のコードを参考にして0.25秒に変更しました。\n\t"
  :code: |
    import ctypes
    import time
    import sys

    MIDI_MAPPER = -1
    MMSYSERR_NOERROR = 0
    CALLBACK_NULL = 0

    class Midi:
        def __init__(self):
            self._dll = ctypes.windll.winmm
            self._h = ctypes.c_void_p()
            self._call("midiOutOpen", ctypes.byref(self._h), MIDI_MAPPER, 0, 0, CALLBACK_NULL)

        def __del__(self):
            self._call("midiOutClose", self._h)

        def play(self, note):
            self._call("midiOutShortMsg", self._h, self._msg(0x9, 0, note, 100))
            self.wait()
            self._call("midiOutReset", self._h)

        def wait(self):
            time.sleep(0.25)

        def _call(self, name, *args):
            ret = getattr(self._dll, name)(*args)
            if ret != MMSYSERR_NOERROR:
                raise RuntimeError("mmsystem error (%s)" % hex(ret))

        def _msg(self, status, channel, data1, data2):
            return (status&lt;&lt;4) | channel | (data1&lt;&lt;8) | (data2&lt;&lt;16)

    def play(s):
        m = Midi()
        notes = {'c': 60, 'd': 62, 'e': 64, 'f': 65,
                 'g': 67, 'a': 69, 'b': 71}
        for c in s:
            if c == 'r':
                m.wait()
            else:
                m.play(notes[c])

    def main():
        if len(sys.argv) == 2:
            play(sys.argv[1])
        else:
            play("cdefedcrefgagfercrcrcrcrcdefedcr")

    if __name__ == '__main__':
        main()
  :tags:
  - Python2.5
  - Windows
  :references:
    :url: 
    :title: 
- :id: '1435'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1435
  :user_name: kawauchi
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/14/
  :language: Perl
  :time: 2007/07/24 16:34 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  Audio::Beep は CPAN で。\r\nMML は引数にして下さい。\n\t"
  :code: |
    use Audio::Beep;

    my $music = $ARGV[0];
    $music =~ s/(.)/\1 /g;
    Audio::Beep-&gt;new()-&gt;play($music);
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1436'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1436
  :user_name: yuin
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/82/
  :language: Scala
  :time: 2007/07/24 16:34 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">適当に。なぜかオルゴール音色。\r\nそういえばMIDI検定という謎な検定持ってます。</pre>\n\t"
  :code: |
    import javax.sound.midi.spi._
    import javax.sound.midi._

    def play_mmf(mmf:String):unit = {
      val noteMap = Map('c' -&gt; 60, 'd' -&gt; 62, 'e' -&gt; 64, 'f' -&gt; 65,
                        'g' -&gt; 67, 'a' -&gt; 69, 'b' -&gt; 71)
      val crotchet = 24
      val channel = 0
      val inst    = 11
      val velocity= 127
      var current = 0
      val sequence = new Sequence(Sequence.PPQ, crotchet)
      val track = sequence.createTrack

      var m = new ShortMessage
      m.setMessage(ShortMessage.PROGRAM_CHANGE,channel, inst, 0)
      track.add(new MidiEvent(m,0))

      def addEvent(t:int, pitch:int, pos:int):unit = {
        var m = new ShortMessage
        m.setMessage(t, channel, pitch, velocity)
        track.add(new MidiEvent(m, pos))
      }
      def interval = current = current + crotchet/2
      def addNote(pitch:int):unit = {
        addEvent(ShortMessage.NOTE_ON, pitch, current)
        interval
        addEvent(ShortMessage.NOTE_OFF, pitch, current)
      }

      mmf.foreach(n =&gt; n match{
        case 'r' =&gt; interval
        case x   =&gt; addNote(noteMap(x))
      })

      val sequencer = MidiSystem.getSequencer
      sequencer.addMetaEventListener(new MetaEventListener(){
         def meta(meta:MetaMessage):unit = meta.getType match {
              case 47 =&gt; sequencer.close()
                         System.exit(0);
              case _  =&gt; ()
          }
      });
      sequencer.open
      sequencer.setSequence(sequence)
      sequencer.start
    }
    play_mmf("cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1440'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1440
  :user_name: sumim
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/88/
  :language: Smalltalk
  :time: 2007/07/24 18:12 GMT
  :vote_count: '4'
  :vote_score: '4'
  :body: "\n\t  Squeak Smalltalk で。\n\t"
  :code: |
    | score pitches duration loudness sequence sound |
    score := 'cdefedcrefgagfercrcrcrcrcdefedcr'.
    duration := 1/8 * 2.
    loudness := 500.
    pitches := FMSound chromaticPitchesFrom: #c4.
    sequence := score asArray collect: [:pName |
       pName = $r
          ifTrue: [{#rest. duration}]
          ifFalse: [{pitches at: ('c d ef g a b' indexOf: pName). duration. loudness}]].
    sound := AbstractSound noteSequenceOn: FMSound default from: sequence.
    sound play
  :tags:
  - Squeak_Smalltalk
  :references:
    :url: 
    :title: 
- :id: '1444'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1444
  :user_name: es
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/147/
  :language: Ruby
  :time: 2007/07/25 00:57 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\">one linerで。\r\n\r\nFreeBSDで動きます(*BSDかも)。\r\nちなみにFreeBSDにはデフォルトでbeepコマンドがない(はず)です。</pre>\n\t"
  :code: |
    ruby -e 'open("/dev/speaker", "w"){|d| d.print "l8"+ARGV.shift.gsub("r","n")}' cdefedcrefgagfercrcrcrcrcdefedcr
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1445'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1445
  :user_name: にしお
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/1/
  :language: Python
  :time: 2007/07/25 02:26 GMT
  :vote_count: '3'
  :vote_score: '1'
  :body: "\n\t  ordの返り値は元からintなのでtoiを定義する必要はないですね。\r\n\n\t"
  :code: |
    import winsound
    import time

    PLAY_FQ = [440, 494, 262, 294, 330, 349, 392]

    def play(mmf):
        for n in mmf:
            if n == 'r':
                time.sleep(0.5)
            else:
                winsound.Beep(
                    PLAY_FQ[ord(n) - ord('a')], 500)

    play("cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags:
  - winsound
  :references:
    :url: 
    :title: 
- :id: '1448'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1448
  :user_name: yuin
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/82/
  :language: 
  :time: 2007/07/25 05:12 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  ありゃ、そのとおり。夜に適当に書いたので頭がボーっとしていたのかもしれません(^^;\r\n\r\nご指摘ありがとうございます。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1453'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1453
  :user_name: hirataka
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/233/
  :language: 
  :time: 2007/07/25 14:39 GMT
  :vote_count: '6'
  :vote_score: '6'
  :body: "\n\t  <pre class=\"compact\">標準の命令を使わずにWindowsAPIを呼んでます。\r\nコード自体はいたって普通です。</pre>\n\t"
  :code: |
    ●ビープ(x, y) = DLL("kernel32", "BOOL Beep(DWORD, DWORD)")

    音階@「c」は262
    音階@「d」は294
    音階@「e」は330
    音階@「f」は349
    音階@「g」は392
    音階@「a」は440
    音階@「b」は494

    「cdefedcrefgagfercrcrcrcrcdefedcr」を鳴らす

    ＊鳴らす(楽譜を)
    　楽譜を文字列分解して反復
    　　もしそれが「r」ならば
    　　　0.5秒待つ
    　　違えば
    　　　ビープ(音階@それ, 500)
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1457'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1457
  :user_name: 匿名
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/4/
  :language: Python
  :time: 2007/07/26 04:13 GMT
  :vote_count: '6'
  :vote_score: '6'
  :body: "\n\t  <pre class=\"compact\">#1433をヒントにして、自前で正弦波を生成しました。\r\n式は適当ですが、一応それっぽい音はします。\r\n\r\n利用パッケージの都合で、Linuxと*BSD(?)のみ対応です。\r\n\r\n8分音符は0.5秒にしました。\r\n</pre>\n\t"
  :code: |
    import math
    import struct
    import ossaudiodev

    def sw(r, f, t):
      return struct.pack('h', int(math.sin((t/(float(r)/f))*2*math.pi)*0x7fff))

    wav = {
      'c': ''.join([sw(8000, 262, i) for i in range(4000)]),
      'd': ''.join([sw(8000, 294, i) for i in range(4000)]),
      'e': ''.join([sw(8000, 330, i) for i in range(4000)]),
      'f': ''.join([sw(8000, 349, i) for i in range(4000)]),
      'g': ''.join([sw(8000, 392, i) for i in range(4000)]),
      'a': ''.join([sw(8000, 440, i) for i in range(4000)]),
      'b': ''.join([sw(8000, 494, i) for i in range(4000)]),
      'r': '\x00\x00' * 4000
    }

    dsp = ossaudiodev.open('w')
    dsp.setparameters(ossaudiodev.AFMT_S16_LE, 1, 8000)
    dsp.writeall(''.join([wav[c] for c in 'cdefedcrefgagfercrcrcrcrcdefedcr']))
    dsp.flush()
    dsp.close()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1469'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1469
  :user_name: 沢渡 みかげ
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/101/
  :language: Mathematica
  :time: 2007/07/26 12:06 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">Mathematicaも数式処理ソフトですが，サウンド用の機能があります．\r\nMathematica6で強化されて，いろいろな音色で音階を奏でることが可能になっています．\r\n\r\nMathematicaでは，音を出さない場合
    None を指定するので，MMLのrをNoneにマップしています．\r\n\r\nhttp://reference.wolfram.com/mathematica/ref/SoundNote.ja.html\r\n\r\n音階がグラフっぽく出るので見た目がきれいです．</pre>\n\t"
  :code: |
    len = 0.25; (* sec *)
    tone = "Organ";
    mml = "cdefedcrefgagfercrcrcrcrcdefedcr";
    mathmml = StringSplit[mml, ""] /. {"r" -&gt; None};
    Sound[{tone, SoundNote[#, len] &amp; /@ mathmml}]
  :tags:
  - Mathematica6
  :references:
    :url: 
    :title: 
- :id: '1473'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1473
  :user_name: 匿名
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/4/
  :language: Java
  :time: 2007/07/26 12:58 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  javax.soud.midiパッケージを使用しています。初めてなので改善点などご指摘いただけましたら幸いです（音がちゃんと消えていないような）……\r\nタイミングの制御をちゃんとやっていないのでたどたどしい演奏になります（苦笑）\n\t"
  :code: "import javax.sound.midi.MidiSystem;\nimport javax.sound.midi.Receiver;\nimport
    javax.sound.midi.ShortMessage;\nimport javax.sound.midi.InvalidMidiDataException;\nimport
    javax.sound.midi.MidiUnavailableException;\n\npublic class TinyMML {\n    private
    final static int[] code = {69, 71, 60, 62, 64, 65, 67};\n    private final static
    int TONE = 120;\n\n    public static void play(String mml) throws InvalidMidiDataException,\n
    \                                              MidiUnavailableException, \n                                               InterruptedException
    {\n        ShortMessage mes = new ShortMessage();\n        Receiver rcvr = MidiSystem.getReceiver();\n
    \       for (int i = 0; i &lt; mml.length(); i++) {\n            char c = mml.charAt(i);\n
    \           if (c &gt;= 'a' &amp;&amp; c &lt;= 'g') {\n                int co
    = code[c - 'a'];\n                mes.setMessage(ShortMessage.NOTE_ON, 0, co,
    TONE);\n                rcvr.send(mes, -1);\n                Thread.sleep(500);\n
    \               mes.setMessage(ShortMessage.NOTE_OFF, 0, co);\n                rcvr.send(mes,
    -1);\n            } else {\n                Thread.sleep(500);\n            }\n
    \       }\n        rcvr.close();\n    }\n\n    public static void main(String[]
    args) throws Exception {\n        play(args[0]);\n        System.exit(0);\n    }\n}\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1480'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1480
  :user_name: hamano
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/25/
  :language: C
  :time: 2007/07/26 17:00 GMT
  :vote_count: '6'
  :vote_score: '6'
  :body: "\n\t  <pre class=\"compact\">サンプリングレート: 8000\r\nPCMフォーマット: 8bit\r\n% gcc
    sound.c -lm\r\nでコンパイル出来ます、linux で鳴るはずです。</pre>\n\t"
  :code: |
    include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;math.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/ioctl.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;linux/soundcard.h&gt;

    #define RATE 8000

    double sol_fa[] = {880.0, 987.0, 523.0, 587.0, 659.0, 698.0, 784.0};

    void play(int fd, const char *str){
        int i, j;
        unsigned char buf[RATE];
        double freq;
        int len = strlen(str);
        for(i=0; i&lt;len; i++){
            if('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'g')
                freq = sol_fa[str[i] - 'a'];
            else
                freq = 0;
            for (j = 0;j &lt; RATE; j++)
                buf[j] = 255 * sin(2.0 * M_PI * freq * j / RATE);
            write(fd, buf, RATE);
        }
    }

    int main( void )
    {
        int fd;
        int fmt = AFMT_U8;
        int channels = 1;
        int rate = RATE;

        fd = open("/dev/dsp", O_WRONLY);
        ioctl(fd, SOUND_PCM_SETFMT, &amp;fmt);
        ioctl(fd, SOUND_PCM_WRITE_CHANNELS, &amp;channels);
        ioctl(fd, SOUND_PCM_WRITE_RATE, &amp;rate);
        play(fd, "cdefedcrefgagfercrcrcrcrcdefedcr");
        close(fd);
        return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1504'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1504
  :user_name: 匿名
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/07/27 11:52 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">音がちゃんと消えていない理由がわかりました。\r\n23行目に間違いがあります。正しくは\r\nmes.setMessage(ShortMessage.NOTE_OFF,
    0, co, 0);\r\nでした。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1596'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1596
  :user_name: PHO
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/69/
  :language: Haskell
  :time: 2007/07/30 14:45 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">OpenAL使用。カエルの歌はあんまり好きじゃないので、曲は自分で作った。\r\n\r\n拡張仕様:\r\n*
    0-9 でオクターブ変更、デフォルト5。\r\n* C, D, F, G, A でそれぞれ元の音から半音上げる。</pre>\n\t"
  :code: "import Control.Concurrent\nimport Data.Char\nimport Data.Map (Map)\nimport
    qualified Data.Map as M\nimport Foreign.Marshal.Alloc\nimport Foreign.Marshal.Array\nimport
    Foreign.Ptr\nimport Foreign.Storable\nimport Sound.OpenAL\n\nfreqForNote :: Char
    -&gt; Double\nfreqForNote 'c' = 261.626\nfreqForNote 'C' = 277.183 -- C# (拡張仕様、互換性有)\nfreqForNote
    'd' = 293.628\nfreqForNote 'D' = 311.127 -- D# (以下同様)\nfreqForNote 'e' = 329.628\nfreqForNote
    'f' = 349.228\nfreqForNote 'F' = 369.994 -- F#\nfreqForNote 'g' = 391.995\nfreqForNote
    'G' = 415.305 -- G#\nfreqForNote 'a' = 440\nfreqForNote 'A' = 466.164 -- A#\nfreqForNote
    'b' = 493.883\nfreqForNote 'r' = 0\n\nscoreToFreqs :: String -&gt; [Double]\nscoreToFreqs
    = scoreToFreqs' 5 -- 5 が中心\n    where\n      scoreToFreqs' :: Int -&gt; String
    -&gt; [Double]\n      scoreToFreqs' _      []     = []\n      scoreToFreqs' octave
    (x:xs)\n          | isDigit x\n              -- オクターブ変更 (拡張仕様、互換性有)\n              =
    scoreToFreqs' (fromEnum x - fromEnum '0') xs\n          | otherwise\n              =
    (freqForNote x) * (2 ^^ (octave - 5))\n                : scoreToFreqs' octave
    xs\n\nmkNote :: Int -&gt; Double -&gt; Double -&gt; IO Buffer\nmkNote samplFreq
    sec noteFreq\n    = let nSamples = round $ (realToFrac samplFreq) * sec\n          bufSize
    \ = nSamples\n      in \n        allocaBytes bufSize $ \\ mem -&gt;\n        do
    renderToMemBuf mem bufSize\n           let memRegion = MemoryRegion mem (fromIntegral
    bufSize)\n               bufData   = BufferData memRegion Mono8 (realToFrac samplFreq)\n
    \          [buf] &lt;- genObjectNames 1\n           bufferData buf $= bufData\n
    \          return buf\n    where\n      renderToArray :: Int -&gt; [ALubyte]\n
    \     renderToArray len = map calcFrame [0 .. len - 1]\n\n      calcFrame :: Int
    -&gt; ALubyte\n      calcFrame n = let frame = sin $\n                                2\n
    \                               * pi\n                                * noteFreq\n
    \                               * (realToFrac n / realToFrac samplFreq)\n                    in\n
    \                     -- -1.0 &lt;= frame &lt;= 1.0\n                      floor
    $ 127 * frame + 128\n\n      renderToMemBuf :: Ptr ALubyte -&gt; Int -&gt; IO
    ()\n      renderToMemBuf mem len = pokeArray mem (renderToArray len)\n\nmkEachBuffers
    :: Int -&gt; Double -&gt; [Double] -&gt; IO (Map Double Buffer)\nmkEachBuffers
    sampleFreq sec = updateMap M.empty\n    where\n      updateMap m []     = return
    m\n      updateMap m (x:xs)\n          | M.member x m\n              = updateMap
    m xs\n          | otherwise\n              = do buf &lt;- mkNote sampleFreq sec
    x\n                   updateMap (M.insert x buf m) xs\n\nmain = do deviceM &lt;-
    openDevice Nothing\n          case deviceM of\n            Nothing\n                -&gt;
    fail \"failed to open audio device\"\n            Just dev\n                -&gt;
    do ctxM &lt;- createContext dev []\n                      case ctxM of\n                        Nothing\n
    \                           -&gt; fail \"failed to create context\"\n                        Just
    ctx\n                            -&gt; do currentContext $= Just ctx\n                                  putStrLn
    \"creating buffers...\"\n\n                                  let freqs = scoreToFreqs
    score\n                                  buffers &lt;- mkEachBuffers 8000 0.2
    freqs\n                                  notes   &lt;- mapM (flip M.lookup buffers)
    freqs\n\n                                  putStrLn \"ok. playing...\"\n\n                                  [src]
    &lt;- genObjectNames 1\n                                  -- 手抜き。全部の音符を一気にキューに\n
    \                                 -- 入れるのは本当は良くない。\n                                  queueBuffers
    src notes\n                                  play [src]\n                        \n
    \                                 waitTillDone src\n                                  putStrLn
    \"done.\"\n    where\n      waitTillDone :: Source -&gt; IO ()\n      waitTillDone
    src\n          = do state &lt;- get (sourceState src)\n               case state
    of\n                 Playing -&gt; threadDelay (50 * 1000) &gt;&gt; waitTillDone
    src\n                 _       -&gt; return ()\n\nscore :: String\n-- score = \"cdefedcrefgagfercrcrcrcrcdefedcr\"\nscore
    = \"5daagabaFed4ba\" ++ \"5daagabaFeFer\"   ++\n        \"5daagabaFedeF\"  ++
    \"5gabFede4b5eFer\" ++\n        \"5daagabaFed4ba\" ++ \"5daagabaFeFer\"   ++\n
    \       \"5daagabaFedeF\"  ++ \"5gabFede4b5eFer\" ++\n\n        \"5babaFabaFeFr\"
    \ ++ \"5eFaFed4bab5CdF\" ++\n        \"5babaFabaFeFr\"  ++ \"5eFedFabbbr6dC\"
    \ ++\n        \"5babaFabaFeFr\"  ++ \"5eFaFed4bab5CdF\" ++\n        \"5babaFabaFeFr\"
    \ ++ \"5eFedFabbbrFF\"   ++\n\n        \"5ebeFgFeged4b5d\" ++ \"5ebeFgebagbar\"
    \ ++\n        \"5ebeFgFeded4br\"  ++ \"5cdebagFFered\"  ++\n        \"5ebeFgFeged4b5d\"
    ++ \"5ebeFgebagbar\"  ++\n        \"5ebeFgFeded4br\"  ++ \"5cdebagFFerer\"  ++\n\n
    \       \"5daagabaFed4ba\" ++ \"5daagabaFeFer\"   ++\n        \"5daagabaFedeF\"
    \ ++ \"5gabFede4b5eFer\" ++\n        \"5daagabaFed4ba\" ++ \"5daagabaFeFer\"   ++\n
    \       \"5daagabaFedeF\"  ++ \"5gabFedeFed4b5d\" ++\n        \"5eee\"\n"
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1723'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1723
  :user_name: tomatsu
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/323/
  :language: Pnuts
  :time: 2007/08/02 12:47 GMT
  :vote_count: '2'
  :vote_score: '2'
  :body: "\n\t  <pre class=\"compact\"></pre>\n\t"
  :code: |
    import javax.sound.midi.*
    import static javax.sound.midi.ShortMessage.*
    code = [69, 71, 60, 62, 64, 65, 67]
    TONE = 120
    function play(mml){
      mes = new ShortMessage()
      rcvr = MidiSystem.getReceiver()
      for (c: mml) {
          if (c &gt;= 'a' &amp;&amp; c &lt;= 'g') {
              co = code[c - 'a']
              mes.setMessage(NOTE_ON, 0, co, TONE)
              rcvr.send(mes, -1)
              sleep(500)
              mes.setMessage(NOTE_OFF, 0, co)
              rcvr.send(mes, -1)
          } else {
              sleep(500)
          }
      }
      rcvr.close()
    }
    play("cdefedcrefgagfercrcrcrcrcdefedcr")
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1818'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1818
  :user_name: ether
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/96/
  :language: Tcl
  :time: 2007/08/04 14:10 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  Snack という Tcl/Python 向けの音声ライブラリを使用しました。Snack は ActiveTcl のディストリビューションにも含まれています。\n\t"
  :code: "package require snack\n\nset C     262\nset dur   4000\nset beat  5000\nset
    amp   30000\nset score cdefedcrefgagfercrcrcrcrcdefedcr\n\nset freq $C\nforeach
    note {c _ d _ e f _ g _ a _ b} {\n  set freq [expr {$freq * pow(2, 1. / 12.)}]\n
    \ set osc  [snack::filter generator $freq $amp 0.0 sine $dur]\n  snack::sound
    $note\n  $note filter $osc\n  $note length $beat\n}\nsnack::sound r; r length
    $beat\n\nsnack::sound snd\nforeach note [split $score {}] {\n  snd concatenate
    $note\n}\nsnd play -blocking yes\n# snd write kaeru.wav -fileformat WAV \n"
  :tags:
  - Snack
  :references:
    :url: 
    :title: 
- :id: '1927'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1927
  :user_name: iwk
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/49/
  :language: OCaml
  :time: 2007/08/06 10:40 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  \n\t"
  :code: |
    #light
    open System
    open System.Runtime.InteropServices
    open System.Threading

    [&lt;DllImport("kernel32.dll")&gt;]

    let Beep (dwFreq:int) (dwDuration:int) :bool = failwith ""
    let toNum = function
        | 'c' -&gt; 262
        | 'd' -&gt; 294
        | 'e' -&gt; 330
        | 'f' -&gt; 349
        | 'g' -&gt; 392
        | 'a' -&gt; 440
        | 'b' -&gt; 494
        | _ -&gt; 0

    let play (s:string) =
        for c in s do
            if (toNum c) = 0 then Thread.Sleep( 500 )
            else Beep (toNum c) 500 |&gt; (fun b -&gt; ())
        done

    do play "cdefedcrefgagfercrcrcrcrcdefedcr"
  :tags:
  - F#
  :references:
    :url: 
    :title: 
- :id: '1950'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1950
  :user_name: naoya_t
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/348/
  :language: Scheme
  :time: 2007/08/06 18:00 GMT
  :vote_count: '1'
  :vote_score: '1'
  :body: "\n\t  <pre class=\"compact\">MML からAIFFファイルを生成し（※単純な正弦波です）iTunes等のプレイヤーに渡します。\r\nとりあえず
    OS X での動作しか考えていませんが... \r\n\r\nA音の周波数設定 / テンポ / サンプリング周波数 / 純正律・平均律 / サンプルサイズ(8bit・16bit)
    / ステレオ・モノラル設定とか・・・無駄にこだわってみました。\r\n\r\nGauche 0.8.10 以降でないと動きません。</pre>\n\t"
  :code: "(use srfi-1) ;first,second,...,seventh\n(use srfi-4) ;uvector\n(use binary.io)
    ;default-endianの設定とか\n(default-endian 'big-endian)\n\n;;\n;; コンフィギュレーション\n;;\n(define
    tempo 120)\n;(define frequency-A 440.0)\n(define frequency-A 442.0)\n(define use-just-intonation
    #f) ;純正律を用いる。#fなら平均律\n(define sample-rate (* frequency-A 4)) ; 1.768KHzでサンプリング\n;(define
    sample-rate 44100) ; 44.1KHzでサンプリングとか\n;(define sample-size 8) ; sampling size
    (bit)\n(define sample-size 16)\n;(define stereo-mode #f)\n(define stereo-mode
    #t)\n\n;\n; 内部で使用する値\n;\n(define volume-maximum (floor-&gt;exact (* 0.707 (if
    (= sample-size 16) 32767 127)))) ; 0.707は適当な音量\n(define note-duration (/ 60 tempo
    2))\n(define note-sample-count (floor-&gt;exact (* sample-rate note-duration)))\n(define
    sample-bytes (ash sample-size -3))\n\n;;\n;; 自前の出力系関数\n;;\n; 80 bit IEEE Standard
    754 floating point number\n(define (write-f80 value)\n  (let ((vec (make-u8vector
    10 0))\n\t\t(sign-mask 0)\n\t\t(exp 16383))\n\t(when (&lt; value 0) \n\t\t  (set!
    sign-mask 0x8000)\n\t\t  (set! value (- value)))\n\t(let* ((log (/ (log value)
    (log 2)))\n\t\t   (exp (floor-&gt;exact log))\n\t\t   (body (/ value (expt 2 exp)))\n\t\t
    \  (first16 (logior sign-mask (+ 16383 exp))) )\n\t  (u8vector-set! vec 0 (ash
    first16 -8))\n\t  (u8vector-set! vec 1 (logand first16 255))\n\t  (let loop ((body
    (* body 128))\n\t\t\t\t (i 2))\n\t\t(when (&lt; i 10)\n\t\t\t  (let1 b (floor
    body)\n\t\t\t\t\t(u8vector-set! vec i b)\n\t\t\t\t\t(loop (* (- body b) 256) (+
    i 1))) ))\n\t  (write-block vec) ; u8vector\n\t  )))\n\n(define (write-u32-idstr
    idstr)\n  (let write-id ((chars (string-&gt;list idstr))\n\t\t\t\t (n 4))\n\t(when
    (&lt; 0 n)\n\t\t  (write-char (car chars))\n\t\t  (write-id (cdr chars) (- n 1)))))\n
    \ \n(define (write-chunk-head chunk-idstr chunk-size)\n  (write-u32-idstr chunk-idstr)\n
    \ (write-u32 chunk-size))\n\n(define (write-block-s16-bigendian vec)\n  (do ((i
    0 (+ i 1)))\n\t  ((= i (s16vector-length vec)) vec)\n\t(write-s16 (s16vector-ref
    vec i))\n\t(when stereo-mode\n\t\t  (write-s16 (s16vector-ref vec i))) ))\n;  (lambda
    (vec) (write-block vec (current-output-port) 0 -1 'big-endian)))\n\n(define (write-block-s8
    vec)\n  (do ((i 0 (+ i 1)))\n\t  ((= i (s8vector-length vec)) vec)\n\t(write-s8
    (s8vector-ref vec i))\n\t(when stereo-mode\n\t\t  (write-s8 (s8vector-ref vec
    i))) ))\n\n(define (save-as-aiff-file file-name sound-vecs)\n  (let* ((num-sample-frames
    (apply + (map (if (= sample-size 16) s16vector-length s8vector-length) sound-vecs)))\n\t\t
    (sound-chunk-size (+ 8 (* sample-bytes num-sample-frames (if stereo-mode 2 1)))))\n\t(with-output-to-file
    file-name\n\t  (lambda ()\n\t\t(write-chunk-head \"FORM\" (+ 4 26 8 sound-chunk-size))\n\t\t(write-u32-idstr
    \"AIFF\")\n\n\t\t(write-chunk-head \"COMM\" 18)\n\t\t(write-u16 (if stereo-mode
    2 1)) ; numChannels\n\t\t(write-u32 num-sample-frames) ; numSampleFrames\n\t\t(write-u16
    sample-size)\n\t\t(write-f80 sample-rate)\n\n\t\t(write-chunk-head \"SSND\" sound-chunk-size)\n\t\t(write-u32
    0) ; offset\n\t\t(write-u32 0) ; blocksize\n\t\t(if (= sample-size 16)\n\t\t\t(for-each
    write-block-s16-bigendian sound-vecs) ; write-block だとうまく行かなかった\n\t\t\t(for-each
    write-block-s8 sound-vecs))\n\t\t))))\n\n;;\n;; 簡易（というか正弦波）サウンドジェネレータ\n;;\n; ８分休符のサウンドデータを生成\n(define
    (make-pause sample-count)\n  ((if (= sample-size 16) make-s16vector make-s8vector)
    sample-count 0))\n\n; 指定した周波数で８分音符のサウンドデータを生成\n(define (make-note freq sample-count)\n
    \ (do ((vec (make-pause sample-count)) ;(make-s8vector sample-count))\n\t   (i
    0 (+ i 1)))\n\t  ((= i sample-count) vec)\n\t((if (= sample-size 16) s16vector-set!
    s8vector-set!) vec i\n\t (* volume-maximum (sin (/ (* freq 3.14159265358979323846
    2 i) sample-rate))) )))\n\n(define (make-sound-table)\n  (let* ((note-frequencies
    (map (lambda (mag) (* frequency-A mag))\n\t\t\t\t\t\t\t\t(if use-just-intonation\n\t\t\t\t\t\t\t\t\t(list
    3/5 27/40 3/4 4/5 9/10 1 9/8)\n\t\t\t\t\t\t\t\t\t(map (lambda (x) (expt 2.0 x))
    (list -3/4 -7/12 -5/12 -1/3 -1/6 0 1/6)))))\n\t\t (notes (map (lambda (freq) (make-note
    freq note-sample-count)) note-frequencies))\n\t\t (pause (make-pause note-sample-count)))\n\t(let
    ((c (first notes))\n\t\t  (d (second notes))\n\t\t  (e (third notes))\n\t\t  (f
    (fourth notes))\n\t\t  (g (fifth notes))\n\t\t  (a (sixth notes))\n\t\t  (b (seventh
    notes))\n\t\t  (r pause))\n\t  (define (sound-data-for-note note-char)\n\t\t(case
    note-char\n\t\t  ((#¥r #¥R) r)\n\t\t  ((#¥c #¥C) c)\n\t\t  ((#¥d #¥D) d)\n\t\t
    \ ((#¥e #¥E) e)\n\t\t  ((#¥f #¥F) f)\n\t\t  ((#¥g #¥G) g)\n\t\t  ((#¥a #¥A) a)\n\t\t
    \ ((#¥b #¥B) b)\n\t\t  (else r)))\n\t  (define (dispatch m)\n\t\t(case m\n\t\t
    \ ((sound-for-note) sound-data-for-note)\n\t\t  (else (print \"not defined.\"))))\n\t
    \ dispatch)))\n\n(define sound-table (make-sound-table))\n\n(define (play-mml
    mml-string)\n  (let ((aiff-file-name (string-append mml-string \".aiff\"))\n\t\t(notes
    (string-&gt;list mml-string)))\n\t(save-as-aiff-file aiff-file-name (map [sound-table'sound-for-note]
    notes))\n\t(sys-exec \"open\" (list \"open\" aiff-file-name)) ))\n\n; REPL\n(define
    (input-loop)\n  (let ((line (read-line)))\n\t(cond ((eof-object? line) 'eof)\n\t\t
    \ ((string=? \"\" line) 'quit)\n\t\t  (else (play-mml line)\n\t\t\t\t(input-loop)
    ))))\n\n(input-loop)\n"
  :tags:
  - gauche
  - joke
  :references:
    :url: 
    :title: 
- :id: '1951'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1951
  :user_name: naoya_t
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/348/
  :language: 
  :time: 2007/08/06 18:21 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">言語間違えてる\r\n　誤：awk\r\n　正：scheme\r\nどうやって直したらいいの？</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1953'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1953
  :user_name: shiro
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/41/
  :language: 
  :time: 2007/08/06 19:04 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">こういう、高レベル言語でバイナリをいじくるコード好きです。\r\n\r\nwrite-f80は組込みで持ってても良いように思い始めました。\r\n\r\nwrite-u32-idstrはdisplayじゃだめなのかな。\r\n\r\nwrite-block-s16-bigendianとwrite-block-s8は\r\n(use
    gauche.sequence)してuvectorに直接for-eachを適用すると\r\nシンプルになるかもしれません。 \r\n\r\nmake-noteでs16vector-set!とs8vector-set!を切り替えてるところですが、\r\n(set!
    (ref vec i) ...) のようにすればジェネリックに書けます。速度は遅くなりますが。\r\nさらに、(map-to &lt;s8vector&gt;
    (lambda (i) (* volume-maximum ...)) (iota sample-count))\r\nのようにするとdoループも不要です。\r\n\r\nmake-sound-tableの(let
    ((c (first notes)) (d (second notes)) ...) のところは\r\nutil.matchを使って (let-match1
    (c d e f g a b) notes ...) のようにも書けます。\r\n\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1954'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1954
  :user_name: 匿名
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/4/
  :language: C
  :time: 2007/08/06 19:56 GMT
  :vote_count: '3'
  :vote_score: '3'
  :body: "\n\t  <pre class=\"compact\">周波数は計算で出したかったのですけど複雑なので諦めました☆\r\nその代わりきらきら星をつけました☆</pre>\n\t"
  :code: |
    #include&lt;windows.h&gt;
    void play(char *p){
      for(int f[]={494,261,294,329,349,392,440};*p;p++)
        if(*p=='r')
          Sleep(400);
        else
          Beep(f[*p%7],400);
    }
    int main(void){
      play("cdefedcrefgagfercrcrcrcrcdefedcr");
      play("ccggaagrffeeddcrggffeedrggffeedrccggaagrffeeddcr");
      return 0;
    }
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1970'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1970
  :user_name: naoya_t
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/348/
  :language: 
  :time: 2007/08/07 05:57 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  shiroさん直々にご指導ありがとうございます。\r\n\r\nwrite-f80 は今回は１回（ヘッダ部分にサンプリング周波数を書き込む為だけに）しか呼び出していませんが、組み込みで用意されていたら嬉しい場面ももしかしたらあるかもしれません。\r\n\r\nライブラリモジュールをもっと活用できるよう、今後使い込んで行きたいと思います。\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '1983'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/1983
  :user_name: shimakuma
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/343/
  :language: JavaScript
  :time: 2007/08/07 10:24 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  これはなかなか素晴らしいツール。\n\t"
  :code: "(function playbeep(scr, quaver, beep){\n\tif(!beep) (beep = WSH.CreateObject(\"SfcMini.DynaCall\")).Declare(\"kernel32\",
    \"Beep\");\n\tif(!quaver) quaver = 250;\n\tvar S = { c:262, d:294, e:330, f:349,
    g:392, a:440, b:494, r:0 };\n\twith(Math) scr.replace(/([a-grA-G])(\\d?)(\\+*)(-*)(\\.?)/g,
    function($, s, t, p, m, d){\n\t\tvar hz = s.charCodeAt(0) &gt; 96 ? S[s] : round(S[s.toLowerCase()]
    * 1.06);\n\t\tvar dr = round(quaver * pow(2, p.length) * pow(2, -m.length) * (d
    ? 1.5 : 1));\n\t\tif(hz) beep(t ? hz * pow(2, t - 3) : hz, dr);\n\t\telse WSH.Sleep(dr);\n\t});\n})(\"e+g+c4++g+a+g++r.c-e.g-c4+b.a-g++.r++\");\n//
    大文字は半音上，0~9で高さ指定(省略で3)，+-.で長さ調整(伸び|縮み|付点)。\n"
  :tags:
  - JScript
  - SFCmini
  - WSH
  :references:
    :url: /web/20080329155921/http://hp.vector.co.jp/authors/VA016157/
    :title: SFC mini
- :id: '2002'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/2002
  :user_name: 匿名
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/4/
  :language: 
  :time: 2007/08/08 02:26 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">こんにちわ。\r\n上のかたの、音消しは\r\nmes.setMessage(ShortMessage.NOTE_OFF,
    0, co);\r\nではなく\r\nmes.setMessage(ShortMessage.NOTE_OFF, 0, co, 0);\r\nまたは\r\nmes.setMessage(ShortMessage.NOTE_OFF
    | 0, co, 0);\r\nではないでしょうか？\r\n</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '2374'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/2374
  :user_name: 管理者
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/411/
  :language: 
  :time: 2007/08/22 06:19 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">解説ブログ記事があったのでリンクしときます。</pre>\n\t"
  :code: ''
  :tags: []
  :references:
    :url: /web/20080329155921/http://www.cuspy.org/blog/2007/08/11/
    :title: cuspy memo 2007 August 11
- :id: '2510'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/2510
  :user_name: nakawaka
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/406/
  :language: Groovy
  :time: 2007/08/25 18:11 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">quicktimeのapi使ってますが、ただしく使えているか自信ないです...\r\n</pre>\n\t"
  :code: |
    import quicktime.QTSession
    import quicktime.std.music.ToneDescription
    import quicktime.std.music.NoteChannel
    import quicktime.std.music.NoteRequest

    // kaeru_song_player
    // cがド、dがレ、eがミ、fがファ、gがソ、aがラ、bがシ、rが休符
    def tbl = ['c':60, 'd':62, 'e':64, 'f':65, 'g':67, 'a':69, 'b':71, r:-1]
    def song = "cdefedcrefgagfercrcrcrcrcdefedcr"

    QTSession.open()
    NoteChannel noteChannel = new NoteChannel(new NoteRequest(new ToneDescription(1)))

    for(c in song){
        noteChannel.playNoteRaw(tbl[c] as int, 60)
        sleep(300)
    }

    QTSession.close()
  :tags: []
  :references:
    :url: 
    :title: 
- :id: '3226'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/3226
  :user_name: tilde
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/446/
  :language: Objective
  :time: 2007/10/02 01:36 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">Mac OSX 10.4.10(Intel)で動作確認しています。Objective-CというよりAudio
    Unitの使い方ですね。\r\n永野さんのページを参考にさせていただきました。</pre>\n\t"
  :code: "//コンパイルオプション：-std=gnu99 -fobjc-exceptions\n\n#import &lt;Foundation/Foundation.h&gt;\n#import
    &lt;AppKit/AppKit.h&gt;\n#import &lt;Audiounit/AudioUnit.h&gt;\n\nOSStatus callbackProc(
    void* inRefCon, AudioUnitRenderActionFlags* ioActionFlags,\n\t\tconst AudioTimeStamp*
    inTimeStamp, UInt32 inBusNumber,\n\t\tUInt32 inNumberFrames, AudioBufferList*
    ioData ) {\n\tstatic const char notes[] = \"cdefedcrefgagfercrcrcrcrcdefedcr\";\t//かえるの歌\n\tstatic
    const unsigned int length = sizeof notes - 1;\t//音符の数\n\tstatic const float scale[]
    = { 440, 495, 264, 297, 330, 352, 396 };\t//純正律音階\n    static const float samplingRate
    = 44100;\n\t\n\tstatic unsigned int tempo = 160;\t//テンポ:八分音符／分\n\tstatic unsigned
    int consumedFrames = 0;\t//現在の音符の発音済みフレーム数。１分間だとsamplingRate*60\n\tstatic unsigned
    int index = 0;\t//音符のインデックス\n\tstatic float phase = 0;\n\t\n\tchar note = notes[index];\n
    \   float frequency = ( note &gt;= 'a' &amp;&amp; note &lt;= 'g' ) ? scale[note
    - 'a'] : 0;\n    frequency *= 2 * M_PI / samplingRate;\n\n    float* outL = ioData-&gt;mBuffers[0].mData;\n
    \   float* outR = ioData-&gt;mBuffers[1].mData;\n\n    for ( int i = 0; i &lt;
    inNumberFrames; i++ ) {\n        float wave = sin( phase );\n        *outL++ =
    wave;\n        *outR++ = wave;\n        phase += frequency;\n    }\n\t\n\tconsumedFrames
    += inNumberFrames;\n\t//規定の時間が過ぎたら次の音符へ\n\tif ( consumedFrames &gt;= samplingRate
    * 60 / tempo ) {\n\t\tconsumedFrames = 0;\n\t\t//曲を最後まで演奏したら終了\n\t\tif ( ++index
    &gt;= length )\n\t\t\t[NSApp terminate:nil];\n\t}\n\t\n    return noErr;\n}\n\nBOOL
    initAudioUnit() {\n\t@try {\n\t\tComponentDescription description = {\n\t\t\tkAudioUnitType_Output,
    kAudioUnitSubType_DefaultOutput, \n\t\t\tkAudioUnitManufacturer_Apple, 0, 0\n\t\t};\n\t\t\n\t\tComponent
    component = FindNextComponent( NULL, &amp;description );\n\t\tif ( component ==
    0 )\n\t\t\t@throw @\"Faild to find component.\";\n\t\t\n\t\tAudioUnit audioUnit;\n\t\tif
    ( OpenAComponent( component, &amp;audioUnit ) != noErr )\n\t\t\t@throw @\"Faild
    to open component.\";\n\t\t\n\t\tAURenderCallbackStruct callbackStruct = { callbackProc,
    NULL };\n\t\tif ( AudioUnitSetProperty( audioUnit, kAudioUnitProperty_SetRenderCallback,\n\t\t\t\tkAudioUnitScope_Input,
    0, &amp;callbackStruct, sizeof callbackStruct ) != noErr )\n\t\t\t@throw @\"Faild
    to set property values for audio unit.\";\n\t\t\n\t\tif ( AudioUnitInitialize(
    audioUnit ) != noErr )\n\t\t\t@throw @\"Faild to initialize audio unit.\";\n\t\t\n\t\tif
    ( AudioOutputUnitStart( audioUnit ) != noErr )\n\t\t\t@throw @\"Faild to start
    audio unit.\";\n\t} @catch ( id error ) {\n\t\tNSLog( error );\n\t\treturn NO;\n\t}\n\t\n\treturn
    YES;\n}\n\nint main( int argc, const char** argv ) {\n    NSAutoreleasePool *
    pool = [[NSAutoreleasePool alloc] init];\n\t\n\t[NSApplication sharedApplication];\n\tif
    ( initAudioUnit() )\n\t\t[NSApp run];\n\t\n    [pool release];\n    return 0;\n}\n"
  :tags:
  - Mac
  - OSX
  :references:
    :url: /web/20080329155921/http://nagano.monalisa-au.org/?cat=3&amp;paged=2
    :title: My Codex Leicester (Monalisa-au.org)
- :id: '3729'
  :parent_id: '31'
  :url: http://ja.doukaku.org/comment/3729
  :user_name: h_sakurai
  :user_url: /web/20080329155921/http://ja.doukaku.org/user/519/
  :language: D
  :time: 2007/11/06 06:44 GMT
  :vote_count: '0'
  :vote_score: '0'
  :body: "\n\t  <pre class=\"compact\">C#の移植。Windowsのみ</pre>\n\t"
  :code: |
    extern(Windows) uint Beep(uint, uint);
    extern(Windows) void Sleep(uint);
    void main() {
        play("cdefedcrefgagfercrcrcrcrcdefedcr");
    }
    void play(string s) {
        uint[] dt = [440, 494, 262, 294, 330, 349, 392];
        foreach (char c ; s) {
            if (c == 'r') Sleep(500);
            else Beep(dt[c - 'a'], 500);
        }
    }
  :tags: []
  :references:
    :url: 
    :title: 
